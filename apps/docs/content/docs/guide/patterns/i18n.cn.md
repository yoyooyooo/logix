---
title: 国际化（i18n）
description: 在 Logix 中接入外部 i18n 实例的推荐模式（注入、token、语言切换与异步就绪）。
---

Logix 推荐把“翻译引擎”当作一个外部能力注入到 Runtime 中，而不是在每个模块里各自创建实例。这样可以保证：

- 同一棵 Runtime Tree 内共享同一个 i18n 实例；
- Logic 可以通过显式 root 单例入口获取 i18n（不受局部 `RuntimeProvider.layer` 覆写影响）；
- UI 侧仍可沿用你熟悉的 i18n 方案（例如 i18next + react-i18next）。

本指南使用 `@logixjs/i18n` 提供的最小适配层完成接入。

## 1) 注入外部 i18n 实例

`@logixjs/i18n` 定义了最小 `I18nDriver` 形状，并提供 `I18n.layer(driver)` 用于注入：

```ts
import * as Logix from "@logixjs/core"
import { Layer } from "effect"
import { I18n } from "@logixjs/i18n"

export const AppRuntime = Logix.Runtime.make(RootImpl, {
  layer: Layer.mergeAll(
    I18n.layer(i18nDriver),
    AppInfraLayer,
  ),
})
```

如果你在 React 中使用 `RuntimeProvider.layer`，也可以把 `I18n.layer(i18nDriver)` 放在**最外层**（提供 `runtime={...}` 的那层）：

- 这样 Logic 内用 `$.root.resolve(I18nTag)` 一定能拿到同一个“root provider 单例”；
- 若把 `I18n.layer(...)` 只放在内层 Provider，则它会变成局部覆写：`$.root.resolve` 会忽略它（按设计）。

## 2) 在 Logic 中获取 i18n（root 单例）

在模块 Logic 内，使用 `$.root.resolve(I18nTag)` 显式读取 root provider 提供的 i18n 服务：

```ts
import { Effect } from "effect"
import { I18nTag } from "@logixjs/i18n"

export const MyLogic = MyModule.logic(($) =>
  Effect.gen(function* () {
    const i18n = yield* $.root.resolve(I18nTag)
    // ...
  }),
)
```

## 3) Message token（推荐：把“要翻译什么”写入状态）

如果你的目标是“可回放 / 可审计 / 可重放”的状态，推荐在 Logic 中生成 **message token** 并写入 Module state：

```ts
const i18n = yield* $.root.resolve(I18nTag)
const msg = i18n.token("form.required", { field: "name", defaultValue: "Required" })
```

UI 渲染时再把 token 翻译成最终字符串（例如 `t(msg.key, msg.options)`）。语言切换后，token 本身不变，但展示结果会随 i18n 实例变化自动更新。

> token 的 `options` 只允许 `null/boolean/number/string` 等可序列化值；不要把大对象塞进去，也不要传 `lng/lngs` 等“冻结语言”的字段。

## 4) 语言切换

通过 i18n service 提供的入口切换语言：

```ts
const i18n = yield* $.root.resolve(I18nTag)
yield* i18n.changeLanguage("zh")
```

如果你希望“把语言切换也做成模块动作”，可以引入 `I18nModule`（见下节）。

## 5) 异步就绪（ready / 不等待 vs 等待）

外部 i18n 实例可能需要异步初始化。`@logixjs/i18n` 提供两档语义：

- `t(key, options)`：不等待；当 i18n 未 ready 时立即返回 fallback（`defaultValue` 或 `key`）。
- `tReady(key, options, timeoutMs?)`：等待 ready（默认上限 5 秒）；timeout/失败时返回 fallback。

这能让你在“快速可用”与“最终一致”之间按场景取舍：多数情况下，推荐在状态里保留 token，由 UI 在 ready 后自然渲染出最终文案；只有当 Logic 必须产出最终字符串时才使用 `tReady`。

## 6) I18nModule（可选：把 snapshot 暴露成模块状态）

如果你希望在 Runtime 中显式拥有一个 i18n 模块（例如让 Devtools/页面直接订阅 `snapshot`，或用 Action 驱动语言切换），可以把 `I18nModule.impl` 加入 root 的 `imports`：

```ts
import { I18nModule } from "@logixjs/i18n"

const RootModule = RootDef.implement({
  initial: { /* ... */ },
  imports: [I18nModule.impl],
})

const RootImpl = RootModule.impl
```

每棵 Runtime Tree 都可以注入不同的 `I18n.layer(driver)`，它们之间不会串实例；`I18nModule` 会在各自树内转发到同一个 i18n service。

## 可运行示例

- 索引：[可运行示例索引](../recipes/runnable-examples)
- 代码：
  - `examples/logix/src/i18n-message-token.ts`
  - `examples/logix/src/i18n-async-ready.ts`
  - `examples/logix-react/src/modules/i18n-demo.ts`
