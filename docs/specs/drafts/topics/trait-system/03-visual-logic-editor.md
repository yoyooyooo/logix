# Visual Logic Editor: The "Endgame" of StateTrait Submersion

> **The Insight**: Visual programming usually fails because it tries to replace code with a worse graphical syntax. Logix's Visual Editor doesn't replace code; it **projects** the underlying Logic Protocol (IR) that code _already generates_.

## 1. 核心架构跃迁 (Architecture Shift)

### Before: 代码即黑盒

在 Trait Submersion 之前，要实现可视化编辑器，我们必须解析 TypeScript AST。

- _用户写了什么？_ -> 各种 `useEffect` / `function` / `if-else`。
- _依赖关系在哪？_ -> 很难静态分析，除非强制用户写非常受限的 DSL。
- _结果_：编辑器要么极其简陋（只能连线不能写逻辑），要么极其复杂（必须复刻 TS 编译器）。

### After: IR 即真理

Trait Submersion 强制要求 `StateTrait` 导出完备的 `Static IR`。

- **输入明确**：`descriptor` 包含 `ReadQueryStaticIr`，甚至 `Module-as-Source` 的依赖路径。
- **输出明确**：Trait Kind (`externalStore`, `source`, `link`) 决定了节点类型。
- **流向明确**：`ownership` 和 dependencies 显式声明了数据流向。

**现在，Visual Editor 不需要理解 TypeScript，它只需要消费和生成 `StateTraitProgram (JSON)`。**

## 2. 双向工作流 (Bidirectional Workflow)

编辑器不是单向生成的工具，而是代码的 "Live View"。

```mermaid
graph LR
    Code[Source Code (.ts)] <-->|Compiler/Lowering| IR[Static IR (.json)]
    IR <-->|Projection| Canvas[Visual Editor UI]
```

### 场景 A: Code -> Visual (可解释性)

1.  开发者手写 `const $ = Logic.define(...)`。
2.  Logix Compiler 提取 `Static IR`。
3.  编辑器渲染出：
    - **Nodes**: 这一组 Traits (e.g. `query`, `selection`, `pagination`)。
    - **Edges**: 这一条依赖链 (`query` -> `fetch` -> `data`)。
4.  **价值**：新入职员工不需要读 500 行代码，看一眼图就知道数据怎么流转的。

### 场景 B: Visual -> Code (低代码构建)

1.  开发者在 Canvas 上拖拽一个 `Module Node` (e.g. `UserModule`)。
2.  从 `UserModule.outputs.currentUser` 拉一条线到当前 Logic 的 `inputs`。
3.  编辑器生成 `DeclarativeLinkIR`。
4.  Codegen 引擎在 `.ts` 文件中插入：
    ```ts
    // Auto-generated by Logix Visual Editor
    user: $.link(UserModule.source.currentUser),
    ```

## 3. 杀手级特性: Module-as-Source Linking

这是 `073` 引入 `source.kind="module"` 契约后的直接红利。

- **痛点**：以前我想用别的模块的数据，得先 import 模块，查它的 API，看它是 selector 还是 atom，然后写 glue code。
- **Visual 方案**：
  1.  编辑器知道项目中所有 Module 的 `Static IR`（因为它们都遵守协议）。
  2.  左侧面板列出 "Available Modules"。
  3.  拖拽 `AuthModule` 到画布。
  4.  展开看到 `isLoggedIn`, `token`, `userInfo`。
  5.  直接连线到当前 Logic 的 `computed`。
  6.  **代码自动生成**：系统自动处理 `moduleId` 解析、`selectorId` 绑定，生成强一致的 `StateTrait.link`。

## 4. 为什么这次能成？

历史上 Visual Editor 失败的原因往往是 **" 图灵完备性陷阱 "** —— 试图用图形表达 `for loop` 或复杂算法。

Logix 的策略是 **"逻辑分层"**：

- **复杂算法 (How)**：依然写在 TypeScript 函数里（Reducer / Selector）。Visual Editor 只显示一个 "黑盒节点" (Function Node)。
- **因果流转 (What)**：数据从哪里来 (Source)，经过谁 (Flow)，流向哪里 (Sink)。这正是 Visual Editor 擅长的。

**Visual Editor 不画算法，只画因果。** 这就是 StateTrait Submersion 带来的最终形态。
