---
title: 历史提炼：从早期探索到当前主线
status: living
---

> 目的：把早期探索中“可复用的结论”吸收到当前主线，并以统一术语与边界表述。这里不保留版本分叉，只保留可执行的经验与反模式。

## 1. 我们保留下来的三条主线

### 1.1 LLM 一等公民（可生成、可校验、可对比）

- 结构化表达的目标不是“让人读得更爽”，而是让 **LLM 能稳定生成、工具链能稳定校验、Diff 能稳定对比**。
- 因此：术语必须可裁决；IR 必须最小化；对外 API 必须有白盒子集与可降级路径。

### 1.2 意图先于实现（Intent ≠ Code）

- Intent 只表达 **What**（业务/交互/信息结构），不表达 **How**（组件选型/文件路径/实现细节）。
- “实现细节”只能作为：Pattern 资产、运行时组合（Layer/Runtime）、或代码中的可解析子集（Fluent DSL）出现。

### 1.3 行为层必须有事实源（可追踪、可回放）

- 业务逻辑不能散落为一堆不可追踪的事件处理与副作用；必须能还原为可解释的规则/链路。
- 当前主线以 **IntentRule IR + EffectOp 诊断事件** 作为统一证据链，平台与 Devtools 都应只认 IR/事件，不认“口头约定”。

## 2. 关于“分层”的关键教训：细分不是目的

早期探索曾尝试把前端意图拆成更多层级（例如 Layout/View/Interaction/Behavior/Data/Code Structure）。这在概念上有启发，但也带来明确代价：

- 层级过细会导致 **概念碎片化**：同一条业务链路被拆散到多个文档与资产，难以维护单一事实源。
- “工程结构/文件路径”并不属于业务意图，应当退回到 **约束（Constraints）或 Pattern 的工程约定**，而不是让需求/意图层承担。

因此当前主线采用更稳定的三位一体（详见 `../02-intent-layers.md`）：

- **UI**：布局/视图结构 + 纯视觉交互（不触及业务副作用）
- **Logic**：触发器 + 流程编排 + 副作用边界（Service/Dispatch/State）
- **Module**：领域模型 + Schema + 服务契约 + 领域错误（通用语言）

> 映射规则：把“代码结构”从分层体系中移除，作为平台/工程的落地约束；把“交互”拆为 UI 的视觉交互 与 Logic 的业务触发。

## 3. 关于 Pattern 与 Plan：保留“资产化”，弱化“文档化”

早期提出过 Intent / Pattern / Plan 的分离，其中可复用的结论是：

- **Pattern 必须资产化**：运行时形态收敛为 `(input) => Effect`（或返回 Logic 单元的工厂），平台只在外层包 metadata（id/configSchema/tags）。
- **Plan 必须可执行**：但它不应成为另一套“版本化大文档”。当前仓库将可交付计划收敛到 `specs/<id>/{spec,plan,tasks}.md`，并把“长期方向”留给 `blueprint.md`。

## 4. 我们明确拒绝的反模式（持续警戒）

- 用多套版本目录维护同一主题，形成并行真相源（规范漂移不可控）。
- 把“如何组织代码/文件”当成意图的一部分（应回归工程约束与生成器模板）。
- 让平台/实现细节反过来定义概念（概念裁决必须先于实现，见 `../99-glossary-and-ssot.md`）。

