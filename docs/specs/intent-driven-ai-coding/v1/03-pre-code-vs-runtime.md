---
title: 出码前 vs 运行时 · 概念与资产划分
status: draft
version: v1
---

> 本文聚焦 toB 管理系统前端团队，明确意图驱动体系中哪些概念和资产属于「出码前」（类似低代码阶段），哪些属于「出码后」运行时。

## 1. 为什么要刻意区分？

如果不区分出码前/出码后，很容易出现两个极端：

- 要么把所有东西都塞进“低代码平台”，最后所有人都绕着平台写 hack；
- 要么完全放弃平台，只拿 AI 当自动补全，意图和模式停留在 PPT 上。

我们希望：

- 出码前：集中在**表达意图、选择模式、制定生成计划**；
- 出码后：集中在**在约束内写好业务逻辑与 UI**；
- 平台和 AI 在中间做可靠的“翻译和执行”。

## 2. 出码前资产（Pre-code Assets）

出码前资产主要是“设计与规划层”的东西，通常不会直接进入生产运行时。

> 当前团队的出码前资产，主要落地在 IMD 仓库 `/Users/yoyo/projj/git.imile.com/ux/imd` 与 best-practice 仓库 `/Users/yoyo/projj/git.imile.com/ux/best-practice` 的组合环境中：前者提供组件库与注册表结构，后者提供文件/状态/服务层的实践规范与代码片段。但它们都是本规划的输入与实现载体，真正的抽象核心仍然是 Intent / Pattern / Template Meta / Plan。

### 2.1 意图资产（Intent）

- 描述业务目标、场景结构、所选模式、领域契约；
- 形式：`*.intent.yaml` + 说明文档；
- 读/写：产品、前端、AI 共同参与；
- 用途：
  - 作为生成/重构的入口；
  - 作为需求与实现之间的桥梁。

### 2.2 模式定义（Pattern）

- 描述可复用的编码模式及其约束；
- 形式：`*.pattern.yaml`/`*.pattern.md`；
- 读/写：架构/平台前端为主，业务前端阅读和选择；
- 用途：
  - 提供模式选型依据；
  - 指导模板实现和代码评审。

### 2.3 模板元数据（Template Meta）

- 描述模板实现了哪些模式、需要哪些参数、有哪些变体；
- 不含具体代码，只含契约；
- 形式：`*.template.yaml`；
- 读/写：模板作者、平台前端；
- 用途：
  - 帮工具把意图/模式参数映射到具体模板；
  - 帮 AI 了解“可以自动填哪些、必须人工选哪些”。

### 2.4 生成计划（Generation Plan）

- 从意图 + 模式 + 模板推导出的“出码计划”；
- 形式：`*.plan.json`；
- 内容包含：
  - 将创建/更新/删除哪些文件；
  - 每个文件来源于哪个模板/模式；
  - 参数/插槽的具体值；
  - 执行顺序、依赖关系；
- 读/写：
  - 由平台/工具生成；
  - 由业务前端审阅、裁剪、确认。

### 2.5 执行日志与映射（Execution Log & Mapping）

- 记录每次执行计划时的具体行为和结果；
- 形式：结构化日志 + “意图/模式/模板 ↔ 代码”的映射表；
- 用途：
  - 追溯一段代码是如何生成的；
  - 反向导航：从代码跳回对应意图和模式；
  - 支持 AI 做“解释”和“重构建议”。

## 3. 出码后资产（Runtime Assets）

出码后资产是在浏览器/前端运行时真正被加载执行的东西。

### 3.1 业务页面与组件

- 生成/手写的页面组件、表单组件、图表组件等；
- 格式：实际的 `*.tsx` / `*.vue` / 其他前端文件；
- 读/写：
  - 业务前端维护；
  - 平台侧工具可能执行“增量修改”，但不应随意覆盖。

### 3.2 公共运行时库

- 表格组件、表单框架、状态管理封装、权限控制、错误边界等；
- 由平台/架构提供和维护；
- 模式通常会基于这些库来实现行为一致性。

### 3.3 模式的运行时实现

- 标准工作台布局组件、列表+详情容器、审批流容器等；
- 这些可以看作是“模式在运行时的物理形态”；
- 模板生成的代码通常会组合使用这些组件/Hook。

### 3.4 运行时流程内核（可选）

- 某些跨页面、跨组件的复杂流程（例如导入导出、批量任务执行）可以有一个小的“流程内核”；
- 内部可以使用更复杂的技术（例如函数式 Effect/DI 框架），对外用简单 API 或 Hook 封装。

## 4. 角色在出码前/出码后各做什么？

> 默认假设：平台的直接用户是前端开发。产品/运营等需求方通过其他渠道提供输入，但不直接在平台中操作。

### 4.1 业务前端（兼任产品角色）

- 出码前：
  - 基于外部需求输入创建和维护意图草稿；
  - 补全意图资产中的模式/领域信息；
  - 审阅生成计划，决定哪些部分自动生成、哪些部分手写；
  - 触发生成/更新代码。
- 出码后：
  - 在生成的代码基础上做业务特化；
  - 当变更涉及结构/模式层时，推动回写意图资产。

### 4.3 平台 / 架构前端

- 出码前：
  - 维护模式库和模板元数据；
  - 把“常犯错的写法”抽象成模式层的约束，而不是埋在评审口头意见里；
  - 迭代生成引擎和校验规则。
- 出码后：
  - 维护公共运行时库和模式实现；
  - 为业务团队提供“从代码返回意图/模式”的导航工具。

### 4.4 AI 代理

- 出码前：
  - 辅助意图结构化、模式匹配、参数填充；
  - 在计划生成前做一致性和缺失检查；
  - 用自然语言解释“为什么推荐某模式/模板”。
- 出码后：
  - 结合映射信息，解释某段代码背后的意图与模式；
  - 为小规模改动提议：是直接在代码里改，还是先改意图再生成。

## 5. 与 toB 管理系统场景的契合点

在 toB 管理后台里，这种划分尤其重要：

- 场景稳定但需求变化频繁：  
  很多页面本质上是“列表+详情”“工作台”“审批流”的变种，适合用模式+意图统一管理。
- 团队成员角色分明：  
  产品/前端/架构划分清晰，有利于把意图编辑、模式维护、模板实现分角色落地。
- 长期演进：  
  管理后台通常长期存在，意图与模式的沉淀可以显著降低后续迭代成本。

因此，把“意图/模式/模板/计划”视为**出码前资产**，把“页面/组件/运行时库”视为**出码后资产**，是整个体系落地的关键前提。
