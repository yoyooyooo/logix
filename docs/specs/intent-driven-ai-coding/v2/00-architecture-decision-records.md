---
title: 00 · 架构演进与决策记录 (v2 Snapshot)
status: archived
---

> 本文档是 v2 时期的架构决策快照，详细记录了“六层模型”的设计背景与理由。虽然已被 v3 取代，但其对问题的拆解思路仍具参考价值。

## ADR-002: 确立“六层意图”模型 (v2)

*   **日期**: 2025-11-20
*   **状态**: **Superseded by ADR-003**
*   **背景**: 
    在 v1 阶段，Intent、Pattern 和 Plan 的概念混杂在一起，导致 LLM 难以生成高质量的代码。为了解决这个问题，团队认为需要对前端工程进行“全切面”的解构，试图穷尽所有开发细节，以便让 LLM 在每个切面上都能精准工作。
*   **当时的方案 (The Six Layers)**:
    我们将前端意图拆解为六个独立的层级：
    1.  **Layout Intent (布局)**：
        *   *定义*：页面的分区结构（如 Sidebar, Header, Content）。
        *   *目的*：解决“页面长什么样”的宏观问题。
    2.  **View & Component Intent (视图)**：
        *   *定义*：区域内的具体组件模式（如 Table, Form）。
        *   *目的*：解决“区域里放什么”的微观问题。
    3.  **Interaction Intent (交互)**：
        *   *定义*：用户操作（Click/Hover）与 UI 反馈或信号触发的绑定。
        *   *目的*：试图将“交互”从组件和逻辑中剥离出来独立管理。
    4.  **Behavior & Flow Intent (行为)**：
        *   *定义*：业务信号的处理流程（Service Call, Branch）。
        *   *目的*：解决“业务逻辑怎么跑”的问题。
    5.  **Data & State Intent (数据)**：
        *   *定义*：实体定义、状态存储位置（Local vs Global）。
        *   *目的*：解决“数据长什么样、存在哪”的问题。
    6.  **Code Structure Intent (工程结构)**：
        *   *定义*：模块拆分、文件路径、目录规范。
        *   *目的*：试图让 LLM 显式控制代码文件的组织方式。
*   **决策理由**：
    当时认为“分得越细，LLM 越好控制”。通过显式定义 `Code Structure`，希望解决 LLM 生成代码时文件乱放的问题；通过独立 `Interaction`，希望实现 UI 与逻辑的解耦。
*   **反思与教训**：
    虽然出发点是好的，但这种分类方式是**“实现导向”**而非**“意图导向”**的。特别是 `Code Structure`，它实际上是 Constraint 或 Pattern 的产物，不应由用户（尤其是 PM）来定义。六层模型导致了信息的碎片化，增加了系统的熵。

## ADR-001: 意图驱动开发 (v1)

*   **日期**: 2025-10-01
*   **状态**: **Superseded by ADR-002**
*   **背景**: 
    传统低代码平台灵活性不足，而直接写代码又缺乏规范且难以维护。LLM 的出现提供了新的可能，但直接让 LLM 生成代码往往不可控。
*   **当时的方案**:
    *   提出 **"Intent"** 概念，作为自然语言和代码之间的中间层 DSL。
    *   引入 **Pattern** (模式) 和 **Plan** (执行计划) 的概念。
    *   Intent 主要是一个扁平的 JSON 配置，混合了 UI、逻辑和数据配置。
*   **决策理由**：
    需要一个结构化的载体来承载 LLM 的思考结果，而不是直接生成代码文件。
*   **反思**：
    v1 验证了“意图驱动”的可行性，但由于 Intent 结构定义过于随意（混合大杂烩），导致复杂场景下 LLM 无法生成稳定的结果，也无法支持复杂的业务逻辑编排，因此催生了 v2 的分层探索。
