# Advanced Scenarios (进阶场景压力测试)

> **Status**: Draft  
> **Purpose**: 覆盖核心场景之外，在真实业务中高频出现、且对 Logix API 设计有较强约束力的复杂场景；用于在设计/实现阶段对 API 做压力测试与对齐。

---

## 1. 状态形态 & 路径系统

### Scenario 1.1: 深层嵌套与可选字段
**描述**：`user.addresses[0].geo.location.lat` 这类深层、部分节点可选的结构，既要支持安全读写，又要避免在逻辑中手动判空/构造中间对象。  
**目标**：验证 `getPath` / `set` 在路径不存在时的行为约定（自动补全、返回默认值或显式失败），以及这套约定是否便于 AI 生成稳定逻辑。

### Scenario 1.2: 判别联合类型切换
**描述**：`payment` 根据 `type` 区分不同子结构，例如 `"card"` / `"cash"` / `"transfer"`，切换 `type` 时需要重置/迁移对应分支字段。  
**目标**：验证在单个 `watch('payment.type', ...)` 中处理结构变化的可读性，及路径系统对“清空一整个分支”的支持能力。

### Scenario 1.3: 动态字典 / Map
**描述**：以 `itemsById[id].status` 为代表的动态键结构，需要支持“监听任意 entry 变化”和“只监听特定 key”。  
**目标**：压测 Logix 是否需要提供字典级别的监听能力（如 `watch('itemsById.*.status', ...)`），以及通配符路径在类型与实现上的可行性。

---

## 2. 多触发条件 & 派生状态

### Scenario 2.1: 多字段约束（区间合法性）
**描述**：`startDate <= endDate`、`min <= max` 等需要同时读取多个字段的约束与校验。  
**目标**：验证使用单路径 `watch` + `get` 读取其他字段是否足够自然，是否需要 `watchMany(['startDate', 'endDate'], ...)` 之类 API。

### Scenario 2.2: 聚合字段（汇总统计）
**描述**：购物车总价 `summary.total = sum(items[*].total)`，任何一行的 `quantity` / `price` / `discount` 变化都需要刷新总计与汇总信息。  
**目标**：压测 Logix 对“聚合派生状态”的表达能力，以及是否需要专门的聚合工具（如 `derive` / `selector` 风格）。

### Scenario 2.3: 条件派生链（多级联动）
**描述**：`country` 变化 → 重置地区 → 自动按新地区加载默认仓库 → 刷新依赖仓库的多个派生字段。  
**目标**：验证多级联动在逻辑数组中的组织方式，避免出现“难以追踪的链式触发”和隐藏循环。

---

## 3. 循环依赖 & 自激发防护

### Scenario 3.1: 间接循环依赖
**描述**：A 字段变更触发规则更新 B，B 更新又触发规则修改 A 的一部分（例如格式化/归一化），可能形成间接循环。  
**目标**：明确 Logix 对“同一 tick 内重复写同一路径”的去重策略，以及如何避免在规则层面产生难以察觉的循环。

### Scenario 3.2: 双向绑定风格（外部源 + 手工编辑）
**描述**：`price` 同时受外部源（如 WebSocket 行情）和用户手工编辑影响，需要区分“外部推送”和“用户输入”，避免互相刺激形成来回写。  
**目标**：验证 `watch` / `mount` 是否需要引入来源标记（meta），以及 Logix 是否提供防止自触发的机制。

### Scenario 3.3: 多规则冲突（写同一路径）
**描述**：多个规则都试图更新 `shipping.method`，例如“根据地区自动选择默认方式”与“根据重量强制升级方式”，在部分条件下可能互相覆盖。  
**目标**：压测 Logix 对“规则优先级”“合并策略”是否需要显式约束，或者通过文档约定“一个字段只允许一个写规则”等风格规范。

---

## 4. 并发控制 & 提交场景

### Scenario 4.1: 表单提交并发控制
**描述**：用户在提交按钮上快速多次点击，业务期望只执行一次（或串行执行），并正确维护 `isSubmitting`、`submitError` 等状态。  
**目标**：验证 Logix 是否提供提交级并发策略（如 `exhaust` / `restart`），以及与 `watch`/`on` 的组合方式。

### Scenario 4.2: 自动保存 + 手动保存协同
**描述**：自动保存逻辑按固定间隔或变更累计触发，用户也可以随时点击“保存”；两种保存需要共享节流/幂等语义，避免相互抢占或重复提交。  
**目标**：压测在同一个 Store 中协调多条保存逻辑时的表达方式，以及是否需要“逻辑分组”或“命名通道”概念。

### Scenario 4.3: 多服务并行调用与部分成功
**描述**：一次操作中并行调用 A/B/C 三个服务，允许部分成功并更新对应子状态，同时收敛错误并反馈给用户。  
**目标**：验证在 `watch` 中组合 `Effect.all` / `Effect.allWith` 等并发原语时，Logix 对错误通道路由、部分成功写入与回滚策略的兼容性。

---

## 5. 生命周期 & 多实例

### Scenario 5.1: 多 Store 实例并存
**描述**：同一页面上创建 N 个 Store 实例（例如多行可编辑表格的行级 Store），需要确保 Scope/资源按实例隔离，销毁时不互相影响。  
**目标**：压测 `makeStore` 的 Scope 策略，在高并发创建/销毁实例场景下的资源释放与订阅管理。

### Scenario 5.2: 延迟初始化与自动销毁
**描述**：只有在第一次有订阅者（例如 React 组件挂载）时才真正执行初始化逻辑，所有订阅者都卸载一段时间后自动销毁 Store。  
**目标**：验证 Logix 是否需要内建“init-on-first-subscribe / auto-dispose”策略，还是通过 Adapter / 外层 Runtime 负责。

### Scenario 5.3: 跨页面持久化状态
**描述**：会话级 Store 生命周期跨越多个页面或路由，页面卸载时不销毁 Store，但重新挂载时不能重复注册逻辑或泄露资源。  
**目标**：压测在长期存活的 Scope 下，逻辑初始化与多次挂载/卸载的幂等性。

---

## 6. 外部源 / 挂载与解除

### Scenario 6.1: 轮询与条件暂停
**描述**：按固定间隔轮询某接口刷新列表，当用户切换到其他 Tab 或满足某条件时暂停轮询，再切回时恢复。  
**目标**：验证 `mount`/`on` 是否方便与条件流组合，实现“条件化订阅”和优雅的暂停/恢复。

### Scenario 6.2: 第三方缓存源整合（如 React Query）
**描述**：把 React Query / SWR 等数据源作为外部流挂载到 Store 中，同时允许 Store 中的逻辑触发“重新拉取”或“失效”。  
**目标**：压测 Logix 在“状态源桥接”场景下的双向交互能力，以及对第三方库生命周期的适配难度。

### Scenario 6.3: 资源清理与异常恢复
**描述**：WebSocket、EventSource 等长连接在网络抖动、服务端断开等异常情况下，需要正确重连或释放资源，关闭 Store 时必须彻底清理。  
**目标**：验证 Scope + finalizer 在异常路径上的表现，以及是否需要 Logix 提供统一的 retry/backoff 策略挂点。

---

## 7. 错误流 & 观测性

### Scenario 7.1: 领域错误上屏与集中管理
**描述**：某些规则返回领域错误（校验失败、业务 reject 等），需要统一映射到 `errors.*` 路径或 `error$` 流，并驱动 UI 显示。  
**目标**：压测 Logix 对错误通道的建模方式，确保业务逻辑无需手写大量 try/catch 也能收敛错误。

### Scenario 7.2: 全局错误处理与局部吞掉
**描述**：同时存在全局错误处理器（记录日志、上报 telemetry）和局部逻辑内的错误捕获，有些错误需要在局部被“吞掉”不冒泡。  
**目标**：验证 Logix 是否支持 per-rule 与 global handler 的叠加与优先级设计。

### Scenario 7.3: Trace / DevTools 视角下的执行链路
**描述**：在复杂联动场景中，通过 Trace 或 DevTools 看到完整的“字段变更 → 规则触发 → 服务调用 → 状态更新”链路。  
**目标**：压测 Logix 是否在规则执行、状态变更、服务调用等关键节点打点足够的 Span/Metadata。

---

## 8. 性能与背压

### Scenario 8.1: 高频输入与背压策略
**描述**：拖动 slider 或实时搜索输入产生的高频事件，服务端或网络无法承受全部请求，需要在前端进行防抖、节流或丢弃。  
**目标**：验证 Logix 对 debounce/throttle、队列长度、丢弃策略（drop/latest/buffer 等）的配置能力及可组合性。

### Scenario 8.2: 大列表批量更新
**描述**：一次操作导致上千条记录的变化（批量选中/取消、统一设值），要求在性能可接受的前提下保证状态一致性。  
**目标**：压测 `set`/`setPath` 是否需要提供批处理/事务性更新能力，以及对订阅者通知策略的影响。

### Scenario 8.3: 订阅粒度与局部重渲染
**描述**：对大对象，部分订阅者只关心其中某些字段变化（例如某一行、某一字段），希望避免整对象 diff 和全量重渲染。  
**目标**：从 Logix 角度明确 `state$` 是否只提供整体流，还是需要提供局部投影/选择器机制以支撑高性能 Adapter。

---

## 9. AI / 平台集成 & 动态逻辑

### Scenario 9.1: 动态注入与替换逻辑
**描述**：AI 或配置中心在运行时增删/替换某些逻辑规则（例如新增一个校验、调整联动行为），不销毁现有 Store。  
**目标**：验证 Logix 是否支持 LogicRule 的动态注册/注销及其生命周期管理。

### Scenario 9.2: JSON 意图解释执行与 TS 等价性
**描述**：同一业务逻辑既可以由 TS `watch` 代码表示，也可以由 JSON AST（Intent → Flow）解释执行，二者在行为和 Trace 上应保持等价。  
**目标**：压测未来 JSON 解释器设计对 Logix API 的要求，例如逻辑序列化、规则标识与调试信息。

### Scenario 9.3: 多版本逻辑共存与灰度
**描述**：旧版本逻辑仍在跑（线上实例），新版本逻辑已部署，需要按租户/用户/实验组切换逻辑版本，并支持回滚。  
**目标**：验证 Logix 是否需要对“逻辑版本/命名空间”提供一等公民支持，或者通过外层运行时管理。

---

## 10. 多租户 / 安全与隔离

### Scenario 10.1: 多租户隔离的 Store 与 Services
**描述**：一个 Logix 进程内为多个租户提供服务，每个租户拥有独立的 Store 与 Services，实现与配置完全隔离。  
**目标**：压测 Context / Layer 组合在多租户场景下的隔离性，避免数据或配置泄漏。

### Scenario 10.2: 权限约束与能力检测
**描述**：部分逻辑只有在具备特定能力（例如 `canApprove`）的环境下才允许执行，缺失能力时应 fail 或退化为 no-op。  
**目标**：验证通过 `Services` 类型和运行时校验表达权限约束的最佳实践。

### Scenario 10.3: 数据脱敏与日志合规
**描述**：在 Telemetry/日志中不记录敏感字段原文，但仍能完整调试逻辑链路（例如通过字段名/哈希）。  
**目标**：压测 Logix 在 Trace/日志接口上是否提供足够的扩展点，以支撑脱敏策略和合规要求。
