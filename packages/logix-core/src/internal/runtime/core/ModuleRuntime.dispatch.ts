import { Effect, PubSub } from 'effect'
import type { StateChangeWithMeta, StateCommitMeta, StateCommitMode, StateCommitPriority } from './module.js'
import * as Debug from './DebugSink.js'
import type { ConcurrencyDiagnostics } from './ConcurrencyDiagnostics.js'
import * as ReducerDiagnostics from './ReducerDiagnostics.js'
import * as StateTransaction from './StateTransaction.js'
import type { RunOperation } from './ModuleRuntime.operation.js'
import type { RunWithStateTransaction, SetStateInternal } from './ModuleRuntime.transaction.js'
import type { EnqueueTransaction } from './ModuleRuntime.txnQueue.js'
import type { ResolvedConcurrencyPolicy } from './ModuleRuntime.concurrencyPolicy.js'

export const makeDispatchOps = <S, A>(args: {
  readonly optionsModuleId: string | undefined
  readonly instanceId: string
  readonly initialReducers?: Readonly<
    Record<string, (state: S, action: A, sink?: (path: StateTransaction.StatePatchPath) => void) => S>
  >
  readonly txnContext: StateTransaction.StateTxnContext<S>
  readonly readState: Effect.Effect<S>
  readonly setStateInternal: SetStateInternal<S>
  readonly recordStatePatch: (
    path: StateTransaction.StatePatchPath | undefined,
    reason: StateTransaction.PatchReason,
    from?: unknown,
    to?: unknown,
    traitNodeId?: string,
    stepId?: number,
  ) => void
  readonly actionHub: PubSub.PubSub<A>
  readonly actionCommitHub: PubSub.PubSub<StateChangeWithMeta<A>>
  readonly diagnostics: ConcurrencyDiagnostics
  readonly enqueueTransaction: EnqueueTransaction
  readonly resolveConcurrencyPolicy: () => Effect.Effect<ResolvedConcurrencyPolicy>
  readonly runOperation: RunOperation
  readonly runWithStateTransaction: RunWithStateTransaction
  readonly isDevEnv: () => boolean
}): {
  readonly registerReducer: (tag: string, fn: (state: S, action: A) => S) => void
  readonly dispatch: (action: A) => Effect.Effect<void>
  readonly dispatchBatch: (actions: ReadonlyArray<A>) => Effect.Effect<void>
  readonly dispatchLowPriority: (action: A) => Effect.Effect<void>
} => {
  const {
    optionsModuleId,
    instanceId,
    initialReducers,
    txnContext,
    readState,
    setStateInternal,
    recordStatePatch,
    actionHub,
    actionCommitHub,
    diagnostics,
    enqueueTransaction,
    resolveConcurrencyPolicy,
    runOperation,
    runWithStateTransaction,
    isDevEnv,
  } = args

  // Primary reducer map: initial values come from options.reducers and can be extended at runtime via internal hooks (for $.reducer sugar).
  const reducerMap = new Map<string, (state: S, action: A) => S>()
  if (initialReducers) {
    for (const [key, fn] of Object.entries(initialReducers)) {
      reducerMap.set(key, fn as (state: S, action: A) => S)
    }
  }

  // Track whether an Action tag has been dispatched, for diagnosing config issues like late reducer registration.
  const dispatchedTags = new Set<string>()

  const registerReducer = (tag: string, fn: (state: S, action: A) => S): void => {
    if (reducerMap.has(tag)) {
      // Duplicate registration: throw a config error with extra context; catchAllCause emits diagnostics.
      throw ReducerDiagnostics.makeReducerError('ReducerDuplicateError', tag, optionsModuleId)
    }
    if (dispatchedTags.has(tag)) {
      // Registering after the tag has already been dispatched is a risky config; surfaced via a custom error type for diagnostics.
      throw ReducerDiagnostics.makeReducerError('ReducerLateRegistrationError', tag, optionsModuleId)
    }
    reducerMap.set(tag, fn)
  }

  const applyPrimaryReducer = (action: A) => {
    const tag = (action as any)?._tag ?? (action as any)?.type
    if (tag == null || reducerMap.size === 0) {
      return Effect.void
    }
    const tagKey = String(tag)
    dispatchedTags.add(tagKey)
    const reducer = reducerMap.get(tagKey)
    if (!reducer) {
      return Effect.void
    }

    return readState.pipe(
      Effect.flatMap((prev) =>
        Effect.gen(function* () {
          const patchPaths: Array<StateTransaction.StatePatchPath> = []
          const sink = (path: StateTransaction.StatePatchPath): void => {
            if (typeof path === 'string') {
              if (path.length > 0) patchPaths.push(path)
              return
            }
            if (typeof path === 'number') {
              if (Number.isFinite(path)) patchPaths.push(Math.floor(path))
              return
            }
            if (path.length > 0) patchPaths.push(path)
          }

          const next = (reducer as any)(prev, action, sink) as S

          // No-op reducer: avoid dirty evidence to prevent redundant converge/validate full paths.
          if (Object.is(next, prev)) {
            return
          }

          // Prefer the traceable in-transaction path:
          // - If the reducer provides patchPaths (e.g. generated by Logix.Module.Reducer.mutate), record field-level patches.
          // - Otherwise deterministically fall back to dirtyAll (path="*") and emit a migration diagnostic in dev mode.
          if (txnContext.current) {
            if (patchPaths.length > 0) {
              StateTransaction.updateDraft(txnContext, next)
              for (const path of patchPaths) {
                recordStatePatch(path, 'reducer')
              }
              return
            }

            StateTransaction.updateDraft(txnContext, next)
            recordStatePatch('*', 'reducer', undefined, next)

            if (isDevEnv()) {
              yield* Debug.record({
                type: 'diagnostic',
                moduleId: optionsModuleId,
                instanceId,
                txnSeq: txnContext.current?.txnSeq,
                txnId: txnContext.current?.txnId,
                trigger: txnContext.current?.origin,
                code: 'state_transaction::dirty_all_fallback',
                severity: 'warning',
                message:
                  'Reducer writeback did not provide field-level dirty-set evidence; falling back to dirtyAll scheduling.',
                hint: 'Prefer Logix.Module.Reducer.mutate(...) or $.state.mutate(...) inside the transaction to produce field-level patchPaths.',
                kind: 'dirty_all_fallback:reducer',
              })
            }

            return
          }

          yield* setStateInternal(next, '*', 'reducer', undefined, next)
        }),
      ),
    )
  }

  const makeActionOrigin = (originName: string, action: A): StateTransaction.StateTxnOrigin => ({
    kind: 'action',
    name: originName,
    details: {
      _tag: (action as any)?._tag ?? (action as any)?.type,
      path: typeof (action as any)?.payload?.path === 'string' ? ((action as any).payload.path as string) : undefined,
      op: (() => {
        const tag = String((action as any)?._tag ?? (action as any)?.type ?? '')
        if (tag.includes('Remove') || tag.includes('remove')) return 'remove'
        if (
          tag.includes('Append') ||
          tag.includes('Prepend') ||
          tag.includes('Insert') ||
          tag.includes('Swap') ||
          tag.includes('Move') ||
          tag.includes('append') ||
          tag.includes('prepend') ||
          tag.includes('insert') ||
          tag.includes('swap') ||
          tag.includes('move')
        ) {
          return 'insert'
        }
        if (tag.includes('Unset') || tag.includes('unset')) return 'unset'
        return 'set'
      })(),
    },
  })

  const dispatchInTransaction = (action: A): Effect.Effect<void> =>
    Effect.gen(function* () {
      // Apply the primary reducer first (may be a no-op).
      yield* applyPrimaryReducer(action)

      // Record action dispatch (for Devtools/diagnostics).
      yield* Debug.record({
        type: 'action:dispatch',
        moduleId: optionsModuleId,
        action,
        instanceId,
        txnSeq: txnContext.current?.txnSeq,
        txnId: txnContext.current?.txnId,
      })

      // actionsWithMeta$: provides stable txnSeq/txnId anchors for higher-level subscriptions (e.g. Process).
      const current = txnContext.current
      if (current) {
        const meta: StateCommitMeta = {
          txnSeq: current.txnSeq,
          txnId: current.txnId,
          commitMode: ((current as any).commitMode ?? 'normal') as StateCommitMode,
          priority: ((current as any).priority ?? 'normal') as StateCommitPriority,
          originKind: current.origin.kind,
          originName: current.origin.name,
        }
        yield* PubSub.publish(actionCommitHub, { value: action, meta })
      }
    })

  const runDispatch = (action: A): Effect.Effect<void> =>
    runOperation(
      'action',
      'action:dispatch',
      {
        payload: action,
        meta: { moduleId: optionsModuleId, instanceId },
      },
      runWithStateTransaction(makeActionOrigin('dispatch', action), () => dispatchInTransaction(action)),
    ).pipe(Effect.asVoid)

  const runDispatchLowPriority = (action: A): Effect.Effect<void> =>
    runOperation(
      'action',
      'action:dispatchLowPriority',
      {
        payload: action,
        meta: { moduleId: optionsModuleId, instanceId },
      },
      runWithStateTransaction(makeActionOrigin('dispatchLowPriority', action), () =>
        Effect.gen(function* () {
          if (txnContext.current) {
            ;(txnContext.current as any).commitMode = 'lowPriority' as StateCommitMode
            ;(txnContext.current as any).priority = 'low' as StateCommitPriority
          }
          yield* dispatchInTransaction(action)
        }),
      ),
    ).pipe(Effect.asVoid)

  const runDispatchBatch = (actions: ReadonlyArray<A>): Effect.Effect<void> => {
    if (actions.length === 0) return Effect.void

    return runOperation(
      'action',
      'action:dispatchBatch',
      {
        payload: actions,
        meta: { moduleId: optionsModuleId, instanceId },
      },
      runWithStateTransaction({ kind: 'action', name: 'dispatchBatch', details: { count: actions.length } }, () =>
        Effect.gen(function* () {
          if (txnContext.current) {
            ;(txnContext.current as any).commitMode = 'batch' as StateCommitMode
            ;(txnContext.current as any).priority = 'normal' as StateCommitPriority
          }
          for (const action of actions) {
            yield* dispatchInTransaction(action)
          }
        }),
      ),
    ).pipe(Effect.asVoid)
  }

  const publishWithPressureDiagnostics = (triggerName: string, publish: Effect.Effect<unknown>): Effect.Effect<void> =>
    Effect.gen(function* () {
      const startedAt = Date.now()
      yield* publish
      const elapsedMs = Date.now() - startedAt

      // fast-path: treat 0ms as "no backpressure wait observed" to avoid parsing policy per dispatch.
      if (elapsedMs <= 0) {
        return
      }

      const policy = yield* resolveConcurrencyPolicy()
      yield* diagnostics.emitPressureIfNeeded({
        policy,
        trigger: { kind: 'actionHub', name: triggerName },
        saturatedDurationMs: elapsedMs,
      })
    })

  return {
    registerReducer,
    // Note: publish is a lossless/backpressure channel and may wait.
    // Must run outside the transaction window (FR-012) and must not block the txnQueue consumer fiber (avoid deadlock).
    dispatch: (action) =>
      enqueueTransaction(runDispatch(action)).pipe(
        Effect.zipRight(publishWithPressureDiagnostics('publish', PubSub.publish(actionHub, action))),
      ),
    dispatchBatch: (actions) =>
      enqueueTransaction(runDispatchBatch(actions)).pipe(
        Effect.zipRight(publishWithPressureDiagnostics('publishAll', PubSub.publishAll(actionHub, actions))),
      ),
    dispatchLowPriority: (action) =>
      enqueueTransaction(runDispatchLowPriority(action)).pipe(
        Effect.zipRight(publishWithPressureDiagnostics('publish', PubSub.publish(actionHub, action))),
      ),
  }
}
