This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
effect-standard/
  README.md
specs/
  intent-driven-ai-coding/
    v1/
      design/
        layout.md
      examples/
        04-export-orders-flow-example.md
        order-management-crud-example.md
      intents/
        expense-approval-center.intent.yaml
        ops-workbench.intent.yaml
        order-management.intent.yaml
      patterns/
        approval-flow.pattern.yaml
        crud-feature-skeleton.pattern.yaml
        filter-bar.pattern.yaml
        list-page.pattern.yaml
        service-adapter-query.pattern.yaml
        table-with-server-filter.pattern.yaml
        toolbar-with-quick-edit.pattern.yaml
        wizard-form.pattern.yaml
        workbench-layout.pattern.yaml
        zustand-store-with-slices.pattern.yaml
      plans/
        order-management.plan.json
      poc/
        model/
          intent.ts
          pattern.ts
          runtime-services.example.ts
          template.ts
        cli.ts
        effect.ts
        execution.ts
        planning.ts
        README.md
        services.ts
      prd/
        intent-studio-prototype/
          public/
            vite.svg
          src/
            components/
              intent-studio/
                intent-tabs.tsx
              copilot-bar.tsx
              file-tree-preview.tsx
              flow-simulator.tsx
              flow-viewer.tsx
              intent-selector.tsx
              pattern-editor-sections.tsx
              pattern-form.tsx
              pattern-gallery.tsx
              pattern-intent-reference.tsx
              pattern-manager.tsx
              pattern-nav-tabs.tsx
              pattern-params-editor.tsx
              pattern-registry-view.tsx
              pattern-roles-editor.tsx
              pattern-runtime-binds.tsx
              pattern-runtime-section.tsx
              pattern-studio.tsx
              pattern-ui-schema-editor.tsx
              pipeline-header.tsx
              pipeline-shell.tsx
              plan-console.tsx
              platform-assets.tsx
              requirement-intake.tsx
              results-dock.tsx
              role-panels.tsx
              role-switcher.tsx
              template-explorer.tsx
            contexts/
              plan-simulation-context.tsx
            data/
              raw/
                flows/
                  export-orders.flow.ts
                intents/
                  ops-workbench.intent.json
                  order-management.intent.json
                patterns/
                  filter-bar.pattern.json
                  service-adapter-query.pattern.json
                  table-with-server-filter.pattern.json
                  toolbar-with-quick-edit.pattern.json
                  workbench-layout.pattern.json
                  zustand-store-with-slices.pattern.json
                plans/
                  order-management.plan.json
                templates/
                  order-list-feature-skeleton.template.json
              requirements/
                index.ts
                ops-workbench.usecase.json
                order-export.usecase.json
              index.ts
            hooks/
              use-plan-simulator.ts
            lib/
              virtual-file-tree.ts
            routes/
              assets.tsx
              dashboard.tsx
              index.tsx
              intent-create.tsx
              intent-detail.tsx
              intent-page.tsx
              intents-list.tsx
              pattern-create.tsx
              pattern-detail.tsx
              pattern-edit.tsx
              pattern-registry.tsx
              patterns.tsx
            stores/
              use-intent-store.ts
              use-pattern-store.ts
              use-session-store.ts
            styles/
              global.css
            types/
              index.ts
            App.tsx
            main.tsx
          .gitignore
          index.html
          package.json
          tsconfig.json
          tsconfig.node.json
          vite.config.ts
        README.md
      schema/
        intent.schema.json
        pattern.schema.json
        plan.schema.json
        README.md
        template.schema.json
      templates/
        order-list-feature-skeleton.template.yaml
        workbench-feature-skeleton.template.yaml
      01-overview.md
      02-patterns-and-intents.md
      03-pre-code-vs-runtime.md
      04-platform-design.md
      05-effect-ts-integration.md
      06-platform-ui-and-interactions.md
      07-ui-capabilities-and-design-system.md
      08-flow-dsl-and-ast.md
      09-llm-collaboration-and-intent-workflow.md
      10-best-practice-effect-integration-roadmap.md
      services.md
    v2/
      design/
        behavior-and-flow.md
        code-structure.md
        constraints-and-quality.md
        data-and-state.md
        interaction.md
        layout.md
        view-and-component.md
      effect-poc/
        scenarios/
          approval-flow/
            env.ts
            flow.ts
          bulk-operations/
            env.ts
            flow.ts
          crud-form/
            env.ts
            flow.ts
          dependent-selects/
            env.ts
            flow.ts
          file-import/
            env.ts
            flow.ts
          long-task-polling/
            env.ts
            flow.ts
          optimistic-toggle/
            env.ts
            flow.ts
          order-export/
            env.ts
            flow.ts
          search-with-debounce/
            env.ts
            flow.ts
        shared/
          effect-types.ts
        README.md
      01-overview.md
      02-intent-layers.md
      03-assets-and-schemas.md
      04-intent-to-code-example.md
      05-platform-ux.md
      06-intent-linking-and-replay.md
      06-intent-linking-and-traceability.md
      97-effect-runtime-and-flow-execution.md
      98-intent-boundaries-and-open-questions.md
      99-long-term-blueprint.md
      SCHEMA_EVOLUTION.md
    README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="effect-standard/README.md">
---
title: Effect 运行时与 Flow 场景规范（PoC）
status: draft
version: 0
---

> 本目录用于沉淀「意图驱动 + effect-ts 运行时」下的编码规范与场景模式，优先围绕 ToB 典型场景做业务压力测试，再反向收敛成 Env/Flow/Constraint 的约定。

## 1. 总体目标

- 为 Behavior & Flow Intent 提供一套 **可复用的 effect-ts 写法**，而不是把 Intent 变成“YAML 版代码”；  
- 用一批复杂 ToB 场景（订单列表+筛选+批量+导出、文件导入+预览+错误回放等）验证 Env/Flow/Constraint 的边界是否合理；  
- 为后续 Studio/平台化预留清晰契约：`FlowDslV2` → `.flow.ts` Effect 程序 → Env/Layer/Constraint。

## 2. Env 约定：按服务分桶，而不是按 API

在 `packages/effect-runtime-poc/src/shared/base.ts` 中定义了：

- `BasePlatformEnv`：提供 `logger`、`clock` 等平台级能力；  
- 各场景 Env 必须通过扩展 `BasePlatformEnv` 来引入领域服务，例如：

```ts
export interface OrdersComplexEnv extends BasePlatformEnv {
  OrderFilterService: OrderFilterService
  OrderListService: OrderListService
  OrderSelectionService: OrderSelectionService
  OrderBulkUpdateService: OrderBulkUpdateService
  OrderExportService: OrderExportService
  TableStateService: TableStateService
  NotificationService: OrdersNotificationService
  AuditService: OrdersAuditService
}
```

规范要点：

- [[MUST]] Env 采用“领域/技术服务”为粒度，例如 `OrderListService`、`OrderExportService`、`AuditService`，**禁止**按单个 HTTP API 或 URL 分桶；  
- [[MUST]] Flow 只依赖服务语义（方法入参/出参），不感知 HTTP 细节（URL、header、status code）；  
- [[SHOULD]] 场景 Env 命名为 `<UseCase>Env`，例如 `OrdersComplexEnv`、`FileImportWithPreviewEnv`；
- [[SHOULD]] 横切能力（日志/审计/重试等）通过 `BasePlatformEnv` 扩展或 Layer 提供，而不是在每个 Flow 内手动堆叠。

## 3. Flow 命名与职责划分

所有 Flow 均以 `Fx<R, E, A>` 形式存在（`Fx` 为 `Effect.Effect` 类型别名），命名上遵循：

- [[MUST]] 使用动词开头，表达完整业务动作，而非单步技术细节，例如：  
  - `refreshListFlow`：刷新订单列表；  
  - `bulkUpdateThenExportFlow`：批量更新订单状态并提交导出任务；  
  - `pollExportStatusFlow`：轮询导出任务进度；  
  - `analyzeAndMaybeImportFlow`：文件预览并按条件启动导入；  
  - `fetchImportResultFlow`：获取导入结果与失败明细。
- [[MUST]] 单个 Flow 保持“单一责任 + 完整闭环”：  
  - 要么完成一次业务动作（提交导出、启动导入、批量更新并审计）；  
  - 要么完成一段独立控制流（轮询、预览分析、结果查询）。  
- [[SHOULD]] 更长的业务链条通过多个 Flow 组合，而不是在单个 Flow 中塞下所有步骤，以便在 FlowIntent/FlowDslV2 中有映射空间。

## 4. 典型场景模式

### 4.1 订单列表 + 筛选 + 批量更新 + 导出 + 轮询

对应文件：`packages/effect-runtime-poc/src/scenarios/ordersComplex.ts`。

模式要点：

- [[MUST]] 列表刷新单独一个 `refreshListFlow`，只处理「filters → list」；  
- [[MUST]] 批量操作 Flow（`bulkUpdateThenExportFlow`）内部：  
  - 先读取当前筛选条件 `OrderFilterService.getCurrentFilters`；  
  - 按 scope 决定操作对象（`selected` 使用 `OrderSelectionService`，`allByFilter` 只带 filters）；  
  - 调用 `OrderBulkUpdateService.applyStatusChange` 完成批量更新；  
  - 通过 `AuditService.record` 记录操作审计；  
  - 读取 `TableStateService.getCurrentState`，用可见列发起 `OrderExportService.submitExportTask`；  
  - 再次审计导出行为。  
- [[SHOULD]] 轮询逻辑单独由 `pollExportStatusFlow` 承担，内部使用简单 `while` + `Effect.async`，未来可替换为基于 `Effect.Schedule` 的策略 Layer；  
- [[MUST]] Flow 内部允许使用 `NotificationService` 提示用户，但文本语义保持通用（不绑定具体组件）。

### 4.2 文件导入 + 预览 + 错误明细

对应文件：`packages/effect-runtime-poc/src/scenarios/fileImport.ts` 与 `fileImportWithPreview.ts`。

模式要点：

- `uploadAndStartImportFlow`：负责「上传文件 → 启动导入任务」，不包含轮询；  
- `pollImportStatusFlow`：负责「轮询任务状态 → 结束时记录状态」；  
- `analyzeAndMaybeImportFlow`：  
  - 通过 `PreviewService.analyze` 生成 `ImportPreview`（总行数/合法行数/示例行）；  
  - 根据 `autoStart` 与 `invalidCount` 决定是否直接启动导入（`uploadAndStartImportFlow`）；  
  - 通过可选 `NotificationService` 给出用户提示（有无错误行、是否已提交任务）。  
- `fetchImportResultFlow`：  
  - 调用 `ImportResultService.getImportResult` 获取任务状态与失败行；  
  - 根据结果发出成功/部分失败/失败的提示；  
  - 记录日志，方便后续在 Flow Studio/监控中回放。

## 5. 可观测性与约束（草案）

当前 PoC 中：

- [[MUST]] 所有 Flow 在关键步骤前后调用 `env.logger.info`，携带必要上下文（例如 `taskId`、`scope`、`filters`、`columns` 等）；  
- [[SHOULD]] 将审计类需求统一下沉到 `AuditService`，Flow 只描述“何时记录什么类型”；  
- [[MAY]] 在未来通过 ConstraintIntent + Layer，将重试/超时/退避等策略从 Flow 中抽离成可配置项。

后续演进方向：

- 从这些场景中抽取共性约束（标准轮询策略、批量操作默认审计字段、导出/导入任务统一状态机），收敛到单独的 Constraint/Layer 规范；  
- 为 FlowIntent/FlowDslV2 定义一组最小必要字段，使其既能表达上述模式，又不泄漏具体实现细节。
</file>

<file path="specs/intent-driven-ai-coding/v1/design/layout.md">
---
title: 布局意图 · 网格线稿与 AI 布局生成
status: draft
version: v1
---

> 本文聚焦一个问题：在 AI 时代，前端开发者如何**快速、自由地表达页面布局意图**，让平台与 LLM 帮我们把「线稿」转成可落地的布局结构与代码，而不是再回到拖栅格/手写 HTML 的老路。

## 1. 问题重述：布局意图 vs 传统栅格

传统前端布局的表达方式大致有几种：

- 直接在代码里写：`div + flex/grid` + 一堆 class；
- 在 UI Builder 里拖拽 Row/Col，调 `span/offset`；
- 在设计工具（Figma）里画线框，然后开发者自己脑补结构。

这些方式的共同问题：

- **表达成本高**：开发者脑子里明明只是一张「粗略分区图」，却要立刻翻译成抽象的 `span=8/16`、`flex-1` 等技术细节；
- **复用困难**：布局意图无法以结构化方式沉淀，只能作为具体代码/设计稿的一部分，被动复用；
- **与模式/模板割裂**：布局往往先靠感觉拼出来，再去套模式，难以把“布局意图”直接映射到 Pattern/Template。

我们希望的形态是：

> 开发者只画一张“线稿级”的布局草图，平台把它解析成结构化布局意图（Layout Intent），再交给模式/模板/LLM 生成 HTML 结构和样式。

## 2. 布局意图的目标与边界

**布局意图（Layout Intent）要解决的，不是 Pixel 级美术问题，而是：**

1. 页面有几个“主要区域”？
2. 每个区域的大致位置与相对大小？（上/下/左/右、多列/单列）
3. 这些区域的语义是什么？（例如 filters / toolbar / table / metrics 等）

它**不负责**：

- 组件内部的微观布局（表单项如何对齐、按钮间距是多少）；
- 响应式所有细节（mobile 断点上每一个排列差异）；
- 动画/视觉风格（阴影、圆角、配色）。

这些内容应由 Pattern/Template + 设计系统接管。布局意图是**线稿**：只负责“大的块”和“它们叫什么”。

## 3. 网格线稿交互：n×m 矩阵 + 上色

### 3.1 基本构想

提供一个类似 Excel 的 n×m 网格：

- 比如 4×4 或 6×4（数量可配置，但必须克制）；
- 用户可以按住鼠标拖动，连续选中一个矩形区域，如同合并单元格；
- 松开后给这个区域上色（或自动分配颜色），并允许输入一个 label；
- 多个色块之间的边界自然形成页面的“分区线”。

示意：

- 顶部一整行色块 → header；
- 底下左 3/4 宽、右 1/4 宽 → 主内容 + 侧栏；
- 右下再切一小条 → 操作栏等。

### 3.2 线稿转结构化 Layout JSON

当用户完成上色并给区域命名后，平台可以做几步处理：

1. **识别色块**：
   - 将连续同色单元格合并为矩形区域：`(x, y, w, h)`；
   - 给每个区域一个 id 和 label：例如 `filters/table/metrics/sidebar` 等。

2. **构造布局树**：
   - 根据区域的上下/左右相邻关系，推断出一个布局树：

   ```json
   {
     "type": "vertical",
     "children": [
       { "slot": "header", "ratio": 1 },
       {
         "type": "horizontal",
         "children": [
           { "slot": "leftPane", "ratio": 3 },
           { "slot": "rightPane", "ratio": 1 }
         ]
       }
     ]
   }
   ```

3. **附加语义信息**：
   - 用户可为每个 slot 选择/输入语义标签：
     - `filters / toolbar / table / metrics / detail / sidebar / footer ...`
   - 系统把这些标签同步到 `Intent.scene.layout` 或 Pattern config 中：
     - 例如 list-page 场景下，将 `filters / toolbar / table` 与 Pattern 的 target 对齐。

4. **生成 Layout Intent**：
   - 形成一个 Layout Intent 对象：

   ```ts
   interface LayoutRegion {
     id: string
     label: string
     role: string // filters/table/toolbar/metrics...
     area: { x: number; y: number; w: number; h: number }
   }

   interface LayoutIntent {
     gridSize: { rows: number; cols: number }
     regions: LayoutRegion[]
     tree: LayoutNode // 上文推导出的 vertical/horizontal 树
   }
   ```

### 3.3 Layout Intent → Flex/Grid HTML

一旦有了 Layout Intent，后续 pipeline 可以有两层：

1. **规则层**（不用 LLM）
   - 根据 layout 树生成通用的 flex/grid 结构：
     - 垂直栈：`flex-col` + children；
     - 水平栈：`flex-row` + `basis-[ratio]`；
     - 也可以直接映射到 `grid-template-rows/cols`。
   - 生成一个语义 slot 组件骨架，例如：

   ```tsx
   export function LayoutShell({ filters, toolbar, table, metrics }: Props) {
     return (
       <div className="flex flex-col h-full">
         <div className="flex-none">{filters}</div>
         <div className="flex-none">{toolbar}</div>
         <div className="flex-1 overflow-auto">{table}</div>
       </div>
     )
   }
   ```

2. **LLM 层**
   - 输入：
     - Layout Intent（regions + tree + labels）；
     - 当前项目的布局规范（例如 preferred flex/grid 写法、breakpoints）；
     - 已选 Pattern（例如 list-page/workbench-layout）。
   - 输出：
     - 语义清晰的容器组件代码（命名、props、接口）；
     - 适配 Pattern/Template 所需的 slot 名称和 props；
     - 根据规范生成响应式建议（例如 sidebar 在移动端折叠到底部）。

这样，开发者只需画一次“色块线稿”，平台就能给出一套高度合理的布局 shell，而不必手撸所有栅格细节。

## 4. 为什么不复刻拖栅格，而要用网格线稿？

关键在于：**网格线稿是意图表达，而不是实现细节**。

### 4.1 拖 Row/Col 的问题

- 用户必须理解 12 栅格/24 栅格等抽象概念；
- 必须手动输入 span/offset 或拖到合适宽度；
- 一旦想调整布局，往往要重新调多个 Row/Col 的 span。

这是在直接操作“实现结构”，而不是表达“我想要什么分区”。

### 4.2 网格线稿的优势

- 用户只需要“看着画”——选中区域、上色、起名；
- 不需要记住任何栅格数字，视觉直觉即可；
- 网格粒度可以很粗（例如 4×4），刚好只表达相对大小，而不是像素。

**只要我们严格限制粒度与职责，这会比拖栅格更快，而不是多一个复杂工具。**

## 5. 与 Intent / Pattern / Plan 的关系

布局线稿不是一个孤立组件，它要嵌入到既有的 Intent / Pattern / Plan 流水线里。

### 5.1 Intent.scene.layout 的来源

当前 Intent 中的 `scene.layout` 是直接在 YAML 中手写区域：

```yaml
scene:
  type: list-page
  layout:
    regions:
      - id: filters
        label: 筛选区
        role: filter-bar
      - id: toolbar
        label: 工具栏
        role: actions
      - id: table
        label: 列表
        role: data-table
```

改造后：

- 这些 region 不再由开发者手写，而是由布局线稿工具生成；
- region 的 `area` 信息（x/y/w/h）只在内部用于推导 layout 树，可选是否持久化；
- `role` 与 Pattern 的 target 对齐，例如 `filters/table/toolbar` 对应 filter-bar/table-with-server-filter/toolbar-with-quick-edit。

### 5.2 Pattern 的布局参数

很多 Pattern（尤其是 layout 模式，如 `workbench-layout`）本身有自己的布局参数：

```yaml
paramsSchema:
  layoutMode:
    type: string
    enum: [two-column, three-row]
  leftPanelId:
    type: string
  rightPanelId:
    type: string
  metricsRegionId:
    type: string
```

布局线稿可以帮助：

- 自动为这些参数提供候选值（从 regions.id/role 中推导）；
- 提示“当前线稿与所选 Pattern 是否适配”（例如没有 metrics 区域但选择了 workbench-layout，就标黄）；
- 为 Pattern Studio 提供示例 layout（模式文档里可附上典型线稿）。

### 5.3 Template / Plan 的生成

Layout Intent + Pattern config 可以参与 Template → Plan 的决策：

- 根据布局树决定生成哪些容器组件、文件路径；
- 根据 slot role 决定哪些 Pattern 实例挂在哪个 slot 下；
- 根据 Layout Intent 提示开发者：某些区域未配置 Pattern/Template，是否补充。

最终 Plan 中的 `create-file` actions 可以明确说明每个文件对应哪个布局 slot。

## 6. UX 设计原则：要比写 HTML 快，否则就不要做

布局线稿工具成立的前提是：

> 表达布局意图的速度和清晰度，必须**显著优于**手写 HTML 或拖栅格，否则它只是一种“酷炫的多余”。

因此，在交互设计上需要非常克制：

### 6.1 控制网格分辨率

- 默认提供 4×4 或 6×4，足够表达“上/下/左右/大/小”；
- 不提供 24×24 级别的细粒度，以免用户陷入 Pixel 级调节；
- 如需更细控制，交给 Pattern/Template（例如 ProLayout、UI 库的 grid 组件），而不是线稿工具。

### 6.2 辅以简短语义输入

- 每个色块至少要有一个 `label`，并可选择 `role`；
- “只画不命名”会让 LLM 缺乏语义，生成意图的价值大打折扣；
- 建议提供常用 role 快捷按钮（filters/table/toolbar/metrics/sidebar/footer 等）。

### 6.3 立即看到“彩稿级”结果

- 在画布下方或右侧实时展示：
  - Layout Intent JSON 预览；
  - 生成的 React Layout Shell 代码 preview；
  - 对应 Pattern 参数自动填充情况（例如 workbench-layout 的 panelId）。
- 让用户在几秒钟内看到“我画的线稿已经变成了有 slot 的 Layout 组件”，否则会怀疑价值。

### 6.4 保留回退与微调

- 用户可以修改色块（拖动/扩展/拆分）并重新生成 Layout Intent；
- 生成的代码不应成为黑盒：
  - 平台保存“线稿 → Intent.scene.layout → LayoutShell 组件”之间的映射；
  - 当 Layout Intent 变更时，可以生成差异提示，而不是全量覆盖。

## 7. 与“高维画布”的关系

本方案只覆盖布局层面的线稿：

- 我们不在这个网格里表达所有行为/数据/代码结构；
- 行为 Flow、模块依赖图仍应有自己专属的可视化（小画布/图表）。

未来可以在更高层次提供“全局画布”：

- 布局线稿只是全局画布中的一个视图层（Layout Layer）；
- 行为 Flow Layer 叠加在其上（点击某块区域中的按钮，显示相关 Flow）；
- 代码结构 Layer 则展示此布局对应的组件树/目录结构；
- 但这些都建立在**各层线稿工具已经足够好用**的前提上。

## 8. 对现有规划与原型的影响

引入布局线稿后，我们需要对规划与原型做以下调整：

1. **Intent Studio 中增加 Layout 视图**：
   - 用网格线稿替代/补充 YAML 形式的 `scene.layout`；
   - 将区域 label/role 与 Pattern target 对齐；
   - Layout Intent 作为 Intent 的一部分保存。

2. **Pattern Studio 中增加 Layout 示例与适配提示**：
   - 对 layout 类模式（如 workbench-layout）展示典型线稿；
   - 对当前 Intent 的 Layout Intent 做适配性校验，并给出提示。

3. **生成控制台中展示 Layout Shell**：
   - 在 Plan 预览中，展示根据 Layout Intent 生成的 LayoutShell 组件；
   - 标明各 slot 对应的 Pattern/Template 绑定。

4. **文档层面**：
   - 明确区分布局意图、组件/交互意图、行为 Flow 意图、代码结构意图；
   - 布局线稿仅承担其中一层的表达责任。

## 9. 下一步 PoC 建议

为了验证这个设计是否比拖栅格/手写 HTML 更“有意义”，建议先做一个极简 PoC：

1. 在原型中增加一个简单的 4×4 网格画布：
   - 支持矩形选区、上色、label 输入；
   - 显示 Layout Intent JSON 预览。

2. 添加一个 LayoutShell 预览区：
   - 使用纯算法将布局树映射到 flex 布局；
   - 不引入 LLM，仅做规则层验证。

3. 再接入一次 LLM：
   - 将 Layout Intent + 当前项目的布局规范喂给 LLM；
   - 生成更语义化的 LayoutShell 代码（组件名、props 等）；
   - 对比人工写的布局代码，评估可读性与调整成本。

如果这个 PoC 的体验被认为“确实比拖栅格/手写 HTML 更快、更清晰”，再将其纳入 v1 的平台交互；否则宁可保留旧方式，也不要做一个华而不实的新玩具。
</file>

<file path="specs/intent-driven-ai-coding/v1/examples/04-export-orders-flow-example.md">
---
title: 示例 · 订单导出 Flow（runtimeFlows → FlowAst → Effect → Hook）
status: draft
version: v1
---

## 1. 场景简介

- **业务意图**：在订单列表页顶部点击“导出”按钮时，自动读取当前筛选条件与表格列信息，生成导出任务。
- **对应 Intent**：`docs/specs/intent-driven-ai-coding/v1/intents/order-management.intent.yaml`
- **定位**：这是一个纯行为层示例，不涉及 CLI/Plan，而是展示 Flow DSL 和 `.flow.ts` 在运行时如何配合。

## 2. 中间产物与文件

| 层级 | 产物 | 位置 / 说明 |
| --- | --- | --- |
| Intent 行为 DSL | `runtimeFlows` 中的 `exportOrders` | `order-management.intent.yaml` |
| FlowAst | 由 `Flow DSL` 解析到内存对象 | 示例代码见下文 |
| Effect 行为文件 | `.flow.ts` | `src/features/order-management/flows/export-orders.flow.ts`（示例路径） |
| Hook | `useExportOrders` | `src/features/order-management/hooks/use-export-orders.hook.ts` |
| 组件 | `OrdersToolbar` | `src/features/order-management/components/orders-toolbar.tsx` |

## 3. 行为定义（Intent.runtimeFlows → FlowAst）

在 Intent 中声明 Flow：

```yaml
runtimeFlows:
  - id: exportOrders
    trigger:
      element: toolbar.exportButton
      event: click
    pipeline:
      - call: FilterService.getCurrentFilters
        as: filters
      - call: TableUiStateService.getCurrentState
        as: tableState
      - call: ExportService.submitExportTask
        params:
          filters: "{{filters}}"
          columns: "{{tableState.visibleColumns}}"
```

解析为 FlowAst（示意）：

```ts
type FlowStep =
  | {
      _tag: 'Call'
      service: 'FilterService' | 'TableUiStateService' | 'ExportService'
      method: string
      as?: string
      params?: Record<string, unknown>
    }

interface FlowAst {
  id: string
  trigger: { element: string; event: string }
  pipeline: FlowStep[]
}

const exportOrdersAst: FlowAst = {
  id: 'exportOrders',
  trigger: { element: 'toolbar.exportButton', event: 'click' },
  pipeline: [
    {
      _tag: 'Call',
      service: 'FilterService',
      method: 'getCurrentFilters',
      as: 'filters',
    },
    {
      _tag: 'Call',
      service: 'TableUiStateService',
      method: 'getCurrentState',
      as: 'tableState',
    },
    {
      _tag: 'Call',
      service: 'ExportService',
      method: 'submitExportTask',
      params: {
        filters: '{{filters}}',
        columns: '{{tableState.visibleColumns}}',
      },
    },
  ],
}
```

## 4. Effect 行为文件（`.flow.ts`）

行为层将 FlowAst 映射为 Effect 程序：

`src/features/order-management/flows/export-orders.flow.ts`：

```ts
// 这里的 Effect 类型可以采用 effect-ts，也可以采用 v1/poc/effect.ts 中的简化版本。
type Effect<R, E, A> = (env: R) => Promise<A>

// Env 中包含行为层所需的 Service 接口
export interface ExportOrdersEnv {
  FilterService: {
    getCurrentFilters: Effect<unknown, never, { [key: string]: unknown }>
  }
  TableUiStateService: {
    getCurrentState: Effect<
      unknown,
      never,
      { visibleColumns: string[]; [key: string]: unknown }
    >
  }
  ExportService: {
    submitExportTask: Effect<
      { filters: unknown; columns: string[] },
      Error,
      void
    >
  }
}

export type ExportOrdersEffect = Effect<ExportOrdersEnv, Error, void>

export const exportOrdersFlow: ExportOrdersEffect = async (env) => {
  const filters = await env.FilterService.getCurrentFilters({})
  const tableState = await env.TableUiStateService.getCurrentState({})
  await env.ExportService.submitExportTask({
    filters,
    columns: tableState.visibleColumns,
  })
}
```

要点：

- `.flow.ts` 只定义 Effect 与 Env，不依赖 React；
- Flow DSL 中的 Service ID（FilterService/TableUiStateService/ExportService）对应 Env 中的接口；
- 平台或 LLM 可以直接对这个 Effect 文件做增量修改，而不必碰组件。

## 5. Hook：桥接 Flow 与 UI

在 UI 层，用一个 Hook 将 Flow 暴露为简单的事件处理函数：

`src/features/order-management/hooks/use-export-orders.hook.ts`：

```ts
import { useCallback } from 'react'
import type { ExportOrdersEffect, ExportOrdersEnv } from '../flows/export-orders.flow'

// 简化版 runEffect；真实项目中可替换为 effect-ts 的 runPromise 或定制运行器
async function runEffect<R, E, A>(eff: (env: R) => Promise<A>, env: R) {
  return eff(env)
}

function createExportOrdersEnv(): ExportOrdersEnv {
  // 这里注入具体实现，例如基于 Zustand/TanStack Query 的服务
  return {
    FilterService: {
      getCurrentFilters: async () => {
        // 从 Store 或 Hook 读取当前筛选条件
        return {}
      },
    },
    TableUiStateService: {
      getCurrentState: async () => {
        // 从 Store 或 Hook 读取表格 UI 状态
        return { visibleColumns: [] }
      },
    },
    ExportService: {
      submitExportTask: async ({ filters, columns }) => {
        // 调用后端导出接口
        void filters
        void columns
      },
    },
  }
}

export function useExportOrders(flow: ExportOrdersEffect = exportOrdersFlow) {
  const env = createExportOrdersEnv()

  const handleExport = useCallback(async () => {
    await runEffect(flow, env)
  }, [flow, env])

  return { handleExport }
}
```

## 5. 组件：只声明“意图”，不关心实现

最终在组件中，只需要这样使用：

```tsx
import { useExportOrders } from '../hooks/use-export-orders.hook'

export function OrdersToolbar() {
  const { handleExport } = useExportOrders()

  return (
    <div className="flex justify-end gap-2">
      <button type="button" onClick={handleExport}>
        导出当前筛选
      </button>
    </div>
  )
}
```

组件层：

- 只关心“点击按钮触发导出”这一意图；
- 不关心 filters/tableState 从哪里来、导出逻辑如何实现；
- 导出行为完全由 `.flow.ts` 中的 Effect 程序表达，并与 Intent.runtimeFlows 对应。

## 6. 小结：Flow + Effect 如何在行为层闭环

在“导出订单”这个例子中：

- **Intent 层**：在 `order-management.intent.yaml` 中定义 `exportOrders` Flow；
- **行为层（Effect）**：在 `.flow.ts` 中实现 `exportOrdersFlow: Effect<Env, Error, void>`；
- **调用层（Hook/组件）**：用 `useExportOrders` 将 Flow 暴露为 `handleExport`，组件只负责绑定事件。

这样：

- 意图（Flow DSL）与行为实现（Effect）之间有清晰的对应关系；
- 行为实现不被散落在多个组件/Store 中，而是集中在 `.flow.ts` 行为文件；
- 运行时是否使用 effect-ts，只影响 Effect 类型和运行器实现，不影响 Intent/Flow 的结构。

## 6. CLI 角色？

本示例聚焦运行时行为，不通过 CLI 执行。  
如果将 Flow 也纳入出码 pipeline，可以在 Plan 中加入 “生成 `.flow.ts`” 的动作，然后由 CLI 写出行为文件；当前阶段 CLI 只处理结构产物，行为层由开发者通过 `.flow.ts` + Hook 落地。
</file>

<file path="specs/intent-driven-ai-coding/v1/examples/order-management-crud-example.md">
---
title: 示例 · 订单管理 CRUD 场景（Intent → Pattern → Plan → CLI 执行）
status: draft
version: v1
---

> 本文可以**独立阅读**：即使不了解仓库其它文档，也能看到一个完整的「意图 → 模式 → 出码计划 → CLI 执行 → 产物」链路。  
> 示例场景：订单管理列表（筛选 + 列表 + 快速编辑 + 导出）。

## 1. 场景简介与目标

- **业务目标**
  - 在单页内完成订单的筛选、列表浏览、快速编辑和导出；
  - 向 LLM/平台提供一个结构化意图，便于自动生成骨架代码。
- **示例文件**
  - Intent：`docs/specs/intent-driven-ai-coding/v1/intents/order-management.intent.yaml`
  - CLI：`docs/specs/intent-driven-ai-coding/v1/poc/cli.ts`
  - Planning/Execution：`poc/planning.ts` / `poc/execution.ts`

接下来按“阶段 → 产物 → 关键字段/代码 → 输出”顺序展开。

---

## 2. 意图（Intent）

**文件**：`docs/specs/intent-driven-ai-coding/v1/intents/order-management.intent.yaml`

关键字段：

- `scene.type: list-page` → 驱动模式匹配；
- `patterns` → 声明选择的模式及其参数；
- `domain.entities/apis` → 供后续模板使用；
- `runtimeFlows` → 描述导出行为（参见 `04-export-orders-flow-example.md`）。

节选：

```yaml
patterns:
  - id: table-with-server-filter
    target: table
    config:
      entity: Order
      pagination: true
      batchActions:
        - export
  - id: filter-bar
    target: filters
    config:
      inlineSearch: true
      showResetButton: true
      fields:
        - status
        - createdAt
  - id: toolbar-with-quick-edit
    target: toolbar
    config:
      supportQuickEdit: true
      supportExport: true
      editableFields:
        - remark
```

**作用**：  
这一份 YAML 就是「意图」本体。后一切花哨的东西（模式匹配、Plan、模板、CLI）都只是在消费它。

---

## 3. 模式（Pattern Repo）

在真实平台里，Pattern 定义位于 `docs/specs/intent-driven-ai-coding/v1/patterns/*.pattern.yaml`。  
为了让 PoC CLI 自给自足，我们在 `poc/cli.ts` 里内置了最小模式集 `basePatternMetas`：

```ts
const basePatternMetas: PatternMeta[] = [
  { id: 'table-with-server-filter', requiredSceneType: ['list-page', 'workbench'] },
  { id: 'filter-bar', requiredSceneType: ['list-page', 'workbench'] },
  { id: 'toolbar-with-quick-edit', requiredSceneType: ['list-page'] },
  { id: 'crud-feature-skeleton', requiredSceneType: ['list-page'] },
]
```

**作用**：  
`matchPatternsByIntent(scene.type)` 会用这些 meta 判断意图声明的模式是否合法、是否适配当前场景（list-page）。

---

## 4. 生成计划（Plan）如何构建

入口：`poc/planning.ts` 中的 `buildPlan()`。

步骤概览：

1. 加载 Intent；
2. 调用 `matchPatternsByIntent` 获取匹配的模式 meta；
3. 遍历 Intent 中显式声明的 `patterns`，为每个模式推导目标文件路径、参数；
4. 生成 `PlanAction[]`。

关键代码片段（已省略日志）：

```ts
const intent = await intentRepo.loadIntent(intentId)(env.fs)
const matches = await matchPatternsByIntent(intent, patternRepo)
const selected = matches.filter((m) => explicitPatternIds.has(m.pattern.id))

for (const match of selected) {
  const params = intentPattern?.config ?? {}
  const targets = inferTargetPaths(intent, match.pattern.id)
  for (const path of targets) {
    actions.push({
      type: 'create-file',
      path,
      templateId: match.pattern.id,
      patternId: match.pattern.id,
      params,
    })
  }
}
```

结果示例（内存对象）：

```ts
[
  {
    type: 'create-file',
    path: 'src/features/order-management/components/order-management-table.tsx',
    templateId: 'table-with-server-filter',
    params: { entity: 'Order', pagination: true, batchActions: ['export'] },
  },
  {
    type: 'create-file',
    path: 'src/features/order-management/stores/order-management-table.store.ts',
    templateId: 'table-with-server-filter',
    params: { ... },
  },
  ...共 6 条
]
```

**作用**：  
Plan 是「出码计划」，告诉执行器要创建哪些文件、各自属于哪个模板/模式、要传哪些参数。

---

## 5. CLI 执行（把 Plan 落到磁盘）

命令：

```bash
cd /Users/yoyo/projj/git.imile.com/ux/imd
pnpm tsx docs/specs/intent-driven-ai-coding/v1/poc/cli.ts order-management
```

执行行为：

1. 调 `buildPlan()`，获得 `GenerationPlan`；
2. 调 `executePlan(plan)`：
   - 遍历 `plan.actions`；
   - 调 `CodeGen.generate(templateId, params)`（当前 dummy 生成占位文本）；
   - 将内容写入 `.generated/<templateId>.txt`；
   - 打印日志。

实际日志（节选）：

```
[planning] building plan for intent order-management
[execution] executing plan for intent order-management, actions=6
[execution] create-file src/features/order-management/components/order-management-table.tsx using template table-with-server-filter
[execution] wrote ./.generated/table-with-server-filter.txt
...
[execution] create-file src/features/order-management/components/order-management-quick-edit.tsx using template toolbar-with-quick-edit
[execution] wrote ./.generated/toolbar-with-quick-edit.txt
```

**作用**：  
CLI 是一个最薄的 orchestrator：把“意图 → 计划”串起来，并产生可观察的输出。后续换成 `imd intent plan/apply` 时，这一层机制不变，只需升级 CodeGen。

---

## 6. 当前产物与未来扩展

| 阶段 | 现状 | 下一步 |
| --- | --- | --- |
| Intent | YAML - 可读、可被 LLM/工具解析 | 继续沉淀更多场景，保持结构清晰 |
| Pattern Repo | PoC 内置 meta | 接入 `patterns/*.pattern.yaml`，支持 roles/paramsSchema |
| Plan | 真实路径 + 参数 | 将 `.generated` 输出替换为真实模板渲染文件 |
| CLI/执行器 | 写 `.generated/<templateId>.txt` 占位文件 | 对接 best-practice 的 snippets/templates，生成 React/Zustand/Service 代码；将 Plan/Log 写入 `.plans/` |

---

## 7. 小结

- 这一条链路证明：只要有结构化 Intent，就可以透过 `buildPlan` 把「模式 + 参数」转换成结构化行动列表，并由 CLI 自动写入产物；
- 目前产物还是占位文本，但 Plan 已经包含真实的目标路径和参数，下一步只需将 `CodeGen` 替换为模板渲染即可；
- 如果需要把 Flow/Effect 也纳入自动化，只需在 Plan 中增加生成 `.flow.ts` 的 action（参见 `04-export-orders-flow-example.md`），即能让行为层也进入“意图 → 出码”闭环。


命令：

```bash
cd /Users/yoyo/projj/git.imile.com/ux/imd
pnpm tsx docs/specs/intent-driven-ai-coding/v1/poc/cli.ts order-management
```

执行顺序：

1. **规划阶段**（`buildPlan`）
   - 读取 `order-management.intent.yaml`；
   - 通过 `matchPatternsByIntent()` 找出 `scene.type = list-page` 对应的模式；
   - 为每个匹配的模式生成若干 `PlanAction`，并推导目标路径。例如：
     ```ts
     [
       {
         type: 'create-file',
         path: 'src/features/order-management/components/order-management-table.tsx',
         templateId: 'table-with-server-filter',
         patternId: 'table-with-server-filter',
         params: { entity: 'Order', pagination: true, batchActions: ['export'] },
       },
       {
         type: 'create-file',
         path: 'src/features/order-management/stores/order-management-table.store.ts',
         templateId: 'table-with-server-filter',
         patternId: 'table-with-server-filter',
         params: { ...同上... },
       },
       {
         type: 'create-file',
         path: 'src/features/order-management/queries/use-order-management-list.hook.ts',
         templateId: 'table-with-server-filter',
         patternId: 'table-with-server-filter',
         params: { ...同上... },
       },
       {
         type: 'create-file',
         path: 'src/features/order-management/components/order-management-filters.tsx',
         templateId: 'filter-bar',
         patternId: 'filter-bar',
         params: { inlineSearch: true, showResetButton: true, fields: ['status', 'createdAt'] },
       },
       {
         type: 'create-file',
         path: 'src/features/order-management/components/order-management-toolbar.tsx',
         templateId: 'toolbar-with-quick-edit',
         patternId: 'toolbar-with-quick-edit',
         params: { supportQuickEdit: true, supportExport: true, editableFields: ['remark'] },
       },
       {
         type: 'create-file',
         path: 'src/features/order-management/components/order-management-quick-edit.tsx',
         templateId: 'toolbar-with-quick-edit',
         patternId: 'toolbar-with-quick-edit',
         params: { ...同上... },
       },
     ]
     ```

2. **执行阶段**（`executePlan`）
   - 调用 `CodeGen.generate(templateId, params)` 生成占位内容；
   - 将生成结果写入 `.generated/<templateId>.txt`，并打印日志。

实际输出（节选）：

```
[planning] building plan for intent order-management
[execution] executing plan for intent order-management, actions=6
[execution] create-file src/features/order-management/components/order-management-table.tsx using template table-with-server-filter
[execution] wrote ./.generated/table-with-server-filter.txt
[execution] create-file src/features/order-management/stores/order-management-table.store.ts using template table-with-server-filter
[execution] wrote ./.generated/table-with-server-filter.txt
[execution] create-file src/features/order-management/queries/use-order-management-list.hook.ts using template table-with-server-filter
[execution] wrote ./.generated/table-with-server-filter.txt
[execution] create-file src/features/order-management/components/order-management-filters.tsx using template filter-bar
[execution] wrote ./.generated/filter-bar.txt
[execution] create-file src/features/order-management/components/order-management-toolbar.tsx using template toolbar-with-quick-edit
[execution] wrote ./.generated/toolbar-with-quick-edit.txt
[execution] create-file src/features/order-management/components/order-management-quick-edit.tsx using template toolbar-with-quick-edit
[execution] wrote ./.generated/toolbar-with-quick-edit.txt
```

> 当前 PoC 仍然把真实内容写在 `.generated/*.txt` 文件中，主要用于证明“Intent.patterns → Plan → 执行” 的链路。接下来可以把 `CodeGen.generate` 替换为真正的模板渲染器（对接 best-practice snippets），即可把这些路径生成为 React/Zustand/Service 骨架。

## 4. 中间产物的承载能力

- **Intent**：已经能精确描述场景（scene/layout/actors/flows）、模式选择和领域实体；
- **Pattern**：PoC 中用内置 `basePatternMetas` 替代真实仓库，只关注 `id/name/applicability`；
- **Plan**：是结构化的行动列表 `PlanAction[]`；即便目前只生成 `.generated.txt`，也能看出真实目标路径和参数；
- **CLI / 执行器**：起到“把 Intent 映射到文件系统改动”这一核心作用。后续 CLI 可以换成更正式的 `imd intent plan/apply` 命令，但这套骨架已经证明了流程可行。

## 5. 后续进阶方向

1. **接入真实 Pattern/Template 仓库**：从 `patterns/*.pattern.yaml` / `templates/*.template.yaml` 中读取 `composition.roles` 与路径模板。
2. **完善 CodeGen**：用 best-practice snippets / tpl-* 模板渲染 TS/TSX 文件，替换 `.generated.txt`。
3. **记录 Plan/Log**：将 `GenerationPlan`、执行日志和 diff 写入 `.plans/` 目录，形成可追溯资产。
4. **结合 Flow/Effect**：将 Intent.runtimeFlows 编译为 `.flow.ts` 行为文件，与组件 Hook 打通（参见 `04-export-orders-flow-example.md`）。

这一示例表明：只要有结构化 Intent，借助 PoC CLI 就可以看到“意图 → 模式 → 计划 → 执行”的完整闭环，后续只需要逐步增强模板和代码生成能力，即能把生成物替换为真实的 React/Zustand/Service 骨架。
</file>

<file path="specs/intent-driven-ai-coding/v1/intents/expense-approval-center.intent.yaml">
id: expense-approval-center
title: 费用报销审批中心
description: 统一处理费用报销的待办/已办/全部审批任务，提供详情与审批历史视图。

goals:
  - 提升审批人处理效率，减少漏审
  - 统一审批体验与状态展示方式

scene:
  type: approval
  actors:
    - role: approver
      description: 负责审核费用报销申请的审批人
  flows:
    - from: "待办列表"
      to: "审批详情"
      action: "点击某条待办进入详情"
    - from: "审批详情"
      to: "待办列表"
      action: "审批通过/拒绝后返回列表"
    - from: "审批详情"
      to: "审批历史"
      action: "查看审批时间线与记录"

patterns:
  - id: approval-flow
    config:
      entity: ExpenseApproval
      tabs: [todo, done, all]
      listPageSize: 20
      showHistory: true
  - id: table-with-server-filter
    target: approvals-list
    config:
      entity: ExpenseApproval
      pagination: true
      batchActions: []
  - id: service-adapter-query
    config:
      entity: ExpenseApproval
      resourceName: expense-approvals
      operations: [list, detail, update]
      hasPagination: true
  - id: zustand-store-with-slices
    config:
      storeName: expenseApproval
      enableImmer: true
      slices:
        - id: data
          kind: data
          hasSelectors: true
        - id: ui
          kind: ui
          hasSelectors: false

domain:
  entities:
    - name: ExpenseApproval
      fields:
        - id: string
        - applicant: string
        - amount: number
        - currency: string
        - status: enum[PENDING, APPROVED, REJECTED]
        - createdAt: datetime
        - updatedAt: datetime
  apis:
    - name: listExpenseApprovals
      path: /api/expense-approvals
      method: GET
      query:
        - name: status
          type: string
          optional: true
        - name: applicant
          type: string
          optional: true
        - name: page
          type: number
        - name: pageSize
          type: number
      returns: Paginated<ExpenseApproval>
    - name: getExpenseApprovalDetail
      path: /api/expense-approvals/{id}
      method: GET
      returns: ExpenseApproval
    - name: approveExpense
      path: /api/expense-approvals/{id}/approve
      method: POST
    - name: rejectExpense
      path: /api/expense-approvals/{id}/reject
      method: POST
    - name: listExpenseApprovalHistory
      path: /api/expense-approvals/{id}/history
      method: GET
      returns: List<ApprovalRecord>

openQuestions:
  - "是否需要支持多级审批（串/并行）？"
  - "是否需要支持转交/加签等高级操作？"

autoFill:
  - "根据 ExpenseApproval 字段自动生成审批列表列配置"
  - "根据 listExpenseApprovals 查询参数自动生成筛选字段"
</file>

<file path="specs/intent-driven-ai-coding/v1/intents/ops-workbench.intent.yaml">
id: ops-workbench
title: 运营工作台
description: 统一处理运营任务的桌面工作台

goals:
  - 提升任务处理效率 30%
  - 支持 1440px 桌面 + 窄屏折叠

scene:
  type: workbench
  actors:
    - role: operator
      description: 日常处理任务的运营人员
  flows:
    - from: "待处理列表"
      to: "详情面板"
      action: "开始处理任务"
    - from: "详情面板"
      to: "待处理列表"
      action: "完成任务后返回"

patterns:
  - id: workbench-layout
    config:
      leftPanelId: tasks-list
      rightPanelId: task-detail
      metricsRegionId: metrics
      layoutMode: two-column
  - id: table-with-server-filter
    target: tasks-list
    config:
      entity: Task
      pagination: true
      batchActions: [assign, complete]
  - id: service-adapter-query
    config:
      entity: Task
      resourceName: tasks
      operations: [list, detail]
      hasPagination: true
  - id: zustand-store-with-slices
    config:
      storeName: task
      enableImmer: true
      slices:
        - id: data
          kind: data
          hasSelectors: true
        - id: ui
          kind: ui
          hasSelectors: false

domain:
  entities:
    - name: Task
      fields:
        - id: string
        - status: enum[TODO, DOING, DONE]
        - assignee: string
        - priority: enum[LOW, MEDIUM, HIGH]
        - createdAt: datetime
        - updatedAt: datetime
  apis:
    - name: listTasks
      path: /api/tasks
      method: GET
      returns: Paginated<Task>
    - name: getTaskDetail
      path: /api/tasks/{id}
      method: GET
      returns: Task

openQuestions:
  - "任务优先级是否影响排序规则？"
  - "列表是否需要实时刷新？"
  - "是否需要支持批量指派/批量完成？"

autoFill:
  - "根据 Task 字段自动生成列表列配置初稿"
  - "根据 listTasks 查询参数自动生成筛选字段"
</file>

<file path="specs/intent-driven-ai-coding/v1/intents/order-management.intent.yaml">
id: order-management
title: 订单管理列表
description: 管理订单的列表 / 搜索 / 快速编辑 / 导出功能

goals:
  - 让运营在单页内完成大部分订单处理动作
  - 支持高频搜索与筛选，减少切页
  - 统一导出能力，避免每个页面重复接入

scene:
  type: list-page
  layout:
    regions:
      - id: filters
        label: 筛选区
        role: filter-bar
      - id: toolbar
        label: 工具栏
        role: actions
      - id: table
        label: 列表
        role: data-table
  actors:
    - role: ops
      description: 日常处理订单的运营同学
  flows:
    - from: 进入订单管理页面
      to: 筛选区
      action: 选择状态/日期等筛选条件
    - from: 筛选区
      to: 列表
      action: 根据筛选条件加载订单列表
    - from: 列表
      to: 快速编辑弹层
      action: 点击某行快速编辑按钮
    - from: 快速编辑弹层
      to: 列表
      action: 提交修改并刷新当前页
    - from: 工具栏
      to: 导出任务
      action: 点击导出按钮按当前筛选条件导出

runtimeFlows:
  - id: exportOrders
    trigger:
      element: toolbar.exportButton
      event: click
    pipeline:
      - call: FilterService.getCurrentFilters
        as: filters
      - call: TableUiStateService.getCurrentState
        as: tableState
      - call: ExportService.submitExportTask
        params:
          filters: "{{filters}}"
          columns: "{{tableState.visibleColumns}}"

patterns:
  - id: table-with-server-filter
    target: table
    config:
      entity: Order
      pagination: true
      batchActions:
        - export
  - id: filter-bar
    target: filters
    config:
      inlineSearch: true
      showResetButton: true
      fields:
        - status
        - createdAt
  - id: toolbar-with-quick-edit
    target: toolbar
    config:
      supportQuickEdit: true
      supportExport: true
      editableFields:
        - remark

domain:
  entities:
    - name: Order
      fields:
        - id: string
        - status: enum[PENDING, PAID, SHIPPED, COMPLETED, CANCELED]
        - createdAt: datetime
        - updatedAt: datetime
        - buyerName: string
        - totalAmount: number
        - remark: string
  apis:
    - name: listOrders
      path: /api/orders
      method: GET
      query:
        - name: keyword
          type: string
          optional: true
        - name: status
          type: string
          optional: true
        - name: createdAtFrom
          type: datetime
          optional: true
        - name: createdAtTo
          type: datetime
          optional: true
        - name: page
          type: number
        - name: pageSize
          type: number
      returns: Paginated<Order>
    - name: updateOrder
      path: /api/orders/{id}
      method: PATCH
      body:
        - name: remark
          type: string
          optional: true
        - name: status
          type: string
          optional: true
    - name: exportOrders
      path: /api/orders/export
      method: POST
      body:
        - name: filters
          type: object

openQuestions:
  - 导出是否需要限制最大条数？
  - 是否允许在快速编辑中修改订单状态？

autoFill:
  - 根据 Order 字段自动生成表格列初稿（id/status/createdAt/totalAmount）
  - 根据 listOrders 查询参数自动生成过滤项
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/approval-flow.pattern.yaml">
id: approval-flow
name: 审批流页面（待办 + 已办 + 详情 + 历史）
version: v1
status: draft
summary: 适用于需要“待办/已办/全部 + 审批详情 + 操作历史”的审批流场景，统一列表、详情与状态流转视图。

problem: >
  审批类功能（费用报销、权限申请、合同审批等）通常包含：
  1）待办/已办/全部列表；
  2）详情页展示申请信息与当前状态；
  3）操作历史（审批记录时间线）；
  4）审批动作（同意/拒绝/转交等）。
  如果每个审批模块自行实现，容易导致：
  - 列表与详情结构不统一；
  - 状态流转与历史展示方式不一致；
  - 权限检查与按钮显隐逻辑分散在各个组件中。
  approval-flow 模式提供一套“审批中心”页面的基本结构与角色划分，便于在多个审批场景复用。

applicability:
  goodFor:
    - 费用报销、权限申请、合同审批等典型审批流程
    - 需要统一“待办/已办/全部 + 详情 + 历史”的中后台审批中心
  badFor:
    - 简单二选一确认弹窗（不需要完整审批页面）
    - 强业务特化的复杂工作流引擎（建议在此模式基础上扩展）
  requiredSceneType:
    - approval
    - list-page

composition:
  roles:
    - id: ApprovalPageShell
      label: 审批中心页面壳
      description: >
        负责整体布局：上方 Tab（待办/已办/全部）、左侧列表、右侧详情与操作历史区域。
        内部组合列表/详情/历史组件，不直接处理具体审批业务逻辑。
      provides:
        - ApprovalPageShellService
    - id: ApprovalListComponent
      label: 审批列表组件
      description: >
        渲染当前 Tab 对应的审批任务列表（待办/已办/全部），支持基本筛选与排序，
        选中项改变时通过 ApprovalSelectionService 通知详情视图。
      requires:
        - ApprovalSelectionService
        - ApprovalQueryService
    - id: ApprovalDetailComponent
      label: 审批详情组件
      description: >
        展示当前选中任务的申请信息、当前状态与可执行按钮（同意/拒绝/转交等），
        调用 ApprovalActionService 执行动作，不直接封装 HTTP。
      requires:
        - ApprovalSelectionService
        - ApprovalActionService
    - id: ApprovalTimelineComponent
      label: 审批历史时间线组件
      description: >
        渲染审批记录时间线，展示每个节点的处理人、时间、动作与备注。
      requires:
        - ApprovalHistoryService

dataContract:
  description: >
    approval-flow 模式要求 Intent 在 domain 中至少描述：
    1）审批实体（如 ApprovalRequest）的字段（申请人、类型、状态、创建时间等）；
    2）列表接口（待办/已办/全部）及其筛选参数；
    3）详情接口与审批动作接口（同意/拒绝/转交等）；
    4）历史记录接口（审批记录列表）。

paramsSchema:
  entity:
    type: string
    required: true
    desc: 审批实体名称，例如 ApprovalRequest。
  tabs:
    type: array
    required: true
    item:
      type: string
      enum: [todo, done, all]
    desc: 需要展示的 Tab 列表（默认包含待办/已办/全部）。
  listPageSize:
    type: number
    required: false
    default: 20
    desc: 列表默认分页大小。
  showHistory:
    type: boolean
    required: false
    default: true
    desc: 是否在详情右侧/下方展示审批历史时间线。

uiSchema:
  entity:
    widget: select
    label: 审批实体
    optionsFrom: intent.domain.entities
  tabs:
    widget: checkbox-group
    label: Tab 选项
    options:
      - value: todo
        label: 待办
      - value: done
        label: 已办
      - value: all
        label: 全部
  listPageSize:
    widget: number-input
    label: 列表默认分页大小
  showHistory:
    widget: switch
    label: 显示审批历史时间线

examples:
  - name: 费用报销审批中心
    intentId: expense-approval-center
    description: >
      将费用报销审批场景统一抽象为“待办/已办/全部 + 详情 + 时间线”页面，
      列表部分可结合 table-with-server-filter 模式，详情与历史部分复用 approval-flow 约定的组件结构。
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/crud-feature-skeleton.pattern.yaml">
id: crud-feature-skeleton
name: CRUD 垂直特性骨架
version: v1
status: draft
summary: 适用于单个领域实体的标准 CRUD 功能，统一组织“列表 + 详情 + 表单 + 状态管理 + 服务层”的垂直切片结构。

problem: >
  在 toB 系统中，“订单管理”“用户管理”“配置项管理”等功能本质上都是 CRUD 场景，
  但如果每个功能从零随意搭建目录和文件结构，就会出现：
  1）有的直接在 pages 下堆逻辑，有的把服务层、适配器、状态散落在各个角落；
  2）测试文件位置和命名不统一，导致难以复用和自动化校验；
  3）新同学很难一眼看出“一个完整特性”从入口到服务层的边界。
  crud-feature-skeleton 模式将 best-practice 仓库中的目录与文件类型规范整合为一个“垂直特性骨架”，
  以一个领域实体为单位，约定列表页壳、工具栏、表格、服务、适配器、Query、Store、测试的组织方式。

applicability:
  goodFor:
    - 基于单一领域实体的 CRUD 功能（订单、用户、组织、配置项等）
    - 需要统一“从页面到服务层”的代码结构，方便模板和生成器直接铺骨架
  badFor:
    - 强流程型、跨多个实体的复杂场景（建议拆为多个特性 + 流程模式）
    - 只读统计页面或纯图表视图（可使用独立的报表/图表模式）
  preconditions:
    - 已为该实体定义基本的列表/详情/增删改接口
    - 希望后续在该特性上迭代更多行为（权限、导入导出、工作流等）

composition:
  roles:
    - id: ListPageShell
      label: 列表页壳
      description: >
        使用 list-page 模式提供统一的页面布局（filters/toolbar/table 区域），作为整个特性的入口。
      requires:
        - PageShellService
    - id: FilterBar
      label: 顶部筛选条
      description: >
        使用 filter-bar 模式实现筛选区，绑定实体字段和筛选条件，驱动列表刷新。
      requires:
        - FilterService
    - id: ToolbarWithQuickEdit
      label: 工具栏 + 快速编辑
      description: >
        使用 toolbar-with-quick-edit 模式提供新增/导出/快速编辑等按钮入口，协调导出与行内编辑。
      requires:
        - QuickEditService
        - ExportService
    - id: TableWithServerFilter
      label: 服务端筛选表格
      description: >
        使用 table-with-server-filter 模式渲染主列表区域，负责分页、排序、列配置、批量导出等。
      requires:
        - ListQueryService
        - TableUiStateService
    - id: FeatureState
      label: 特性状态层
      description: >
        基于 zustand-store-with-slices 模式，为当前实体定义特性级 Store（如 useOrderStore），
        拆分 data/ui 等 Slice，并暴露必要的 Actions 与 Selectors。
      requires:
        - StoreHook
    - id: FeatureServices
      label: 服务层 + 适配器 + Query
      description: >
        基于 service-adapter-query 模式，为当前实体定义 service（*.service.ts）、
        adapter（*.adapter.ts）、query-keys 与 Query Hook（*.hook.tsx），统一接口接入与缓存行为。
      requires:
        - HttpService
        - DomainAdapter
        - QueryHook
    - id: Tests
      label: 测试骨架
      description: >
        为服务层、适配器、核心 Store 与关键组件生成最小测试骨架（如 *.service.test.ts、*.adapter.test.ts），
        保证特性可以被独立验证。

dataContract:
  description: >
    crud-feature-skeleton 依赖 Intent 中对单个实体（如 Order）的完整 domain 描述：
    1）实体字段与枚举（用于列表、筛选、表单、权限判断）；
    2）列表/详情/创建/更新/删除接口契约（用于服务层与 Query Hook）；
    3）必要时的权限字段或角色信息（可配合权限模式扩展）。

paramsSchema:
  entity:
    type: string
    required: true
    desc: >
      领域实体名称，例如 Order、User。用于命名页面、Store、服务层与适配器等。
  routePath:
    type: string
    required: true
    desc: >
      列表页的路由路径（不含域名），例如 "/orders"。
  enableQuickEdit:
    type: boolean
    required: false
    default: true
    desc: 是否为当前特性启用快速编辑入口和弹层。
  enableExport:
    type: boolean
    required: false
    default: true
    desc: 是否为当前特性启用导出能力。
  enableDetailPage:
    type: boolean
    required: false
    default: true
    desc: 是否为当前实体生成独立的详情页骨架。

uiSchema:
  entity:
    widget: select
    label: 绑定实体
    optionsFrom: intent.domain.entities
  routePath:
    widget: text-input
    label: 路由路径
  enableQuickEdit:
    widget: switch
    label: 启用快速编辑
  enableExport:
    widget: switch
    label: 启用导出
  enableDetailPage:
    widget: switch
    label: 生成详情页骨架

examples:
  - name: 订单管理 CRUD 特性骨架
    intentId: order-management
    description: >
      以 Order 为实体，在 "/orders" 路由下生成列表页壳、筛选区、工具栏、表格、Store、服务层与测试骨架，
      对应 best-practice 仓库中的 feature-skeleton 与 basic CRUD 示例。
    docRefs:
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/examples/feature-skeleton
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/templates/best-practice-templates/03-progressive-examples/01-basic-crud
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/05-file-conventions.md
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/03-api-integration-guide.md
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/filter-bar.pattern.yaml">
id: filter-bar
name: 顶部筛选条
version: v1
status: draft
summary: 适用于列表页顶部的筛选区域，支持关键字搜索与多字段过滤。

problem: >
  在 toB 列表页中，筛选区经常被随意实现：有的在表格上方，有的在侧边栏，
  多个页面复用不同的组件，导致交互和布局不统一。filter-bar 模式提供一个
  统一的筛选区结构和状态管理约定，简化后续模板与生成器的设计。

applicability:
  goodFor:
    - list-page 顶部筛选区域
    - 需要关键字 + 多字段组合筛选的场景
  badFor:
    - 只需要单个下拉选择的极简场景
    - 复杂分步筛选流程（应考虑向导或侧边过滤模式）
  requiredSceneType:
    - list-page

composition:
  roles:
    - id: FilterComponent
      label: 筛选组件
      description: >
        渲染筛选表单控件（select/input/date range 等），读取/更新 FilterStore，
        并在筛选项变更时触发列表刷新。
      requires:
        - FilterService
    - id: FilterStore
      label: 筛选状态 Store
      description: >
        维护筛选条件的 UI 状态（例如 status、日期区间、keyword 等），对外暴露读写接口。
      provides: FilterService

dataContract:
  description: 筛选字段由意图中的实体字段列表推导，不做强制约束。

paramsSchema:
  entity:
    type: string
    required: true
    desc: 绑定的实体名称，用于从 Intent 中推导可用字段。
  fields:
    type: array
    required: false
    item:
      type: string
    desc: 参与筛选的字段列表（例如 ["status", "createdAt"]）。
  inlineSearch:
    type: boolean
    required: false
    default: true
    desc: 是否启用关键字搜索输入框。
  showResetButton:
    type: boolean
    required: false
    default: true
    desc: 是否显示“重置”按钮。

uiSchema:
  entity:
    widget: select
    label: 绑定实体
    optionsFrom: intent.domain.entities
  fields:
    widget: multi-select
    label: 筛选字段
    optionsFrom: intent.domain.entities[entity].fields
  inlineSearch:
    widget: switch
    label: 启用关键字搜索
  showResetButton:
    widget: switch
    label: 显示重置按钮
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/list-page.pattern.yaml">
id: list-page
name: 列表页壳（List Page Shell）
version: v1
status: draft
summary: 为典型 toB 列表页提供统一的页面壳结构（筛选区 + 工具栏 + 列表区），不关心内部实现细节。

problem: >
  在管理后台中，大多数功能页面都可以抽象为“列表页”：顶部有筛选区和工具栏，下方是数据表格。
  如果每个页面都自行设计布局，会导致视觉不统一、响应式行为不一致、可观察性和可测试性不足。
  本模式仅提供统一的页面壳（layout），内部筛选/工具栏/表格由其他模式负责。

applicability:
  goodFor:
    - 标准列表页（顶部筛选 + 工具栏，下方列表）
    - 需要统一布局和间距的列表型功能
  badFor:
    - 向导式流程页面（应使用 wizard-form 等模式）
    - 复杂工作台/仪表盘（应使用 workbench-layout 等模式）
  requiredSceneType:
    - list-page

composition:
  roles:
    - id: PageComponent
      label: 页面组件
      description: >
        作为列表页根组件，负责组合筛选区、工具栏和表格区域，
        并提供统一的布局、间距和容器 className。内部组件由其他模式实现。
      provides: PageShellService

dataContract:
  description: >
    list-page 模式只关心“有哪些区域”，不关心具体实体和接口。

paramsSchema:
  title:
    type: string
    required: true
    desc: 页面标题（例如“订单管理列表”）。
  regions:
    type: array
    required: true
    item:
      type: string
    desc: >
      页面的区域标识列表，推荐使用 ["filters", "toolbar", "table"] 这样的命名，
      以便其他模式通过 target 与之对接。

uiSchema:
  title:
    widget: text-input
    label: 页面标题
  regions:
    widget: tags
    label: 区域标识
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/service-adapter-query.pattern.yaml">
id: service-adapter-query
name: 服务层 + 适配器 + Query Hook
version: v1
status: draft
summary: 适用于基于 HTTP 的业务接口接入场景，统一 service / adapter / TanStack Query Hook 的分层与职责。

problem: >
  在典型的 toB 管理系统中，大量页面需要对接后端接口：列表、详情、创建、更新、删除等。
  如果每个功能随意在组件中直接发请求、拼 URL、操作原始字段，不仅难以复用，也很难在
  错误处理、重试、缓存等方面保持一致。service-adapter-query 模式提供一套明确的分层约定：
  service 只做 IO，adapter 做结构转换，Query Hook 管理缓存与请求策略，组件只消费领域模型。
  该模式与 best-practice 仓库中的 API 集成与适配器规范一一对应，便于模板与生成器直接复用。

applicability:
  goodFor:
    - 基于 HTTP 的标准 CRUD 接口（列表 / 详情 / 创建 / 更新 / 删除）
    - 需要统一错误结构、重试策略与 Query Key 命名的场景
    - 希望服务层可替换、适配器可单测的中大型前端项目
  badFor:
    - WebSocket / 事件流等强实时接口（建议使用专门的异步流模式）
    - 单次调用、完全不会复用的脚本式逻辑
  preconditions:
    - 已有接口契约（OpenAPI 或等价文档），字段语义明确
    - 项目使用 TanStack Query 作为服务端缓存（与 best-practice 一致）

composition:
  roles:
    - id: ServiceModule
      label: 服务层模块（*.service.ts）
      description: >
        封装与后端 HTTP 接口的交互，聚合某个资源的所有操作（list/get/create/update/delete），
        不做数据结构转换，也不做复杂业务决策。返回原始 API 响应或轻度归一化后的数据。
      provides:
        - HttpService
      requires:
        - HttpClient
    - id: AdapterModule
      label: 适配器模块（*.adapter.ts）
      description: >
        在 API 原始结构与前端领域模型之间做纯函数转换，集中处理字段重命名、类型转换、
        默认值与 null/undefined 的归一化。适配器必须保持无副作用，便于单测与复用。
      provides:
        - DomainAdapter
    - id: QueryKeysModule
      label: Query Keys 工厂模块（*.query-keys.ts）
      description: >
        使用统一的 Query Key 工厂（如 @lukemorales/query-key-factory）为当前资源生成稳定的
        queryKey 命名空间，供 Query Hook 与服务层失效策略使用。
      provides:
        - QueryKeysFactory
    - id: QueryHookModule
      label: TanStack Query Hook 模块（*.hook.tsx）
      description: >
        封装具体查询逻辑（如 useOrderList / useOrderDetail），内部调用 ServiceModule，
        并使用 AdapterModule 将原始数据转换为领域模型，对外暴露干净的数据与加载/错误状态。
        Hook 内配置重试策略、staleTime 等缓存行为，不承担 UI 状态管理。
      requires:
        - HttpService
        - DomainAdapter
        - QueryKeysFactory
      provides:
        - QueryHook

dataContract:
  description: >
    本模式不直接规定 API 字段细节，但要求：
    1）为每个资源定义清晰的领域模型类型（例如 Order），并由 AdapterModule 负责转换；
    2）在 Intent 的 domain.apis 中声明接口路径、方法与请求参数，供模板和 Hook 推导。

paramsSchema:
  entity:
    type: string
    required: true
    desc: >
      绑定的领域实体名称，例如 Order、User。用于命名 Service/Adapter/Query Hook 以及推导类型。
  resourceName:
    type: string
    required: true
    desc: >
      服务端资源名或前缀，例如 "orders" 或 "users"，用于组合接口路径与 Query Key 命名空间。
  operations:
    type: array
    required: true
    item:
      type: string
      enum: [list, detail, create, update, delete]
    desc: >
      当前场景需要支持的操作集合。模板会根据该集合决定生成哪些服务方法和 Query Hook。
  hasPagination:
    type: boolean
    required: false
    default: false
    desc: >
      列表接口是否支持分页参数（page/pageSize）。若为 true，Query Hook 会约定分页参数与返回结构。
  queryKeyNamespace:
    type: string
    required: false
    desc: >
      Query Key 命名空间前缀，例如 "order"。缺省时可从 resourceName 推导。

uiSchema:
  entity:
    widget: text-input
    label: 领域实体名称
  resourceName:
    widget: text-input
    label: 资源名（通常为后端路径前缀）
  operations:
    widget: checkbox-group
    label: 支持的操作
    options:
      - value: list
        label: 列表
      - value: detail
        label: 详情
      - value: create
        label: 新建
      - value: update
        label: 更新
      - value: delete
        label: 删除
  hasPagination:
    widget: switch
    label: 列表是否分页
  queryKeyNamespace:
    widget: text-input
    label: Query Key 命名空间（可选）

examples:
  - name: 订单管理接口集成
    intentId: order-management
    description: >
      对应订单列表/详情等接口，将 listOrders/getOrder 等 API 通过 service-adapter-query 模式
      落地为 orderService / orderAdapter / orderKeys / useOrderList 等模块。
    docRefs:
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/03-api-integration-guide.md
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/11-adapter-pattern-guide.md
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/llms/03-templates.yaml
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/table-with-server-filter.pattern.yaml">
id: table-with-server-filter
name: 服务端筛选表格
version: v1
status: draft
summary: 适用于 toB 管理系统中的分页列表场景，通过服务端筛选、分页和批量操作统一实现列表展示与导出能力。

problem: >
  在典型的管理后台中，订单、工单、用户等实体的管理界面通常需要：
  1）按多个字段进行筛选（状态、时间区间、关键字等）；
  2）展示可分页的列表并支持排序、列显隐；
  3）提供批量导出或批量操作能力。
  若每个页面从零开始实现这些能力，容易导致交互不一致、重复代码和维护困难。
  本模式旨在提供一套可复用的表格 + 筛选 + 批量操作实现套路。

applicability:
  goodFor:
    - 需要展示大规模数据的后台列表（订单、工单、用户、库存等）
    - 需要支持按多个字段筛选，并希望统一导出行为
    - 列表数据由服务端分页返回（非一次性加载全部）
  badFor:
    - 仅展示少量静态数据的小表格（此时不需要复杂模式）
    - 强流程型视图（应优先考虑“向导表单”等模式）
    - 需要复杂交互式聚合视图（建议使用专门的图表/仪表盘模式）
  requiredSceneType:
    - list-page
  preconditions:
    - 至少定义一个实体（entity），例如 Order
    - 至少存在一个支持分页与筛选参数的列表接口（list API）

composition:
  roles:
    - id: TableComponent
      label: 列表组件
      description: >
        组合 Query Hook、Filter Store、Table Store 和列配置，负责渲染数据表格、
        分页控件，并处理分页/排序/行点击等交互；不直接进行数据归一化。
      requires:
        - ListQueryService
        - TableUiStateService
    - id: ColumnsConfig
      label: 列配置
      description: >
        以数据结构形式定义表格列（key/title/sortable 等），由 TableComponent 引用；
        同时作为导出字段和列显隐配置的来源，避免重复定义。
    - id: FilterStore
      label: 筛选状态 Store
      description: >
        维护筛选区的 UI 状态（例如 status、日期区间、关键字等），提供 setter，
        不处理 HTTP 参数归一化逻辑。
      provides: FilterService
    - id: TableStore
      label: 表格 UI 状态 Store
      description: >
        维护分页、排序、列显隐等表格 UI 状态；不负责数据加载，仅提供状态与更新方法。
      provides: TableUiStateService
    - id: ListQueryHook
      label: 列表查询 Hook
      description: >
        负责调用列表接口，将 FilterStore 中的筛选状态和 TableStore 中的分页/排序状态
        映射为 HTTP 请求参数；同时负责处理 loading/错误/缓存等行为。
      provides: ListQueryService
      requires:
        - FilterService
        - TableUiStateService
    - id: ExportService
      label: 导出服务
      description: >
        （可选）根据当前筛选条件与列配置构造导出载荷并调用导出接口；不直接参与页面渲染。
      provides: ExportService

dataContract:
  requiredEntityFields:
    - id
    - status
  recommendedEntityFields:
    - createdAt
    - updatedAt
    - totalAmount
  listApi:
    description: "要求列表接口至少支持分页参数与可选筛选参数。"
    requiredQueryParams:
      - page
      - pageSize
    optionalQueryParams:
      - keyword
      - status
      - createdAtFrom
      - createdAtTo

paramsSchema:
  entity:
    type: string
    required: true
    desc: >
      绑定的实体名称，例如 Order。用于从 Intent 的实体定义中推导字段和默认列。
  pagination:
    type: boolean
    required: false
    default: true
    desc: 是否启用分页控件与 page/pageSize 状态。
  batchActions:
    type: array
    item:
      type: string
      enum: [export, bulkUpdate]
    required: false
    desc: 支持的批量操作类型（导出、批量更新等）。
  columns:
    type: array
    required: false
    item:
      type: object
      fields:
        key:
          type: string
          required: true
          desc: 绑定实体字段名。
        title:
          type: string
          required: true
          desc: 列头显示名称。
        sortable:
          type: boolean
          required: false
          default: false
          desc: 是否支持按该列排序。
  pageSize:
    type: number
    required: false
    default: 20
    desc: 默认每页条数。

uiSchema:
  entity:
    widget: select
    label: 绑定实体
    optionsFrom: intent.domain.entities
  pagination:
    widget: switch
    label: 启用分页
  batchActions:
    widget: checkbox-group
    label: 批量操作
    options:
      - value: export
        label: 导出
      - value: bulkUpdate
        label: 批量更新
  columns:
    widget: column-picker
    label: 列配置
    optionsFrom: intent.domain.entities[entity].fields
  pageSize:
    widget: number-input
    label: 默认每页条数

examples:
  - name: 订单管理列表
    intentId: order-management
    description: >
      对应 examples/feature-skeleton 中的订单管理功能。通过该模式生成列表组件、
      列配置、筛选状态 Store、表格 UI Store 和列表查询 Hook 等骨架。
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/toolbar-with-quick-edit.pattern.yaml">
id: toolbar-with-quick-edit
name: 工具栏 + 快速编辑
version: v1
status: draft
summary: 适用于列表页顶部工具栏，提供快速编辑入口与导出入口的组合模式。

problem: >
  在管理后台中，列表页顶部工具栏通常包含“新增”“导出”“批量操作”等按钮。
  部分场景还需要提供行内快速编辑能力（例如修改备注），但如果每个页面自行设计，
  容易产生交互不一致和状态管理混乱。toolbar-with-quick-edit 模式提供一套统一的
  工具栏与快速编辑入口设计。

applicability:
  goodFor:
    - 列表页顶部工具栏
    - 需要导出/快速编辑入口的场景
  badFor:
    - 只需要单个“新增”按钮的极简工具栏
    - 复杂审批/流程操作，应由专门模式承载
  requiredSceneType:
    - list-page

composition:
  roles:
    - id: ToolbarComponent
      label: 工具栏组件
      description: >
        渲染顶部工具栏按钮（导出、快速编辑等），触发对应的交互事件。
      requires:
        - QuickEditService
        - ExportService
    - id: QuickEditComponent
      label: 快速编辑组件
      description: >
        （可选）负责展示和提交快速编辑表单，通常以弹层形式出现。
      provides: QuickEditService

dataContract:
  description: >
    快速编辑操作依赖于实体的可编辑字段和更新接口；导出操作依赖于列表接口和导出接口。

paramsSchema:
  supportQuickEdit:
    type: boolean
    required: false
    default: true
    desc: 是否启用快速编辑入口。
  supportExport:
    type: boolean
    required: false
    default: true
    desc: 是否启用导出入口。
  entity:
    type: string
    required: false
    desc: 用于快速编辑时绑定实体名称（例如 Order）。
  editableFields:
    type: array
    required: false
    item:
      type: string
    desc: 快速编辑允许修改的字段列表（例如 ["remark"]）。

uiSchema:
  supportQuickEdit:
    widget: switch
    label: 启用快速编辑
  supportExport:
    widget: switch
    label: 启用导出
  entity:
    widget: select
    label: 绑定实体
    optionsFrom: intent.domain.entities
  editableFields:
    widget: multi-select
    label: 可快速编辑字段
    optionsFrom: intent.domain.entities[entity].fields
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/wizard-form.pattern.yaml">
id: wizard-form
name: 多步向导表单
version: v1
status: draft
summary: 适用于跨多步收集复杂信息的场景，将表单拆分为多个步骤，并统一状态管理、导航与校验策略。

problem: >
  在 toB 管理系统中，复杂对象的创建/配置往往需要跨多步收集信息（例如创建活动、配置权限、设置价格规则等）。
  如果直接用一个长表单实现，容易出现：
  1）用户难以感知进度；
  2）前端难以管理局部校验和跨步依赖；
  3）状态散落在多个组件里，难以复用。
  wizard-form 模式提供一套多步表单的结构化约定：步骤定义、状态存储、导航行为与提交策略。

applicability:
  goodFor:
    - 创建/配置流程较长的场景（3 步及以上）
    - 每一步表单字段较多，且存在跨步依赖（例如前一步选项影响后一步字段）
  badFor:
    - 字段数量较少的简单表单（使用单页表单模式更简单）
    - 强工作流/审批类场景（建议结合 approval-flow 或专门流程模式）
  requiredSceneType:
    - wizard
    - form

composition:
  roles:
    - id: WizardShellComponent
      label: 向导壳组件
      description: >
        负责渲染整体步骤条（Step Indicator）、上一页/下一步/提交按钮，
        并根据当前步骤渲染对应的 StepFormComponent。
      provides:
        - WizardShell
    - id: StepFormComponent
      label: 步骤表单组件
      description: >
        每个步骤对应一个 StepFormComponent，负责渲染该步骤的字段，并通过 FormStateService
        读写向导状态。组件本身不直接管理跨步导航。
      requires:
        - FormStateService
    - id: FormStateStore
      label: 向导状态 Store
      description: >
        集中存储向导当前步、每步的字段值与校验状态，提供跳步/重置/提交等动作。
        可基于 Zustand 或其他状态库实现，但必须保持与表单组件解耦。
      provides:
        - FormStateService

dataContract:
  description: >
    wizard-form 模式不限定具体字段结构，但要求：
    1）Intent 中明确 steps 列表及每步的语义；
    2）在 domain.entities 中定义完整数据结构，便于生成默认字段配置；
    3）在 domain.apis 中定义创建/更新接口，用于最终提交。

paramsSchema:
  entity:
    type: string
    required: true
    desc: >
      绑定的实体名称，例如 Campaign、UserOnboarding。用于推导默认字段和提交载荷结构。
  steps:
    type: array
    required: true
    item:
      type: object
      fields:
        id:
          type: string
          required: true
          desc: 步骤标识（用于状态存储与导航）。
        title:
          type: string
          required: true
          desc: 步骤标题，用于显示在步骤条上。
        description:
          type: string
          required: false
          desc: 步骤简要说明。
        fields:
          type: array
          required: false
          item:
            type: string
          desc: 本步骤包含的实体字段名列表。
  allowBack:
    type: boolean
    required: false
    default: true
    desc: 是否允许用户返回上一页修改。
  allowSkip:
    type: boolean
    required: false
    default: false
    desc: 是否允许跳过可选步骤。

uiSchema:
  entity:
    widget: select
    label: 绑定实体
    optionsFrom: intent.domain.entities
  steps:
    widget: table-editor
    label: 步骤列表
    columns:
      - key: id
        label: 步骤标识
        widget: text-input
      - key: title
        label: 标题
        widget: text-input
      - key: description
        label: 说明
        widget: text-area
      - key: fields
        label: 字段列表
        widget: multi-select
        optionsFrom: intent.domain.entities[entity].fields
  allowBack:
    widget: switch
    label: 允许返回上一页
  allowSkip:
    widget: switch
    label: 允许跳过步骤

examples:
  - name: 活动创建向导
    intentId: campaign-wizard
    description: >
      将复杂的活动创建流程拆分为“基础信息 → 规则配置 → 权益设置 → 审核确认”四步，
      利用 wizard-form 管理步骤状态、字段聚合与最终提交。
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/workbench-layout.pattern.yaml">
id: workbench-layout
name: 工作台布局（左列表 + 右详情 + 顶部指标）
version: v1
status: draft
summary: 适用于 toB 系统中的“工作台”场景，统一“顶部指标 + 左侧任务/列表 + 右侧详情”的布局与交互约定。

problem: >
  在复杂运营/调度场景中，“工作台”页面往往包含：顶部关键指标、左侧任务列表、右侧详情与操作区。
  如果每个团队自行设计布局，很容易出现：
  1）指标区域位置和样式不一致；
  2）列表与详情之间的关联交互（选中、高亮、同步滚动）混乱；
  3）窄屏/小窗口下的响应式行为不一致。
  workbench-layout 模式提供一套统一的布局骨架和区域命名约定，便于后续模板、状态管理与生成器复用。

applicability:
  goodFor:
    - 以“任务处理/工单处理”为主的运营工作台
    - 需要同时展示列表 + 详情 + 顶部指标的场景
    - 需要在同一页内完成大部分处理动作，减少路由切换
  badFor:
    - 单纯的列表页（建议使用 list-page 模式）
    - 多步向导流程（建议使用 wizard-form 模式）
    - 复杂仪表盘/报表（建议使用专门的仪表盘/图表模式）
  requiredSceneType:
    - workbench

composition:
  roles:
    - id: WorkbenchLayoutComponent
      label: 工作台布局组件
      description: >
        页面根组件，负责整体布局：顶部指标区 + 左侧列表区 + 右侧详情区。
        内部不关心具体业务字段，只承载 slot/children。
      provides:
        - WorkbenchLayoutShell
    - id: MetricsComponent
      label: 顶部指标组件
      description: >
        渲染顶部关键指标卡（待处理数量、处理中数量、 SLA 告警等），
        从外部获取统计数据，不直接发起请求。
    - id: LeftPaneComponent
      label: 左侧列表组件
      description: >
        渲染任务/工单列表，处理选中行、高亮状态等；
        通常结合 table-with-server-filter 或其他列表模式使用。
      requires:
        - WorkbenchSelectionService
    - id: RightPaneComponent
      label: 右侧详情组件
      description: >
        渲染当前选中任务的详情与操作区；
        订阅 WorkbenchSelectionService，响应选中项变化。
      requires:
        - WorkbenchSelectionService

dataContract:
  description: >
    workbench-layout 自身不约束具体实体结构，但要求：
    1）Intent 的 scene.layout 中明确 left/right/metrics 等区域标识；
    2）选中项由统一的 WorkbenchSelectionService 管理，避免多个来源。

paramsSchema:
  layoutMode:
    type: string
    required: false
    enum: [two-column, three-row]
    default: two-column
    desc: >
      布局模式：默认左右分栏（two-column），也可以在窄屏下折叠为上下结构（three-row）。
  leftPanelId:
    type: string
    required: true
    desc: >
      左侧区域在 Intent.scene.layout.regions 中的标识，例如 "tasks-list"。
  rightPanelId:
    type: string
    required: true
    desc: >
      右侧区域在 Intent.scene.layout.regions 中的标识，例如 "task-detail"。
  metricsRegionId:
    type: string
    required: false
    desc: >
      顶部指标区域在 Intent.scene.layout.regions 中的标识，例如 "metrics"。
  responsiveBehavior:
    type: string
    required: false
    enum: [collapse-right, collapse-left, tabs]
    default: collapse-right
    desc: >
      窄屏下的响应式行为：折叠右侧、折叠左侧或改用 tabs 切换。

uiSchema:
  layoutMode:
    widget: select
    label: 布局模式
    options:
      - value: two-column
        label: 左右分栏
      - value: three-row
        label: 上指标准行 + 下方列表/详情
  leftPanelId:
    widget: text-input
    label: 左侧区域 ID
  rightPanelId:
    widget: text-input
    label: 右侧区域 ID
  metricsRegionId:
    widget: text-input
    label: 顶部指标区域 ID（可选）
  responsiveBehavior:
    widget: select
    label: 窄屏行为
    options:
      - value: collapse-right
        label: 折叠右侧详情
      - value: collapse-left
        label: 折叠左侧列表
      - value: tabs
        label: 切换为 tabs 布局

examples:
  - name: 运营任务工作台
    intentId: ops-workbench
    description: >
      对应 ops-workbench 意图，将 Task 列表与详情、顶部指标卡通过 workbench-layout 模式统一布局，
      左侧列表区域通常结合 table-with-server-filter 模式实现。
</file>

<file path="specs/intent-driven-ai-coding/v1/patterns/zustand-store-with-slices.pattern.yaml">
id: zustand-store-with-slices
name: Zustand Store + Slice 拆分
version: v1
status: draft
summary: 适用于中大型前端功能模块，统一使用单一 Store + 多 Slice 的状态管理结构，并与 TanStack Query 职责分离。

problem: >
  在没有约束的情况下，Zustand 很容易被用成“随处可写的全局对象”：
  有的功能把服务端数据直接塞进 Store，有的在组件里裸写 useStore() 订阅整个状态，
  还有的把复杂派生逻辑和异步流程塞进 Store 内部，导致性能问题和状态不可预期。
  zustand-store-with-slices 模式整理了一套基础骨架：单一 Store 聚合根、按领域拆分 Slice、
  通过 Selector 计算派生状态、严格区分客户端 UI 状态与服务端缓存，配合 best-practice 中的状态管理规范。

applicability:
  goodFor:
    - 需要在多个组件之间共享 UI 状态的功能模块
    - 拥有多个子领域（列表过滤、表格 UI、弹层开关等）且需要独立演进的场景
    - 使用 TanStack Query 管理服务端数据缓存的项目
  badFor:
    - 只在单个组件内部使用的简单状态（优先 useState）
    - 极简一次性页面，不需要跨组件共享状态
  preconditions:
    - 已采用 Zustand 和 TanStack Query，且愿意遵守“服务端数据不进 Store”的硬约束

composition:
  roles:
    - id: StoreRoot
      label: Store 聚合根（*.store.ts）
      description: >
        定义单一的 Store 实例（如 useAppStore/useOrderStore），聚合多个 Slice，
        暴露统一的类型与 Hook。负责组合 initial state 与 actions，不直接编写业务逻辑。
      provides:
        - StoreHook
    - id: DataSlice
      label: 数据 Slice（*.slice.ts）
      description: >
        管理某一领域的数据型 UI 状态（例如当前选中的行、草稿表单、过滤条件等），
        只操作自身状态，不直接发起网络请求，不存放服务端缓存。
      provides:
        - DataSliceState
        - DataSliceActions
    - id: UISlice
      label: UI Slice（*.slice.ts）
      description: >
        管理纯 UI 状态（例如弹层开关、loading 标志、当前步骤索引等），
        不包含业务决策，保持简单可预测。
      provides:
        - UISliceState
        - UISliceActions
    - id: SelectorsModule
      label: Selector 模块（*.select.ts）
      description: >
        定义可复用的、从 Store 状态派生新信息的选择器，使用 memoization 保证性能，
        避免在组件中重复拼装派生逻辑。
      provides:
        - StoreSelectors

servicesProvided:
  - StoreHook
  - StoreSelectors

dataContract:
  description: >
    本模式不绑定具体实体数据结构，但要求：
    1）服务端数据（列表、详情）由 TanStack Query 管理，Store 仅持有 UI 状态；
    2）Store 的初始状态与 Slice 类型在类型层面明确声明，便于 refactor 与测试。

paramsSchema:
  storeName:
    type: string
    required: true
    desc: >
      Store 名称前缀，例如 "order" 或 "user"，用于生成 useOrderStore 等标识。
  enableImmer:
    type: boolean
    required: false
    default: true
    desc: >
      是否默认启用 immer 中间件。推荐在中大型项目中开启，以减少手写不可变更新的错误。
  slices:
    type: array
    required: true
    item:
      type: object
      fields:
        id:
          type: string
          required: true
          desc: Slice 标识，例如 "data" / "ui" / "filters"。
        kind:
          type: string
          enum: [data, ui]
          required: true
          desc: Slice 类型，用于区分数据型状态与纯 UI 状态。
        hasSelectors:
          type: boolean
          required: false
          default: false
          desc: 是否需要为该 Slice 生成基础 Selector 模板。

uiSchema:
  storeName:
    widget: text-input
    label: Store 名称前缀
  enableImmer:
    widget: switch
    label: 默认启用 immer
  slices:
    widget: table-editor
    label: Slice 列表
    columns:
      - key: id
        label: Slice 标识
        widget: text-input
      - key: kind
        label: Slice 类型
        widget: select
        options:
          - value: data
            label: 数据 Slice
          - value: ui
            label: UI Slice
      - key: hasSelectors
        label: 生成 Selector 模板
        widget: switch

examples:
  - name: 用户管理 Store 骨架
    intentId: user-management
    description: >
      将用户管理功能的客户端状态拆分为 data/ui 等 Slice，生成 basic.store.ts / data.slice.ts /
      ui.slice.ts / selectors 文件，配合 TanStack Query 管理用户列表与详情。
    docRefs:
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/06-state-management.md
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/08-zustand-guide/02-store-and-slice-setup.md
      - /Users/yoyo/projj/git.imile.com/ux/best-practice/snippets/state-management/basic.store.ts
</file>

<file path="specs/intent-driven-ai-coding/v1/plans/order-management.plan.json">
{
  "intentId": "order-management",
  "version": "v1",
  "actions": [
    {
      "type": "create-file",
      "path": "src/features/order-management/order-management.page.tsx",
      "template": "list-page-shell",
      "patternId": "list-page",
      "params": {
        "title": "订单管理列表",
        "regions": ["filters", "toolbar", "table"]
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-filters.tsx",
      "template": "filter-bar",
      "patternId": "filter-bar",
      "params": {
        "entity": "Order",
        "fields": ["status", "createdAt"],
        "inlineSearch": true,
        "showResetButton": true
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-table.tsx",
      "template": "table-with-server-filter",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "columns": [
          { "key": "id", "title": "订单号", "sortable": true },
          { "key": "status", "title": "状态" },
          { "key": "createdAt", "title": "下单时间", "sortable": true },
          { "key": "totalAmount", "title": "金额" }
        ],
        "pagination": true,
        "batchActions": ["export"],
        "pageSize": 20
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-toolbar.tsx",
      "template": "toolbar-with-quick-edit",
      "patternId": "toolbar-with-quick-edit",
      "params": {
        "supportQuickEdit": true,
        "supportExport": true
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-quick-edit.tsx",
      "template": "quick-edit-dialog",
      "patternId": "toolbar-with-quick-edit",
      "params": {
        "entity": "Order",
        "editableFields": ["remark"]
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/stores/filter.slice.ts",
      "template": "filter-store-slice",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "fields": ["status", "createdAt"],
        "initialState": {
          "status": "ALL",
          "createdAtRange": null
        }
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/stores/table.slice.ts",
      "template": "table-store-slice",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "pageSize": 20
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/queries/use-orders-list.hook.ts",
      "template": "list-query-hook",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "apiName": "listOrders"
      }
    }
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/model/intent.ts">
import { Effect } from '../effect'
import { FileSystem } from '../services'

// ===== Intent 类型（简化版） =====

export interface IntentSceneLayoutRegion {
  id: string
  label: string
  role: 'filter-bar' | 'toolbar' | 'data-table' | string
}

export interface IntentScene {
  type: 'list-page' | 'workbench' | string
  layout?: {
    regions: IntentSceneLayoutRegion[]
  }
}

export interface IntentEntityField {
  name: string
  type: string
}

export interface IntentEntity {
  name: string
  fields: IntentEntityField[]
}

export interface IntentApiParam {
  name: string
  type: string
  optional?: boolean
}

export interface IntentApi {
  name: string
  path: string
  method: string
  query?: IntentApiParam[]
  body?: IntentApiParam[]
  returns?: string
}

export interface IntentPatternConfig {
  id: string
  target?: string
  config?: Record<string, unknown>
}

export interface Intent {
  id: string
  title: string
  description?: string
  goals?: string[]
  scene: IntentScene
  patterns?: IntentPatternConfig[]
  domain: {
    entities: IntentEntity[]
    apis: IntentApi[]
  }
}

// ===== Intent 读写骨架 =====

export interface IntentRepo {
  loadIntent(id: string): Effect<FileSystem, Error, Intent>
}

export const makeIntentRepo = (baseDir: string): IntentRepo => {
  const filePath = (id: string) =>
    `${baseDir.replace(/\/$/, '')}/intents/${id}.intent.yaml`

  return {
    loadIntent: (id) => async (fs) => {
      const path = filePath(id)
      const raw = await fs.read(path)
      // 解析 YAML（PoC：依赖仓库已有的 yaml 包）
      const { parse } = await import('yaml')
      const obj = parse(raw) as Intent
      return obj
    },
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/model/pattern.ts">
import { Intent } from './intent'

// 这里只建模我们关心的一部分 Pattern 元数据，
// 完整字段可参考 patterns/table-with-server-filter.pattern.yaml。

export interface PatternRole {
  id: string
  label: string
  description?: string
}

export interface PatternApplicability {
  goodFor?: string[]
  badFor?: string[]
  requiredSceneType?: string[]
}

export interface PatternMeta {
  id: string
  name: string
  summary?: string
  applicability?: PatternApplicability
  composition?: {
    roles?: PatternRole[]
  }
  // paramsSchema / uiSchema 在 UI 层使用，这里略去细节
}

// ==== Pattern 仓库与匹配骨架 ====

export interface PatternRepo {
  getById(id: string): Promise<PatternMeta | null>
  listAll(): Promise<PatternMeta[]>
}

export interface PatternMatch {
  pattern: PatternMeta
  score: number
  reason?: string
}

// 最简单的规则匹配：只看 scene.type 与 requiredSceneType
export async function matchPatternsByIntent(
  intent: Intent,
  repo: PatternRepo
): Promise<PatternMatch[]> {
  const all = await repo.listAll()
  const sceneType = intent.scene.type

  const matches: PatternMatch[] = all.map((p) => {
    const required = p.applicability?.requiredSceneType
    if (!required || required.length === 0) {
      return { pattern: p, score: 0.5, reason: '无 scene.type 限制' }
    }
    if (required.includes(sceneType)) {
      return {
        pattern: p,
        score: 1,
        reason: `scene.type = ${sceneType} 命中 requiredSceneType`,
      }
    }
    return {
      pattern: p,
      score: 0,
      reason: `scene.type = ${sceneType} 不在 requiredSceneType 内`,
    }
  })

  return matches.filter((m) => m.score > 0).sort((a, b) => b.score - a.score)
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/model/runtime-services.example.ts">
// 示例：与 services.md / Pattern.provides 对齐的运行时 Service 接口与简单实现。
// 仅用于说明 FilterService / TableUiStateService / ExportService 在 TS 里的形态。

// ---- Service 接口定义（契约层） ----

export interface FilterService<Filters> {
  getCurrentFilters: () => Filters
  setFilters: (patch: Partial<Filters>) => void
  resetFilters: () => void
}

export interface TableUiState {
  page: number
  pageSize: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}

export interface TableUiStateService {
  getCurrentState: () => TableUiState
  setPage: (page: number) => void
  setPageSize: (pageSize: number) => void
  setSort: (by: string, order: 'asc' | 'desc') => void
}

export interface ExportService<Filters> {
  submitExportTask(args: { filters: Filters; columns: string[] }): Promise<void>
}

// ---- 简化实现（示例，用普通闭包代替 Zustand） ----

type TaskFilters = {
  status?: string
  createdAtFrom?: Date
  createdAtTo?: Date
}

let filtersState: TaskFilters = {}

export const inMemoryFilterService: FilterService<TaskFilters> = {
  getCurrentFilters: () => filtersState,
  setFilters: (patch) => {
    filtersState = { ...filtersState, ...patch }
  },
  resetFilters: () => {
    filtersState = {}
  },
}

let tableState: TableUiState = {
  page: 1,
  pageSize: 20,
}

export const inMemoryTableUiStateService: TableUiStateService = {
  getCurrentState: () => tableState,
  setPage: (page) => {
    tableState = { ...tableState, page }
  },
  setPageSize: (pageSize) => {
    tableState = { ...tableState, pageSize }
  },
  setSort: (by, order) => {
    tableState = { ...tableState, sortBy: by, sortOrder: order }
  },
}

export const consoleExportService: ExportService<TaskFilters> = {
  async submitExportTask({ filters, columns }) {
    // 真正工程里这里会发 HTTP 请求，这里仅打印示意
    // eslint-disable-next-line no-console
    console.log('submitExportTask', { filters, columns })
  },
}

// ---- Service Registry 与极简 Flow 执行示例 ----

export const serviceRegistry = {
  FilterService: inMemoryFilterService,
  TableUiStateService: inMemoryTableUiStateService,
  ExportService: consoleExportService,
} as const

type ServiceId = keyof typeof serviceRegistry

export type FlowStepCall = {
  call: `${ServiceId}.${string}`
  as?: string
  params?: Record<string, unknown>
}

export interface FlowDefinition {
  id: string
  pipeline: FlowStepCall[]
}

export async function runFlow(flow: FlowDefinition): Promise<Record<string, unknown>> {
  const ctx: Record<string, unknown> = {}

  for (const step of flow.pipeline) {
    const [serviceId, method] = step.call.split('.') as [ServiceId, string]
    const service = serviceRegistry[serviceId] as any
    const fn = service[method]
    if (typeof fn !== 'function') {
      throw new Error(`Service method not found: ${step.call}`)
    }
    const resolvedParams = step.params ?? {}
    const result = await fn(resolvedParams)
    if (step.as) {
      ctx[step.as] = result
    }
  }

  return ctx
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/model/template.ts">
// 模板元数据：把模式中的“角色”映射到具体文件路径模式。

export interface TemplateRoleMapping {
  roleId: string
  files: string[] // 带有占位符的路径，例如 src/features/__FEATURE__/components/__ENTITY__-table.tsx
}

export interface TemplateMeta {
  id: string
  patternId: string
  name?: string
  implements: TemplateRoleMapping[]
  // 可扩展：支持哪些技术栈 / UI 库、是否稳定等
}

export interface TemplateRepo {
  getByPattern(patternId: string): Promise<TemplateMeta[]>
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/cli.ts">
import path from 'node:path'
import { runEffect } from './effect'
import { buildPlan, GenerationPlan } from './planning'
import { executePlan } from './execution'
import { PlanningEnv, ExecutionEnv, FileSystem, Logger, CodeGen } from './services'
import { makeIntentRepo } from './model/intent'
import { PatternRepo, PatternMeta } from './model/pattern'
import { TemplateRepo, TemplateMeta } from './model/template'

// ==== 非生产级简单实现，只用于 PoC ====

const nodeFs: FileSystem = {
  read: async (filePath) => {
    const fs = await import('fs/promises')
    return fs.readFile(filePath, 'utf8')
  },
  write: async (filePath, content) => {
    const fs = await import('fs/promises')
    await fs.mkdir(path.dirname(filePath), { recursive: true })
    await fs.writeFile(filePath, content, 'utf8')
  },
  exists: async (filePath) => {
    const fs = await import('fs/promises')
    try {
      await fs.stat(filePath)
      return true
    } catch {
      return false
    }
  },
}

const consoleLogger: Logger = {
  info: (msg) => console.log(msg),
  warn: (msg) => console.warn(msg),
  error: (msg) => console.error(msg),
}

const dummyCodeGen: CodeGen = {
  async generate(templateId, params) {
    // 这里只是示意：真实实现会根据 templateId + params 选择模板并渲染内容。
    const content = `// generated from template ${templateId}\n// params: ${JSON.stringify(
      params,
      null,
      2
    )}\n`
    return [
      {
        path: `./.generated/${templateId}.txt`,
        content,
      },
    ]
  },
}

// 简化版 PatternRepo / TemplateRepo：实际项目中应从 patterns/ 与 templates/ 目录动态加载。

const basePatternMetas: PatternMeta[] = [
  {
    id: 'table-with-server-filter',
    name: '服务端筛选表格',
    applicability: {
      requiredSceneType: ['list-page', 'workbench'],
    },
  },
  {
    id: 'filter-bar',
    name: '筛选区',
    applicability: {
      requiredSceneType: ['list-page', 'workbench'],
    },
  },
  {
    id: 'toolbar-with-quick-edit',
    name: '工具栏 + 快速编辑',
    applicability: {
      requiredSceneType: ['list-page'],
    },
  },
  {
    id: 'crud-feature-skeleton',
    name: 'CRUD 特性骨架',
    applicability: {
      requiredSceneType: ['list-page'],
    },
  },
]

const inMemoryPatternRepo: PatternRepo = {
  async getById(id: string): Promise<PatternMeta | null> {
    return basePatternMetas.find((m) => m.id === id) ?? null
  },
  async listAll(): Promise<PatternMeta[]> {
    return basePatternMetas
  },
}

const inMemoryTemplateRepo: TemplateRepo = {
  async getByPattern(patternId: string): Promise<TemplateMeta[]> {
    return [] // TODO: 读取匹配该模式的模板定义
  },
}

// ==== CLI 入口：从命令行触发生成 ====

async function main() {
  const intentId = process.argv[2]
  if (!intentId) {
    console.error('Usage: node cli.js <intent-id>')
    process.exit(1)
  }

  const repoBaseDir = path.resolve(
    process.cwd(),
    'docs/specs/intent-driven-ai-coding/v1'
  )
  const intentRepo = makeIntentRepo(repoBaseDir)

  const planningEnv: PlanningEnv = {
    fs: nodeFs,
    logger: consoleLogger,
  }

  const executionEnv: ExecutionEnv = {
    fs: nodeFs,
    logger: consoleLogger,
    codegen: dummyCodeGen,
  }

  const plan: GenerationPlan = await runEffect(
    buildPlan(
      {
        intentRepo,
        patternRepo: inMemoryPatternRepo,
        templateRepo: inMemoryTemplateRepo,
      },
      intentId
    ),
    planningEnv
  )

  await runEffect(executePlan(plan), executionEnv)
}

// PoC：直接执行 main；若未来需要作为模块调用，可再拆分
// eslint-disable-next-line no-console
main().catch((err) => {
  console.error(err)
  process.exit(1)
})
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/effect.ts">
// 简化版 Effect 类型定义，仅用于示意。
// 实际项目中可以替换为 effect-ts 或其他实现。

export type Effect<R, E, A> = (env: R) => Promise<A> // 错误 E 可先忽略，用 A | throws 表示

// 运行 Effect 的辅助函数（PoC 级别，不考虑复杂错误处理）
export async function runEffect<R, E, A>(
  eff: Effect<R, E, A>,
  env: R
): Promise<A> {
  return eff(env)
}
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/execution.ts">
import { Effect } from './effect'
import { ExecutionEnv } from './services'
import { GenerationPlan } from './planning'

// 根据 Plan 实际生成 / 修改代码（PoC 级实现）
export const executePlan =
  (plan: GenerationPlan): Effect<ExecutionEnv, Error, void> =>
  async (env) => {
    env.logger.info(
      `[execution] executing plan for intent ${plan.intentId}, actions=${plan.actions.length}`
    )

    for (const action of plan.actions) {
      env.logger.info(
        `[execution] ${action.type} ${action.path} using template ${action.templateId}`
      )

      // 1. 调用代码生成器生成文件内容
      const generatedFiles = await env.codegen.generate(
        action.templateId,
        action.params
      )

      // 2. 写入文件系统（这里只简单覆盖）
      for (const file of generatedFiles) {
        await env.fs.write(file.path, file.content)
        env.logger.info(`[execution] wrote ${file.path}`)
      }
    }
  }
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/planning.ts">
import { Effect } from './effect'
import { PlanningEnv } from './services'
import { IntentRepo, Intent } from './model/intent'
import { PatternRepo, PatternMatch, matchPatternsByIntent } from './model/pattern'
import { TemplateRepo, TemplateMeta } from './model/template'

// 出码计划中的单个动作
export type PlanActionType = 'create-file' | 'update-file'

export interface PlanAction {
  type: PlanActionType
  path: string
  templateId: string
  patternId: string
  params: Record<string, unknown>
}

export interface GenerationPlan {
  intentId: string
  actions: PlanAction[]
}

export interface PlanningDeps {
  intentRepo: IntentRepo
  patternRepo: PatternRepo
  templateRepo: TemplateRepo
}

function inferTargetPaths(intent: Intent, patternId: string) {
  const featureDir = `src/features/${intent.id}/`
  switch (patternId) {
    case 'table-with-server-filter':
      return [
        `${featureDir}components/${intent.id}-table.tsx`,
        `${featureDir}stores/${intent.id}-table.store.ts`,
        `${featureDir}queries/use-${intent.id}-list.hook.ts`,
      ]
    case 'filter-bar':
      return [`${featureDir}components/${intent.id}-filters.tsx`]
    case 'toolbar-with-quick-edit':
      return [
        `${featureDir}components/${intent.id}-toolbar.tsx`,
        `${featureDir}components/${intent.id}-quick-edit.tsx`,
      ]
    case 'crud-feature-skeleton':
      return [
        `${featureDir}pages/${intent.id}.page.tsx`,
        `${featureDir}stores/${intent.id}.store.ts`,
        `${featureDir}services/${intent.id}.service.ts`,
      ]
    default:
      return [`${featureDir}${patternId}.generated.txt`]
  }
}

// 入口：根据 Intent ID 构建 Plan（PoC 级逻辑）
export const buildPlan =
  (deps: PlanningDeps, intentId: string): Effect<PlanningEnv, Error, GenerationPlan> =>
  async (env) => {
    const { intentRepo, patternRepo } = deps

    env.logger.info(`[planning] building plan for intent ${intentId}`)

    // 1. 加载 Intent
    const intent: Intent = await intentRepo.loadIntent(intentId)(env.fs)

    const explicitPatternIds = new Set((intent.patterns ?? []).map((p) => p.id))
    const matches: PatternMatch[] = await matchPatternsByIntent(intent, patternRepo)
    const selected = matches.filter((m) => explicitPatternIds.has(m.pattern.id))

    if (!selected.length) {
      env.logger.warn('[planning] no explicit patterns selected')
    }

    // 2. PoC：根据 Intent.patterns 与匹配的模式生成 Plan
    const actions: PlanAction[] = []

    for (const match of selected) {
      const intentPattern = intent.patterns?.find((p) => p.id === match.pattern.id)
      const baseParams = intentPattern?.config ?? {}
      const targets = inferTargetPaths(intent, match.pattern.id)

      for (const path of targets) {
        const action: PlanAction = {
          type: 'create-file',
          path,
          templateId: match.pattern.id,
          patternId: match.pattern.id,
          params: baseParams as Record<string, unknown>,
        }
        actions.push(action)
      }
    }

    return {
      intentId,
      actions,
    }
  }
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/README.md">
---
title: PoC · Intent → Pattern → Plan → Code 管线骨架
status: draft
---

> 本目录下的 TypeScript 文件是一个“概念验证级”的代码骨架，演示如何在 Node 环境下实现：
>
> Intent (意图资产) → Pattern (模式定义) → Template Meta (模板元数据) → Generation Plan (出码计划) → 执行修改代码
>
> 这些文件不依赖具体框架，只用伪 `Effect<R, E, A>` 类型表达“可组合的工作流”，方便后续替换为任意 Effect 实现或普通 async 函数。

文件一览：

- `effect.ts`：简化版 Effect 类型与运行器占位符。
- `model/intent.ts`：Intent 类型与读写骨架。
- `model/pattern.ts`：Pattern 类型与匹配函数骨架。
- `model/template.ts`：Template Meta 类型。
- `services.ts`：文件系统、模板仓库、代码生成、日志等“能力服务”的接口。
- `planning.ts`：`buildPlan(intentId)` 的骨架，实现从 Intent+Pattern+Template 到 Plan。
- `execution.ts`：`executePlan(plan)` 的骨架，实现根据 Plan 实际生成/修改代码。
- `cli.ts`：一个极简 CLI/脚本入口，串起 `buildPlan` 和 `executePlan`。

## 快速体验（PoC）

当前 PoC 的行为非常刻意简化，仅用于验证“Intent → Plan → 执行”链路是否贯通：

- `planning.ts` 中的 `buildPlan`：
  - 从 `intents/<id>.intent.yaml` 加载 Intent；
  - 遍历 `intent.patterns` 列表；
  - 为每个模式生成一个占位 `PlanAction`，目标路径形如：
    - `src/features/<intent-id>/<pattern-id>.generated.txt`
  - `params` 来自该模式在 Intent 中的 `config` 字段。
- `execution.ts` 中的 `executePlan`：
  - 对每个 `PlanAction` 调用 `CodeGen.generate(templateId, params)`；
  - 将生成内容写入文件系统（当前 dummy 实现写到 `.generated/` 下）。
- `cli.ts`：
  - 读取命令行参数中的 `intentId`（例如 `order-management`）；
  - 依次调用 `buildPlan` 和 `executePlan`。

示例（伪命令）：

```bash
cd docs/specs/intent-driven-ai-coding/v1/poc
# 使用 ts-node / tsx 等运行 cli.ts，例如：
# ts-node cli.ts order-management
#
# 运行后会在 .generated/ 或 src/features/<intent-id>/ 下看到若干 *.generated.txt 占位文件，
# 用于验证 Intent.patterns 是否已被成功转化为 Plan 并应用。
```

后续 v2 演进方向：

- 将 PatternRepo/TemplateRepo 接入真实的 `patterns/*.pattern.yaml` 与 `templates/*.template.yaml`；
- 用 TemplateMeta 中的 implements.roles 和 Intent 信息推导出真正的文件路径；
- 将 dummy CodeGen 替换为基于 best-practice snippets/模板的代码生成，实现从 Intent 生成 React/Zustand/Service 骨架。
</file>

<file path="specs/intent-driven-ai-coding/v1/poc/services.ts">
import { Effect } from './effect'

// === 能力服务接口（仅用于出码前管线） ===

export interface FileSystem {
  read(path: string): Promise<string>
  write(path: string, content: string): Promise<void>
  exists(path: string): Promise<boolean>
}

export interface CodeGen {
  // 根据模板 ID 与参数生成若干文件内容，返回 path->content 映射
  generate(
    templateId: string,
    params: Record<string, unknown>
  ): Promise<Array<{ path: string; content: string }>>
}

export interface Logger {
  info(msg: string): void
  warn(msg: string): void
  error(msg: string): void
}

// 聚合 Env 类型，便于 Effect 使用
export interface PlanningEnv {
  fs: FileSystem
  logger: Logger
  // patternRepo / templateRepo 这里简化为普通对象注入
}

export interface ExecutionEnv {
  fs: FileSystem
  codegen: CodeGen
  logger: Logger
}

// 示例：一个简单的 Effect 使用方式（出码管线真正实现里会在别处）
export const exampleEffect: Effect<PlanningEnv, Error, void> =
  async (env) => {
    env.logger.info('running example effect')
  }
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/intent-studio/intent-tabs.tsx">
import { useState } from 'react'
import type { ChangeEvent } from 'react'
import YAML from 'yaml'
import { patternsById } from '../../data'
import { useIntentStore } from '../../stores/use-intent-store'
import type { IntentSpec } from '../../types'

const tabs = [
  { id: 'overview', label: 'Overview' },
  { id: 'patterns', label: 'Patterns' },
  { id: 'domain', label: 'Domain' },
  { id: 'behavior', label: 'Behavior' },
  { id: 'yaml', label: 'YAML' },
]

interface TabProps {
  intent: IntentSpec
  onUpdate: (patch: Partial<IntentSpec>) => void
}

function OverviewTab({ intent, onUpdate }: TabProps) {
  const handleGoalChange = (event: ChangeEvent<HTMLTextAreaElement>) => {
    const nextGoals = event.target.value
      .split('\n')
      .map((goal) => goal.trim())
      .filter(Boolean)
    onUpdate({ goals: nextGoals })
  }

  return (
    <div className="split-panel">
      <div className="form-grid">
        <div className="field">
          <label>Intent Title</label>
          <input
            value={intent.title}
            onChange={(event) => onUpdate({ title: event.target.value })}
          />
        </div>
        <div className="field">
          <label>Description</label>
          <textarea
            rows={3}
            value={intent.description}
            onChange={(event) => onUpdate({ description: event.target.value })}
          />
        </div>
        <div className="field" style={{ gridColumn: '1 / -1' }}>
          <label>Goals (one per line)</label>
          <textarea
            rows={4}
            value={intent.goals.join('\n')}
            onChange={handleGoalChange}
          />
        </div>
      </div>
      <div>
        <div className="section-label">Open Questions</div>
        <div className="pattern-card">
          <ul style={{ margin: 0, paddingLeft: 18 }}>
            {intent.openQuestions?.map((question) => (
              <li key={question} style={{ marginBottom: 6 }}>
                {question}
              </li>
            ))}
          </ul>
        </div>
        <div className="section-label" style={{ marginTop: 16 }}>
          Auto Fill Suggestions
        </div>
        <div className="pattern-card">
          <ul style={{ margin: 0, paddingLeft: 18 }}>
            {intent.autoFill?.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  )
}

function PatternsTab({ intent }: TabProps) {
  return (
    <div className="pattern-list">
      {intent.patterns.map((config) => {
        const pattern = patternsById[config.id]
        return (
          <div key={config.id} className="pattern-card">
            <header>
              <div>
                <strong>{pattern?.name ?? config.id}</strong>
                <div style={{ fontSize: 12, color: 'var(--text-muted)' }}>{pattern?.summary}</div>
              </div>
              <span className="badge">{config.target ?? 'root'}</span>
            </header>
            <div className="section-label" style={{ marginTop: 12 }}>
              Params
            </div>
            <pre className="code-block" style={{ background: '#111827', color: '#e5e7eb' }}>
              {JSON.stringify(config.config, null, 2)}
            </pre>
          </div>
        )
      })}
    </div>
  )
}

function DomainTab({ intent }: TabProps) {
  const entity = intent.domain.entities?.[0]
  return (
    <div className="split-panel">
      <div>
        <div className="section-label">Entity Schema · {entity?.name}</div>
        <div className="pattern-card">
          <ul style={{ paddingLeft: 18, margin: 0 }}>
            {entity?.fields.map((field) => (
              <li key={field.name} style={{ marginBottom: 6 }}>
                <strong>{field.name}</strong> · {field.type}
                {field.values ? ` (${field.values.join(', ')})` : null}
              </li>
            ))}
          </ul>
        </div>
      </div>
      <div>
        <div className="section-label">APIs</div>
        <div className="pattern-list">
          {intent.domain.apis?.map((api) => (
            <div key={api.name} className="pattern-card">
              <header>
                <strong>{api.name}</strong>
                <span className="badge">{api.method}</span>
              </header>
              <small>{api.path}</small>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

function BehaviorTab({ intent }: TabProps) {
  return (
    <div>
      <div className="section-label">Runtime Flows</div>
      <div className="flow-steps">
        {intent.runtimeFlows?.map((flow) => (
          <div key={flow.id} className="flow-step">
            <strong>{flow.id}</strong>
            <div style={{ fontSize: 12, color: 'var(--text-muted)' }}>
              trigger: {flow.trigger?.element} · {flow.trigger?.event}
            </div>
            <ul style={{ marginTop: 8, paddingLeft: 18 }}>
              {flow.pipeline.map((step, idx) => (
                <li key={idx}>
                  call <code>{step.call}</code>
                  {step.as ? ` → as ${step.as}` : ''}
                </li>
              ))}
            </ul>
          </div>
        ))}
      </div>
    </div>
  )
}

function YamlTab({ intent }: TabProps) {
  return (
    <div className="yaml-preview">
      <pre>{YAML.stringify(intent)}</pre>
    </div>
  )
}

export function IntentTabs() {
  const intent = useIntentStore(
    (state) => state.drafts[state.selectedIntentId]
  )
  const selectedIntentId = useIntentStore((state) => state.selectedIntentId)
  const updateIntent = useIntentStore((state) => state.updateIntent)
  const [activeTab, setActiveTab] = useState('overview')

  if (!intent) return null

  const renderContent = () => {
    const tabProps: TabProps = {
      intent,
      onUpdate: (patch) => updateIntent(selectedIntentId, patch),
    }

    switch (activeTab) {
      case 'overview':
        return <OverviewTab {...tabProps} />
      case 'patterns':
        return <PatternsTab {...tabProps} />
      case 'domain':
        return <DomainTab {...tabProps} />
      case 'behavior':
        return <BehaviorTab {...tabProps} />
      case 'yaml':
        return <YamlTab {...tabProps} />
      default:
        return null
    }
  }

  return (
    <div>
      <div className="tabs">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            className={tab.id === activeTab ? 'active' : ''}
            onClick={() => setActiveTab(tab.id)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      {renderContent()}
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/copilot-bar.tsx">
import { useIntentStore } from '../stores/use-intent-store'
import { usePlanSimulationContext } from '../contexts/plan-simulation-context'
import { useSessionStore } from '../stores/use-session-store'

export function CopilotBar() {
  const hasRequirementInput = useSessionStore((state) => state.hasRequirementInput)
  const currentIntent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  const { plan, logs } = usePlanSimulationContext()
  const planReady = Boolean(plan && plan.actions.length)
  const steps = [
    {
      id: 'input',
      label: '输入需求',
      desc: hasRequirementInput ? '已接收需求文档' : '等待粘贴或加载示例',
      done: hasRequirementInput,
    },
    {
      id: 'intent',
      label: 'LLM 解析意图',
      desc: currentIntent ? currentIntent.title : '尚未解析意图',
      done: Boolean(currentIntent),
    },
    {
      id: 'plan',
      label: '生成 Plan / Flow',
      desc: planReady ? `Create-file × ${plan?.actions.length ?? 0}` : '点击解析后自动生成',
      done: planReady,
    },
  ]

  return (
    <section className="card" style={{ marginTop: 12 }}>
      <div className="copilot-strip">
        <div>
          <div className="badge" style={{ background: '#e0f2fe', color: '#0369a1' }}>
            Copilot 进度
          </div>
          <div style={{ fontWeight: 700, marginTop: 6 }}>意图驱动流水线</div>
          <div style={{ color: 'var(--text-muted)', fontSize: 13, marginTop: 4 }}>
            Copilot 会在每个阶段提示“系统做了什么 / 你下一步做什么”。
          </div>
        </div>
        <div className="badge" style={{ background: '#eef2ff', color: '#4f46e5' }}>
          {planReady ? 'Plan Ready' : currentIntent ? 'Awaiting Plan' : 'Idle'}
        </div>
      </div>
      <div className="copilot-steps">
        {steps.map((step) => (
          <div key={step.id} className={`copilot-step ${step.done ? 'done' : 'pending'}`}>
            <div className="copilot-step-title">{step.label}</div>
            <div className="copilot-step-desc">{step.desc}</div>
            <div className="copilot-step-status">{step.done ? '完成' : '待处理'}</div>
          </div>
        ))}
      </div>
      {logs.length ? (
        <div className="console-window" style={{ marginTop: 16, height: 'auto' }}>
          <strong>最新日志</strong>
          <div>{logs[logs.length - 1]}</div>
        </div>
      ) : null}
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/file-tree-preview.tsx">
import { buildFileTree } from '../lib/virtual-file-tree'
import type { PlanSpec } from '../types'

interface Props {
  plan?: PlanSpec
}

export function FileTreePreview({ plan }: Props) {
  const tree = buildFileTree(plan)

  const renderNode = (node: ReturnType<typeof buildFileTree>[number], depth = 0) => {
    if (node.type === 'dir') {
      return (
        <div key={`${node.name}-${depth}`} className="file-node" style={{ marginLeft: depth * 12 }}>
          📁 {node.name}
          {node.children.map((child) => renderNode(child, depth + 1))}
        </div>
      )
    }
    return (
      <div key={`${node.name}-${depth}`} className="file-node" style={{ marginLeft: depth * 12 }}>
        📄 {node.name}
        <span style={{ color: '#9ca3af', marginLeft: 6 }}>
          {node.meta?.patternId ? `pattern: ${node.meta.patternId}` : ''}
          {node.meta?.template ? ` · tpl: ${node.meta.template}` : ''}
        </span>
      </div>
    )
  }

  return (
    <div className="file-tree">
      {tree.length === 0 ? <div>暂无 Plan 产物</div> : tree.map((node) => renderNode(node))}
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/flow-simulator.tsx">
import { useIntentStore } from '../stores/use-intent-store'
import { flowSources } from '../data'

export function FlowSimulator() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  const flow = intent?.runtimeFlows?.[0]
  if (!flow) return null
  const code = flowSources[flow.id]

  return (
    <div className="flow-viewer-grid">
      <div>
        <div className="section-label">Trigger → Pipeline</div>
        <div className="flow-steps">
          <div className="flow-step">
            <strong>Trigger</strong>
            <div style={{ color: 'var(--text-muted)', fontSize: 12 }}>
              {flow.trigger?.element} · {flow.trigger?.event}
            </div>
          </div>
          {flow.pipeline.map((step, index) => (
            <div key={index} className="flow-step">
              <strong>{step.call}</strong>
              {step.as ? <span> → {step.as}</span> : null}
            </div>
          ))}
        </div>
      </div>
      <div>
        <div className="section-label">Effect Runtime (.flow.ts)</div>
        <pre className="code-block" style={{ background: '#020617', color: '#cbd5f5', minHeight: 260 }}>
          {code}
        </pre>
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/flow-viewer.tsx">
import { flowSources } from '../data'
import { useIntentStore } from '../stores/use-intent-store'

export function FlowViewer() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  const flow = intent?.runtimeFlows?.[0]
  if (!flow) return null
  const code = flowSources[flow.id]

  return (
    <div className="card flow-card">
      <h3>Flow → Effect → Hook</h3>
      <div className="split-panel">
        <div>
          <div className="section-label">Flow Pipeline</div>
          <div className="flow-steps">
            {flow.pipeline.map((step, idx) => (
              <div key={idx} className="flow-step">
                <strong>{step.call}</strong>
                {step.as ? <span> → {step.as}</span> : null}
              </div>
            ))}
          </div>
        </div>
        <div>
          <div className="section-label">.flow.ts (Effect)</div>
          <pre className="code-block" style={{ background: 'rgba(15,23,42,0.85)', color: '#e5e7eb' }}>
            {code}
          </pre>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/intent-selector.tsx">
import { useIntentStore } from '../stores/use-intent-store'

export function IntentSelector() {
  const { intents, selectedIntentId, selectIntent } = useIntentStore()
  return (
    <div className="sidebar">
      <h1>Intent Catalog</h1>
      <div className="intent-list">
        {intents.map((intent) => (
          <button
            key={intent.id}
            className={intent.id === selectedIntentId ? 'active' : ''}
            onClick={() => selectIntent(intent.id)}
          >
            <div style={{ fontWeight: 700 }}>{intent.title}</div>
            <div style={{ fontSize: 13, color: '#cbd5e1' }}>{intent.description}</div>
          </button>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-editor-sections.tsx">
import type { PatternSpec } from '../types'
import { PatternRolesEditor } from './pattern-roles-editor'
import { PatternParamsEditor } from './pattern-params-editor'

interface Props {
  pattern: PatternSpec
}

export function PatternEditorSections({ pattern }: Props) {
  return (
    <div>
      <div style={{ marginTop: 16 }}>
        <h4>角色定义</h4>
        <PatternRolesEditor patternId={pattern.id} roles={pattern.composition?.roles ?? []} />
      </div>

      <div style={{ marginTop: 16 }}>
        <h4>参数 Schema</h4>
        <PatternParamsEditor patternId={pattern.id} paramsSchema={pattern.paramsSchema as any} />
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-form.tsx">
import type { PatternSpec } from '../types'
import { usePatternStore } from '../stores/use-pattern-store'
interface Props {
  pattern: PatternSpec
}

export function PatternForm({ pattern }: Props) {
  const updateDraft = usePatternStore((state) => state.updateDraft)

  const handleChange = (field: keyof PatternSpec, value: string) => {
    updateDraft(pattern.id, { [field]: value } as Partial<PatternSpec>)
  }

  return (
    <div className="pattern-form">
      <div className="form-grid">
        <div className="field">
          <label>模式 ID</label>
          <input value={pattern.id} onChange={(event) => handleChange('id', event.target.value)} />
        </div>
        <div className="field">
          <label>名称</label>
          <input value={pattern.name} onChange={(event) => handleChange('name', event.target.value)} />
        </div>
        <div className="field">
          <label>版本</label>
          <input value={pattern.version} onChange={(event) => handleChange('version', event.target.value)} />
        </div>
        <div className="field">
          <label>状态</label>
          <select value={pattern.status} onChange={(event) => handleChange('status', event.target.value)}>
            <option value="draft">draft</option>
            <option value="review">review</option>
            <option value="published">published</option>
          </select>
        </div>
      </div>
      <div className="field" style={{ marginTop: 16 }}>
        <label>摘要</label>
        <textarea rows={3} value={pattern.summary} onChange={(event) => handleChange('summary', event.target.value)} />
      </div>

    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-gallery.tsx">
import { patterns } from '../data'
import { useIntentStore } from '../stores/use-intent-store'

export function PatternGallery() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  return (
    <div className="card">
      <h3>Pattern Library</h3>
      <div className="pattern-list">
        {patterns.map((pattern) => {
          const isUsed = intent?.patterns.some((p) => p.id === pattern.id)
          return (
            <div
              key={pattern.id}
              className="pattern-card"
              style={{
                borderColor: isUsed ? 'var(--accent)' : 'var(--border)',
                background: isUsed ? 'var(--accent-soft)' : '#fff',
              }}
            ><header>
                <div>
                  <strong>{pattern.name}</strong>
                  <div style={{ fontSize: 12, color: 'var(--text-muted)' }}>{pattern.summary}</div>
                </div>
                <span className="badge">{pattern.status}</span>
              </header>
              <div className="section-label" style={{ marginTop: 12 }}>
                Roles
              </div>
              <ul style={{ paddingLeft: 18, margin: 0 }}>
                {pattern.composition?.roles.map((role) => (
                  <li key={role.id} style={{ marginBottom: 4 }}>
                    <strong>{role.label}</strong>
                    <span style={{ color: 'var(--text-muted)', marginLeft: 6 }}>
                      {role.requires?.map((req) => `requires ${req}`).join(', ')}
                    </span>
                  </li>
                ))}
              </ul>
            </div>
          )
        })}
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-intent-reference.tsx">
import { useIntentStore } from '../stores/use-intent-store'

interface Props {
  patternId: string
}

export function PatternIntentReference({ patternId }: Props) {
  const intents = useIntentStore((state) => state.intents)
  const refs = intents.filter((intent) => intent.patterns.some((p) => p.id === patternId))

  if (!refs.length) {
    return <div className="empty-state">暂时没有意图引用该模式。</div>
  }

  return (
    <ul className="asset-list">
      {refs.map((intent) => (
        <li key={intent.id}>
          <strong>{intent.title}</strong>
          <span>描述: {intent.description}</span>
        </li>
      ))}
    </ul>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-manager.tsx">
import { patterns } from '../data'
import type { IntentPatternConfig } from '../types'
import { useIntentStore } from '../stores/use-intent-store'

export function PatternManager() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  const updateIntent = useIntentStore((state) => state.updateIntent)
  const selectedIntentId = useIntentStore((state) => state.selectedIntentId)

  if (!intent) {
    return (
      <div className="card">
        <h4>模式选择</h4>
        <div className="empty-state">请先粘贴需求并解析出意图。</div>
      </div>
    )
  }

  const applied = new Set(intent.patterns.map((p) => p.id))

  const togglePattern = (patternId: string) => {
    const next: IntentPatternConfig[] = applied.has(patternId)
      ? intent.patterns.filter((p) => p.id !== patternId)
      : [...intent.patterns, { id: patternId, config: {}, target: 'auto' }]
    updateIntent(selectedIntentId, { patterns: next })
  }

  return (
    <div className="card">
      <h4>模式选择 / 绑定</h4>
      <p className="panel-desc">从平台模式库中挑选或移除当前意图的模式，演示“用户自主选择”的能力。</p>
      <div className="asset-list" style={{ maxHeight: 320, overflow: 'auto' }}>
        {patterns.map((pattern) => (
          <div key={pattern.id} className="pattern-card" style={{ borderColor: applied.has(pattern.id) ? 'var(--accent)' : 'var(--border)' }}>
            <header>
              <div>
                <strong>{pattern.name}</strong>
                <div style={{ fontSize: 12, color: 'var(--text-muted)' }}>{pattern.summary}</div>
              </div>
              <button
                className={applied.has(pattern.id) ? 'secondary-button' : 'primary-button'}
                onClick={() => togglePattern(pattern.id)}
              >
                {applied.has(pattern.id) ? '移除' : '应用'}
              </button>
            </header>
          </div>
        ))}
      </div>
      <div className="badge" style={{ marginTop: 10 }}>
        已应用：{applied.size} / {patterns.length}
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-nav-tabs.tsx">
interface Tab {
  id: string
  label: string
}

interface Props {
  tabs: Tab[]
  active: string
  onChange: (id: string) => void
}

export function PatternNavTabs({ tabs, active, onChange }: Props) {
  return (
    <div className="tabs compact">
      {tabs.map((tab) => (
        <button
          key={tab.id}
          className={tab.id === active ? 'active' : ''}
          onClick={() => onChange(tab.id)}
        >
          {tab.label}
        </button>
      ))}
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-params-editor.tsx">
import { usePatternStore } from '../stores/use-pattern-store'

interface ParamField {
  key: string
  type: string
  required?: boolean
  desc?: string
}

interface Props {
  patternId: string
  paramsSchema?: Record<string, { type?: string; required?: boolean; desc?: string }>
}

export function PatternParamsEditor({ patternId, paramsSchema = {} }: Props) {
  const updateDraft = usePatternStore((state) => state.updateDraft)
  const entries = Object.entries(paramsSchema) as [string, { type?: string; required?: boolean; desc?: string }][]

  type SchemaEntry = [string, { type?: string; required?: boolean; desc?: string }]

  const updateEntries = (next: SchemaEntry[]) => {
    updateDraft(patternId, {
      paramsSchema: Object.fromEntries(next),
    })
  }

  const handleChange = (index: number, field: keyof ParamField, value: string | boolean) => {
    const next = entries.map(([key, schema], idx) => {
      if (idx !== index) return [key, schema] as [string, { type?: string; required?: boolean; desc?: string }]
      if (field === 'key') {
        return [value as string, schema]
      }
      return [key, { ...schema, [field]: value }]
    }) as SchemaEntry[]
    updateEntries(next)
  }

  const addField = () => {
    updateEntries([...entries, [`field_${entries.length + 1}`, { type: 'string', required: false }]])
  }

  const removeField = (index: number) => updateEntries(entries.filter((_, idx) => idx !== index))

  if (!entries.length) {
    return (
      <div>
        <div className="empty-state">暂无参数定义。</div>
        <button className="primary-button" type="button" onClick={addField}>
          添加参数
        </button>
      </div>
    )
  }

  return (
    <div>
      {entries.map(([key, schema], index) => (
        <div key={key} className="pattern-card" style={{ marginBottom: 12 }}>
          <div className="form-grid">
            <div className="field">
              <label>字段 Key</label>
              <input value={key} onChange={(event) => handleChange(index, 'key', event.target.value)} />
            </div>
            <div className="field">
              <label>类型</label>
              <select value={schema.type} onChange={(event) => handleChange(index, 'type', event.target.value)}>
                <option value="string">string</option>
                <option value="number">number</option>
                <option value="boolean">boolean</option>
                <option value="array">array</option>
                <option value="object">object</option>
              </select>
            </div>
            <div className="field">
              <label>是否必填</label>
              <input
                type="checkbox"
                checked={Boolean(schema.required)}
                onChange={(event) => handleChange(index, 'required', event.target.checked)}
              />
            </div>
          </div>
          <div className="field" style={{ marginTop: 8 }}>
            <label>描述</label>
            <textarea
              rows={2}
              value={schema.desc ?? ''}
              onChange={(event) => handleChange(index, 'desc', event.target.value)}
            />
          </div>
          <div className="actions-row" style={{ marginTop: 8 }}>
            <button className="secondary-button" type="button" onClick={() => removeField(index)}>
              删除字段
            </button>
          </div>
        </div>
      ))}
      <button className="primary-button" type="button" onClick={addField}>
        添加参数
      </button>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-registry-view.tsx">
import { useParams } from 'react-router-dom'
import { PatternIntentReference } from './pattern-intent-reference'
import { usePatternStore } from '../stores/use-pattern-store'

export function PatternRegistryView() {
  const { patternId } = useParams()
  const patterns = usePatternStore((state) => state.patterns)
  const publish = usePatternStore((state) => state.publishPattern)
  const pattern = patterns.find((item) => item.id === patternId)

  if (!patternId || !pattern) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">未找到模式。</div>
        </section>
      </div>
    )
  }

  const handlePublish = () => publish(pattern.id)

  return (
    <div className="workspace">
      <section className="card">
        <div className="badge" style={{ background: '#fef9c3', color: '#a16207' }}>模式上架 / 关联</div>
        <h2>{pattern.name}</h2>
        <p className="panel-desc">查看并确认该模式的引用情况，执行发布或下线。</p>
        <div className="actions-row">
          <button className="primary-button" onClick={handlePublish}>
            发布模式
          </button>
        </div>
        <div style={{ marginTop: 16 }}>
          <h4>引用此模式的意图</h4>
          <PatternIntentReference patternId={pattern.id} />
        </div>
        <div style={{ marginTop: 16 }}>
          <h4>模式摘要</h4>
          <pre className="code-block">{JSON.stringify(pattern, null, 2)}</pre>
        </div>
      </section>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-roles-editor.tsx">
import type { PatternRole } from '../types'
import { usePatternStore } from '../stores/use-pattern-store'

interface Props {
  patternId: string
  roles?: PatternRole[]
}

const emptyRole = (): PatternRole => ({
  id: `role-${Date.now()}`,
  label: '未命名角色',
  description: '',
  provides: undefined,
  requires: undefined,
})

export function PatternRolesEditor({ patternId, roles = [] }: Props) {
  const updateDraft = usePatternStore((state) => state.updateDraft)

  const updateRoles = (next: PatternRole[]) => {
    updateDraft(patternId, {
      composition: {
        roles: next,
      },
    })
  }

  const handleChange = (index: number, field: keyof PatternRole, value: string) => {
    const next = roles.map((role, idx) =>
      idx === index
        ? {
            ...role,
            [field]: value,
          }
        : role
    )
    updateRoles(next)
  }

  const handleCommaFields = (index: number, field: 'requires' | 'provides', value: string) => {
    const list = value
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean)
    const next = roles.map((role, idx) =>
      idx === index
        ? {
            ...role,
            [field]: list.length ? list : undefined,
          }
        : role
    )
    updateRoles(next)
  }

  const addRole = () => updateRoles([...roles, emptyRole()])

  const removeRole = (index: number) => updateRoles(roles.filter((_, idx) => idx !== index))

  if (!roles.length) {
    return (
      <div>
        <div className="empty-state">暂无角色，点击下方按钮添加。</div>
        <button className="primary-button" type="button" onClick={addRole}>
          添加角色
        </button>
      </div>
    )
  }

  return (
    <div>
      {roles.map((role, index) => (
        <div key={role.id} className="pattern-card" style={{ marginBottom: 12 }}>
          <div className="form-grid">
            <div className="field">
              <label>角色 ID</label>
              <input value={role.id} onChange={(event) => handleChange(index, 'id', event.target.value)} />
            </div>
            <div className="field">
              <label>显示名称</label>
              <input value={role.label} onChange={(event) => handleChange(index, 'label', event.target.value)} />
            </div>
          </div>
          <div className="field">
            <label>描述</label>
            <textarea
              rows={2}
              value={role.description ?? ''}
              onChange={(event) => handleChange(index, 'description', event.target.value)}
            />
          </div>
          <div className="form-grid">
            <div className="field">
              <label>provides（逗号分隔）</label>
              <input
                value={Array.isArray(role.provides) ? role.provides.join(', ') : role.provides ?? ''}
                onChange={(event) => handleCommaFields(index, 'provides', event.target.value)}
              />
            </div>
            <div className="field">
              <label>requires（逗号分隔）</label>
              <input
                value={Array.isArray(role.requires) ? role.requires.join(', ') : ''}
                onChange={(event) => handleCommaFields(index, 'requires', event.target.value)}
              />
            </div>
          </div>
          <div className="actions-row" style={{ marginTop: 8 }}>
            <button className="secondary-button" type="button" onClick={() => removeRole(index)}>
              移除角色
            </button>
          </div>
        </div>
      ))}
      <button className="primary-button" type="button" onClick={addRole}>
        添加角色
      </button>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-runtime-binds.tsx">
import { usePatternStore } from '../stores/use-pattern-store'

interface Props {
  patternId: string
  runtimeBindings?: Record<string, { component?: string; service?: string }>
}

export function PatternRuntimeBinds({ patternId, runtimeBindings = {} }: Props) {
  const updateDraft = usePatternStore((state) => state.updateDraft)
  const entries = Object.entries(runtimeBindings) as [string, { component?: string; service?: string }][]

  const updateEntries = (
    next: Array<[string, { component?: string; service?: string }]>
  ) => {
    updateDraft(patternId, {
      runtimeBindings: Object.fromEntries(next),
    })
  }

  const handleChange = (
    index: number,
    field: keyof { component?: string; service?: string },
    value: string
  ) => {
    const next = entries.map(([key, entry], idx) =>
      idx === index
        ? [key, { ...entry, [field]: value }]
        : [key, entry]
    ) as [string, { component?: string; service?: string }][]
    updateEntries(next)
  }

  const handleKeyChange = (index: number, value: string) => {
    const next = entries.map(([key, entry], idx) =>
      idx === index ? [value, entry] : [key, entry]
    ) as [string, { component?: string; service?: string }][]
    updateEntries(next)
  }

  const addEntry = () => {
    updateEntries([...entries, [`slot_${entries.length + 1}`, { component: '', service: '' }]])
  }

  const removeEntry = (index: number) => updateEntries(entries.filter((_, idx) => idx !== index))

  return (
    <div>
      {entries.map(([key, entry], index) => (
        <div key={key} className="pattern-card" style={{ marginBottom: 12 }}>
          <div className="form-grid">
            <div className="field">
              <label>绑定 Key</label>
              <input value={key} onChange={(event) => handleKeyChange(index, event.target.value)} />
            </div>
            <div className="field">
              <label>组件 (import)</label>
              <input value={entry.component ?? ''} onChange={(event) => handleChange(index, 'component', event.target.value)} />
            </div>
            <div className="field">
              <label>Service 提供者</label>
              <input value={entry.service ?? ''} onChange={(event) => handleChange(index, 'service', event.target.value)} />
            </div>
          </div>
          <div className="actions-row" style={{ marginTop: 8 }}>
            <button className="secondary-button" type="button" onClick={() => removeEntry(index)}>
              删除绑定
            </button>
          </div>
        </div>
      ))}
      <button className="primary-button" type="button" onClick={addEntry}>
        添加 runtime 绑定
      </button>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-runtime-section.tsx">
import { PatternRuntimeBinds } from './pattern-runtime-binds'
import { PatternUiSchemaEditor } from './pattern-ui-schema-editor'
import type { PatternSpec } from '../types'

interface Props {
  pattern: PatternSpec
}

export function PatternRuntimeSection({ pattern }: Props) {
  return (
    <div className="split-panel" style={{ marginTop: 16 }}>
      <div>
        <h4>UI Schema（可视化配置）</h4>
        <PatternUiSchemaEditor patternId={pattern.id} uiSchema={pattern.uiSchema as any} />
      </div>
      <div>
        <h4>Runtime Bindings（组件/服务）</h4>
        <PatternRuntimeBinds patternId={pattern.id} runtimeBindings={pattern.runtimeBindings as any} />
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-studio.tsx">
import { useState } from 'react'
import { usePatternStore } from '../stores/use-pattern-store'
import { PatternForm } from './pattern-form'
import { PatternIntentReference } from './pattern-intent-reference'
import { PatternNavTabs } from './pattern-nav-tabs'
import { PatternEditorSections } from './pattern-editor-sections'
import { PatternRuntimeSection } from './pattern-runtime-section'

export function PatternStudio({ patternId }: { patternId?: string }) {
  const pattern = usePatternStore((state) => (patternId ? state.drafts[patternId] : undefined))
  const createDraft = usePatternStore((state) => state.createDraft)
  const saveDraft = usePatternStore((state) => state.saveDraft)
  const publishPattern = usePatternStore((state) => state.publishPattern)
  const [activeTab, setActiveTab] = useState('base')

  if (!patternId) {
    return (
      <section className="card">
        <div className="empty-state">请选择或创建模式。</div>
        <button className="primary-button" onClick={createDraft}>新建模式草稿</button>
      </section>
    )
  }

  if (!pattern) {
    return (
      <section className="card">
        <div className="empty-state">未找到模式 {patternId}。</div>
      </section>
    )
  }

  return (
    <section className="card">
      <div className="badge" style={{ background: '#ecfccb', color: '#4d7c0f' }}>Pattern Studio</div>
      <h2>维护模式 · {pattern.name}</h2>
      <PatternNavTabs
        tabs={[
          { id: 'base', label: '基础信息' },
          { id: 'roles', label: '角色/参数' },
          { id: 'runtime', label: 'UI & Runtime' },
          { id: 'references', label: '引用' },
        ]}
        active={activeTab}
        onChange={setActiveTab}
      />
      {activeTab === 'base' ? <PatternForm pattern={pattern} /> : null}
      {activeTab === 'roles' ? <PatternEditorSections pattern={pattern} /> : null}
      {activeTab === 'runtime' ? <PatternRuntimeSection pattern={pattern} /> : null}
      {activeTab === 'references' ? (
        <div style={{ marginTop: 24 }}>
          <h4>引用此模式的意图</h4>
          <PatternIntentReference patternId={pattern.id} />
        </div>
      ) : null}
      <div className="actions-row" style={{ marginTop: 16 }}>
        <button className="primary-button" onClick={() => saveDraft(pattern.id)}>
          保存草稿
        </button>
        <button className="secondary-button" onClick={() => publishPattern(pattern.id)}>
          发布
        </button>
      </div>
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pattern-ui-schema-editor.tsx">
import { usePatternStore } from '../stores/use-pattern-store'

type UiSchemaEntry = {
  widget?: string
  label?: string
  options?: string
}

interface Props {
  patternId: string
  uiSchema?: Record<string, UiSchemaEntry>
}

export function PatternUiSchemaEditor({ patternId, uiSchema = {} }: Props) {
  const updateDraft = usePatternStore((state) => state.updateDraft)
  const entries = Object.entries(uiSchema) as [string, UiSchemaEntry][]

  const updateEntries = (next: [string, UiSchemaEntry][]) => {
    updateDraft(patternId, {
      uiSchema: Object.fromEntries(next),
    })
  }

  const handleChange = (index: number, field: keyof UiSchemaEntry, value: string) => {
    const next = entries.map(([key, schema], idx) =>
      idx === index
        ? [key, { ...schema, [field]: value }]
        : [key, schema]
    ) as [string, UiSchemaEntry][]
    updateEntries(next)
  }

  const handleKeyChange = (index: number, value: string) => {
    const next = entries.map(([key, schema], idx) =>
      idx === index
        ? [value, schema]
        : [key, schema]
    ) as [string, UiSchemaEntry][]
    updateEntries(next)
  }

  const addField = () => {
    updateEntries([...entries, [`field_${entries.length + 1}`, { widget: 'input', label: '' }]])
  }

  const removeField = (index: number) => updateEntries(entries.filter((_, idx) => idx !== index))

  return (
    <div>
      {entries.map(([key, schema], index) => (
        <div key={key} className="pattern-card" style={{ marginBottom: 12 }}>
          <div className="form-grid">
            <div className="field">
              <label>字段 Key</label>
              <input value={key} onChange={(event) => handleKeyChange(index, event.target.value)} />
            </div>
            <div className="field">
              <label>Widget</label>
              <select value={schema.widget} onChange={(event) => handleChange(index, 'widget', event.target.value)}>
                <option value="input">input</option>
                <option value="select">select</option>
                <option value="checkbox">checkbox</option>
                <option value="column-picker">column-picker</option>
              </select>
            </div>
            <div className="field">
              <label>Label</label>
              <input value={schema.label ?? ''} onChange={(event) => handleChange(index, 'label', event.target.value)} />
            </div>
          </div>
          <div className="field">
            <label>Options / 描述</label>
            <textarea
              rows={2}
              placeholder="例如: options=order.fields"
              value={schema.options ?? ''}
              onChange={(event) => handleChange(index, 'options', event.target.value)}
            />
          </div>
          <div className="actions-row" style={{ marginTop: 8 }}>
            <button className="secondary-button" type="button" onClick={() => removeField(index)}>
              删除 UI 配置
            </button>
          </div>
        </div>
      ))}
      <button className="primary-button" type="button" onClick={addField}>
        添加 UI 配置
      </button>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pipeline-header.tsx">
export function PipelineHeader() {
  return (
    <header style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
      <div>
        <div style={{ fontSize: 13, letterSpacing: '0.1em', color: 'var(--text-muted)', textTransform: 'uppercase' }}>
          Intent-Driven Platform
        </div>
        <h1 style={{ margin: '6px 0 0' }}>Intent → Pattern → Plan → Flow</h1>
        <p style={{ marginTop: 8, color: 'var(--text-muted)' }}>
          结构化意图，驱动模式库、生成 Plan 与运行时 Flow 的全链路 IDE。
        </p>
      </div>
      <div style={{ textAlign: 'right' }}>
        <div className="badge" style={{ background: '#dcfce7', color: '#166534' }}>
          Prototype · React + Vite
        </div>
        <div style={{ fontSize: 12, color: 'var(--text-muted)', marginTop: 6 }}>
          数据全部来自 docs/specs/intent-driven-ai-coding/v1
        </div>
      </div>
    </header>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/pipeline-shell.tsx">
import { useIntentStore } from '../stores/use-intent-store'
import { PipelineHeader } from './pipeline-header'
import { CopilotBar } from './copilot-bar'
import { RolePanels } from './role-panels'
import { ResultsDock } from './results-dock'
import { RequirementIntake } from './requirement-intake'
import { PlanSimulationProvider } from '../contexts/plan-simulation-context'
import { PlatformAssets } from './platform-assets'

export function PipelineShell() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])

  return (
    <PlanSimulationProvider intent={intent}>
      <main className="main">
        <PipelineHeader />
        <RequirementIntake />
        <CopilotBar />
        <RolePanels />
        <PlatformAssets />
        <ResultsDock />
      </main>
    </PlanSimulationProvider>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/plan-console.tsx">
import YAML from 'yaml'
import { usePlanSimulationContext } from '../contexts/plan-simulation-context'

export function PlanConsole() {
  const { plan, logs, generatePlan, executePlan, isGenerating, isExecuting } =
    usePlanSimulationContext()

  if (!plan && logs.length === 0) {
    return (
      <div className="card">
        <h2>Plan Console (Mock CLI)</h2>
        <div className="empty-state">等待解析后自动生成 Plan，或点击“Generate Plan”。</div>
        <div className="actions-row" style={{ marginTop: 12 }}>
          <button className="primary-button" onClick={generatePlan} disabled={isGenerating}>
            {isGenerating ? 'Synthesizing…' : 'Generate Plan'}
          </button>
        </div>
      </div>
    )
  }

  return (
    <div className="card">
      <h2>Plan Console (Mock CLI)</h2>
      <div className="actions-row" style={{ marginBottom: 16 }}>
        <button
          className="primary-button"
          onClick={generatePlan}
          disabled={isGenerating}
        >
          {isGenerating ? 'Synthesizing…' : 'Generate Plan'}
        </button>
        <button
          className="secondary-button"
          onClick={executePlan}
          disabled={isExecuting}
        >
          {isExecuting ? 'Executing…' : 'Execute Plan (Mock)'}
        </button>
        <span style={{ color: 'var(--text-muted)', fontSize: 13 }}>
          模拟 CLI 行为：意图 → Plan → create-file 列表
        </span>
      </div>
      <div className="plan-console">
        <div className="console-window">
          <h4>Logs</h4>
          {logs?.map((line, idx) => (
            <div key={idx}>{line}</div>
          ))}
        </div>
        <div className="yaml-preview" style={{ height: 280 }}>
          <h4 style={{ marginTop: 0 }}>Plan JSON</h4>
          <pre>{plan ? YAML.stringify(plan) : '尚未生成 Plan'}</pre>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/platform-assets.tsx">
import { patterns, templates } from '../data'

export function PlatformAssets() {
  return (
    <section className="card">
      <div className="badge" style={{ background: '#fef9c3', color: '#a16207' }}>平台资产</div>
      <h3>模式 / 模板 / 计划基座</h3>
      <p className="panel-desc">展示平台已经收录的可复用资产，方便 LLM 与人工共同扩展。</p>
      <div className="assets-grid">
        <div>
          <div className="section-label">Patterns · {patterns.length}</div>
          <ul className="asset-list">
            {patterns.map((pattern) => (
              <li key={pattern.id}>
                <strong>{pattern.name}</strong>
                <span>{pattern.summary}</span>
              </li>
            ))}
          </ul>
        </div>
        <div>
          <div className="section-label">Templates · {templates.length}</div>
          <ul className="asset-list">
            {templates.map((template) => (
              <li key={template.id}>
                <strong>{template.name}</strong>
                <span>{template.description}</span>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/requirement-intake.tsx">
import { useMemo, useState } from 'react'
import { requirementCases } from '../data/requirements'
import type { RequirementId } from '../data/requirements'
import { intents as canonicalIntents } from '../data'
import { useIntentStore } from '../stores/use-intent-store'
import { usePlanSimulationContext } from '../contexts/plan-simulation-context'
import { useSessionStore } from '../stores/use-session-store'

const guessRequirement = (text: string) => {
  const lower = text.toLowerCase()
  if (!lower.trim()) return undefined
  const byTitle = requirementCases.find((req) => lower.includes(req.title.toLowerCase()))
  if (byTitle) return byTitle
  if (lower.includes('导出') && lower.includes('订单')) {
    return requirementCases.find((req) => req.id === 'order-export-demand')
  }
  if (lower.includes('工作台') || lower.includes('指派') || lower.includes('任务')) {
    return requirementCases.find((req) => req.id === 'ops-workbench-demand')
  }
  return undefined
}

export function RequirementIntake() {
  const selectIntent = useIntentStore((state) => state.selectIntent)
  const loadIntentSnapshot = useIntentStore((state) => state.loadIntentSnapshot)
  const markRequirementInput = useSessionStore((state) => state.setHasRequirementInput)
  const [documentText, setDocumentText] = useState('')
  const [selectedExample, setSelectedExample] = useState<RequirementId>(
    requirementCases[0]?.id ?? 'order-export-demand'
  )
  const [activeExample, setActiveExample] = useState<(typeof requirementCases)[number] | null>(null)
  const [llmOutput, setLlmOutput] = useState<string[]>([])
  const [status, setStatus] = useState<'idle' | 'parsing' | 'ready' | 'error'>('idle')
  const [error, setError] = useState<string | null>(null)
  const { generatePlan } = usePlanSimulationContext()

  const highlightedExample = useMemo(
    () => activeExample ?? requirementCases.find((req) => req.id === selectedExample) ?? null,
    [activeExample, selectedExample]
  )

  const handleLoadExample = () => {
    const example = requirementCases.find((req) => req.id === selectedExample)
    if (!example) return
    setDocumentText(example.document ?? '')
    setActiveExample(example)
    setStatus('idle')
    setError(null)
    setLlmOutput([])
    markRequirementInput(true)
  }

  const handleChangeDocument = (value: string) => {
    setDocumentText(value)
    setActiveExample(null)
    setStatus('idle')
    setError(null)
    setLlmOutput([])
    markRequirementInput(Boolean(value.trim()))
  }

  const handleParse = () => {
    if (!documentText.trim()) {
      setError('请先粘贴需求文档或加载示例。')
      setStatus('error')
      return
    }
    setStatus('parsing')
    const matched = activeExample ?? guessRequirement(documentText)
    if (!matched?.readyIntentId) {
      setError('LLM 未能匹配到平台意图，请补充更具体的描述。')
      setStatus('error')
      return
    }
    setActiveExample(matched)
    const canonical = canonicalIntents.find((intent) => intent.id === matched.readyIntentId)
    if (!canonical) {
      setError('平台暂未收录该意图，请先在资产库创建。')
      setStatus('error')
      return
    }
    loadIntentSnapshot(canonical)
    selectIntent(canonical.id)
    setLlmOutput(matched.llmSummaryBullets ?? [])
    setStatus('ready')
    setError(null)
    setTimeout(() => {
      generatePlan()
    }, 0)
  }

  return (
    <section className="card" style={{ marginTop: 12 }}>
      <div className="badge" style={{ background: '#e0f2fe', color: '#0369a1' }}>Step 1 · 粘贴需求</div>
      <h3>告诉平台你要做什么</h3>
      <p className="panel-desc">
        粘贴需求原文或一键加载示例，平台会调用 LLM 解析结构化意图，随后推送到 Pattern/Plan/Flow。
      </p>
      <div className="form-grid">
        <div className="field" style={{ gridColumn: '1 / -1' }}>
          <label>需求文档 / 会议纪要</label>
          <textarea
            rows={5}
            value={documentText}
            placeholder="粘贴真实需求……"
            onChange={(event) => handleChangeDocument(event.target.value)}
          />
        </div>
      </div>
      <div className="actions-row" style={{ marginTop: 12 }}>
        <div className="field" style={{ flex: '1 1 240px' }}>
          <label>示例需求（演示）</label>
          <select value={selectedExample} onChange={(event) => setSelectedExample(event.target.value as RequirementId)}>
            {requirementCases.map((req) => (
              <option key={req.id} value={req.id}>
                {req.title}
              </option>
            ))}
          </select>
        </div>
        <button className="secondary-button" onClick={handleLoadExample}>
          填充示例文档
        </button>
        <button className="primary-button" onClick={handleParse}>
          {status === 'parsing' ? 'LLM 解析中…' : '解析为意图并生成 Plan'}
        </button>
      </div>
      {error ? <div className="error-text">{error}</div> : null}
      {highlightedExample ? (
        <div className="pattern-card" style={{ marginTop: 16 }}>
          <strong>示例说明 · {highlightedExample.title}</strong>
          <div style={{ color: 'var(--text-muted)', marginTop: 4 }}>{highlightedExample.summary}</div>
          <div className="section-label" style={{ marginTop: 8 }}>痛点 / 约束</div>
          <ul style={{ margin: 0, paddingLeft: 18 }}>
            {highlightedExample.painPoints.map((point) => (
              <li key={point}>{point}</li>
            ))}
          </ul>
          {llmOutput.length ? (
            <div style={{ marginTop: 12 }}>
              <div className="section-label">LLM 输出（演示）</div>
              <ul style={{ margin: 0, paddingLeft: 18 }}>
                {llmOutput.map((line) => (
                  <li key={line}>{line}</li>
                ))}
              </ul>
            </div>
          ) : null}
        </div>
      ) : null}
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/results-dock.tsx">
import { FlowSimulator } from './flow-simulator'
import { FileTreePreview } from './file-tree-preview'
import { usePlanSimulationContext } from '../contexts/plan-simulation-context'
import { useSessionStore } from '../stores/use-session-store'

export function ResultsDock() {
  const { plan, logs } = usePlanSimulationContext()
  const ready = useSessionStore((state) => state.hasRequirementInput)
  if (!ready) {
    return (
      <section className="card">
        <h3>成果区 · 实时产出</h3>
        <div className="empty-state">等待解析意图后生成文件树与行为模拟。</div>
      </section>
    )
  }
  return (
    <section className="card">
      <h3>成果区 · 实时产出</h3>
      <p className="panel-desc">显示行为、虚拟文件树和 CLI 输出，给团队直观“做了什么”。</p>
      {!plan ? (
        <div className="empty-state">LLM 已解析意图，点击“解析”后自动生成 Plan 与 Flow。</div>
      ) : (
        <>
          <div className="panels-grid">
            <div className="card" style={{ background: '#0b1120', color: '#e2e8f0' }}>
              <h4 style={{ marginTop: 0 }}>Flow 模拟</h4>
              <FlowSimulator />
            </div>
            <div className="card">
              <h4 style={{ marginTop: 0 }}>虚拟文件树</h4>
              <FileTreePreview plan={plan} />
            </div>
          </div>
          <div className="console-window" style={{ marginTop: 16, background: '#111827' }}>
            <h4 style={{ marginTop: 0 }}>CLI / Plan 输出</h4>
            {logs.length === 0 ? <div style={{ color: '#94a3b8' }}>尚无日志</div> : null}
            {logs.map((line, idx) => (
              <div key={idx}>{line}</div>
            ))}
          </div>
        </>
      )}
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/role-panels.tsx">
import { useState } from 'react'
import type { ReactNode } from 'react'
import { RoleSwitcher } from './role-switcher'
import { IntentTabs } from './intent-studio/intent-tabs'
import { PatternGallery } from './pattern-gallery'
import { TemplateExplorer } from './template-explorer'
import { PlanConsole } from './plan-console'
import { FlowSimulator } from './flow-simulator'
import { useSessionStore } from '../stores/use-session-store'
import { useIntentStore } from '../stores/use-intent-store'
import { PatternManager } from './pattern-manager'

interface PanelProps {
  children: ReactNode
}

function PanelContainer({ children }: PanelProps) {
  return <div className="role-panel">{children}</div>
}

export function RolePanels() {
  const [role, setRole] = useState('product')
  const hasRequirementInput = useSessionStore((state) => state.hasRequirementInput)
  const hasIntent = useIntentStore((state) => Boolean(state.selectedIntentId))
  const ready = hasRequirementInput || hasIntent

  if (!ready) {
    return (
      <section className="card">
        <div className="role-panel-header">
          <div>
            <div className="badge" style={{ background: '#fee2e2', color: '#b91c1c' }}>
              角色模式
            </div>
            <h2>待解析意图</h2>
            <p className="panel-desc">粘贴需求并解析后，这里会展示各角色关心的视图。</p>
          </div>
        </div>
        <div className="empty-state">暂无结构化意图，请先完成 Step 1。</div>
      </section>
    )
  }

  const renderPanel = () => {
    switch (role) {
      case 'product':
        return (
          <PanelContainer>
            <h3>需求视图</h3>
            <p className="panel-desc">适合产品/运营：聚焦意图、目标、场景。</p>
            <IntentTabs />
          </PanelContainer>
        )
      case 'engineer':
        return (
          <PanelContainer>
            <h3>工程视图</h3>
            <p className="panel-desc">选择/绑定模式 → 查看模板映射 → 生成 Plan。</p>
            <div className="panels-grid">
              <PatternManager />
              <TemplateExplorer />
            </div>
            <div className="panels-grid" style={{ marginTop: 16 }}>
              <PatternGallery />
              <PlanConsole />
            </div>
          </PanelContainer>
        )
      case 'runtime':
        return (
          <PanelContainer>
            <h3>运行时视图</h3>
            <p className="panel-desc">Flow DSL → Effect → Hook → 行为执行。</p>
            <FlowSimulator />
          </PanelContainer>
        )
      default:
        return null
    }
  }

  return (
    <section className="card">
      <div className="role-panel-header">
        <div>
          <div className="badge" style={{ background: '#fee2e2', color: '#b91c1c' }}>
            角色模式
          </div>
          <h2>按角色切换信息密度</h2>
          <p className="panel-desc">不同角色关注各自任务，系统自动折叠无关内容。</p>
        </div>
        <RoleSwitcher value={role} onChange={setRole} />
      </div>
      {renderPanel()}
    </section>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/role-switcher.tsx">
const roles = [
  {
    id: 'product',
    label: '需求视图',
    description: '结构化意图、目标、场景',
  },
  {
    id: 'engineer',
    label: '工程视图',
    description: '模式/模版/Plan 资产',
  },
  {
    id: 'runtime',
    label: '运行时视图',
    description: 'Flow DSL 与 Effect 执行',
  },
]

interface Props {
  value: string
  onChange: (roleId: string) => void
}

export function RoleSwitcher({ value, onChange }: Props) {
  const handleSelect = (roleId: string) => {
    if (roleId === value) return
    onChange(roleId)
  }

  return (
    <div className="role-switcher">
      {roles.map((role) => (
        <button
          key={role.id}
          className={role.id === value ? 'active' : ''}
          onClick={() => handleSelect(role.id)}
        >
          <div style={{ fontWeight: 600 }}>{role.label}</div>
          <small>{role.description}</small>
        </button>
      ))}
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/components/template-explorer.tsx">
import { templates } from '../data'
import { useIntentStore } from '../stores/use-intent-store'

export function TemplateExplorer() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])

  return (
    <div className="card">
      <h3>Template Bindings</h3>
      {templates.map((template) => (
        <div key={template.id} className="pattern-card">
          <header>
            <strong>{template.name}</strong>
            <span className="badge">{template.version}</span>
          </header>
          <div className="section-label" style={{ marginTop: 12 }}>
            Pattern Roles
          </div>
          <ul style={{ paddingLeft: 18, margin: 0 }}>
            {template.patterns.map((binding) => (
              <li key={binding.patternId} style={{ marginBottom: 6 }}>
                <strong>{binding.patternId}</strong>
                <span style={{ marginLeft: 6, color: 'var(--text-muted)' }}>
                  {binding.implements.map((impl) => impl.role).join(', ')}
                </span>
              </li>
            ))}
          </ul>
          {intent?.patterns?.some((patternConfig) =>
            template.patterns.some((binding) => binding.patternId === patternConfig.id)
          ) ? (
            <div className="badge" style={{ background: '#dcfce7', color: '#166534', marginTop: 10 }}>
              Applied in current intent
            </div>
          ) : null}
        </div>
      ))}
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/contexts/plan-simulation-context.tsx">
import { createContext, useContext } from 'react'
import type { ReactNode } from 'react'
import type { IntentSpec } from '../types'
import { usePlanSimulator } from '../hooks/use-plan-simulator'

const PlanSimulationContext = createContext<ReturnType<typeof usePlanSimulator> | null>(null)

interface ProviderProps {
  intent?: IntentSpec
  children: ReactNode
}

export function PlanSimulationProvider({ intent, children }: ProviderProps) {
  const value = usePlanSimulator(intent)
  return <PlanSimulationContext.Provider value={value}>{children}</PlanSimulationContext.Provider>
}

export function usePlanSimulationContext() {
  const ctx = useContext(PlanSimulationContext)
  if (!ctx) throw new Error('usePlanSimulationContext must be used inside PlanSimulationProvider')
  return ctx
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/flows/export-orders.flow.ts">
export interface ExportOrdersEnv {
  FilterService: {
    getCurrentFilters: () => Promise<Record<string, unknown>>
  }
  TableUiStateService: {
    getCurrentState: () => Promise<{ visibleColumns: string[]; [key: string]: unknown }>
  }
  ExportService: {
    submitExportTask: (payload: {
      filters: Record<string, unknown>
      columns: string[]
    }) => Promise<void>
  }
}

export async function exportOrdersFlow(env: ExportOrdersEnv) {
  const filters = await env.FilterService.getCurrentFilters()
  const tableState = await env.TableUiStateService.getCurrentState()

  await env.ExportService.submitExportTask({
    filters,
    columns: tableState.visibleColumns,
  })
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/intents/ops-workbench.intent.json">
{
  "id": "ops-workbench",
  "title": "运营工作台",
  "description": "统一处理运营任务的桌面工作台",
  "goals": [
    "提升任务处理效率 30%",
    "支持 1440px 桌面 + 窄屏折叠"
  ],
  "scene": {
    "type": "workbench",
    "actors": [
      { "role": "operator", "description": "日常处理任务的运营人员" }
    ],
    "flows": [
      { "from": "待处理列表", "to": "详情面板", "action": "开始处理任务" },
      { "from": "详情面板", "to": "待处理列表", "action": "完成任务后返回" }
    ]
  },
  "patterns": [
    {
      "id": "workbench-layout",
      "config": {
        "leftPanelId": "tasks-list",
        "rightPanelId": "task-detail",
        "metricsRegionId": "metrics",
        "layoutMode": "two-column"
      }
    },
    {
      "id": "table-with-server-filter",
      "target": "tasks-list",
      "config": {
        "entity": "Task",
        "pagination": true,
        "batchActions": ["assign", "complete"]
      }
    },
    {
      "id": "service-adapter-query",
      "config": {
        "entity": "Task",
        "resourceName": "tasks",
        "operations": ["list", "detail"],
        "hasPagination": true
      }
    },
    {
      "id": "zustand-store-with-slices",
      "config": {
        "storeName": "task",
        "enableImmer": true,
        "slices": [
          { "id": "data", "kind": "data", "hasSelectors": true },
          { "id": "ui", "kind": "ui", "hasSelectors": false }
        ]
      }
    }
  ],
  "domain": {
    "entities": [
      {
        "name": "Task",
        "fields": [
          { "name": "id", "type": "string" },
          { "name": "status", "type": "enum", "values": ["TODO", "DOING", "DONE"] },
          { "name": "assignee", "type": "string" },
          { "name": "priority", "type": "enum", "values": ["LOW", "MEDIUM", "HIGH"] },
          { "name": "createdAt", "type": "datetime" },
          { "name": "updatedAt", "type": "datetime" }
        ]
      }
    ],
    "apis": [
      { "name": "listTasks", "path": "/api/tasks", "method": "GET", "returns": "Paginated<Task>" },
      { "name": "getTaskDetail", "path": "/api/tasks/{id}", "method": "GET", "returns": "Task" }
    ]
  },
  "openQuestions": [
    "任务优先级是否影响排序规则？",
    "列表是否需要实时刷新？",
    "是否需要支持批量指派/批量完成？"
  ],
  "autoFill": [
    "根据 Task 字段自动生成列表列配置初稿",
    "根据 listTasks 查询参数自动生成筛选字段"
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/intents/order-management.intent.json">
{
  "id": "order-management",
  "title": "订单管理列表",
  "description": "管理订单的列表 / 搜索 / 快速编辑 / 导出功能",
  "goals": [
    "让运营在单页内完成大部分订单处理动作",
    "支持高频搜索与筛选，减少切页",
    "统一导出能力，避免每个页面重复接入"
  ],
  "scene": {
    "type": "list-page",
    "layout": {
      "regions": [
        { "id": "filters", "label": "筛选区", "role": "filter-bar" },
        { "id": "toolbar", "label": "工具栏", "role": "actions" },
        { "id": "table", "label": "列表", "role": "data-table" }
      ]
    },
    "actors": [
      { "role": "ops", "description": "日常处理订单的运营同学" }
    ],
    "flows": [
      { "from": "进入订单管理页面", "to": "筛选区", "action": "选择状态/日期等筛选条件" },
      { "from": "筛选区", "to": "列表", "action": "根据筛选条件加载订单列表" },
      { "from": "列表", "to": "快速编辑弹层", "action": "点击某行快速编辑按钮" },
      { "from": "快速编辑弹层", "to": "列表", "action": "提交修改并刷新当前页" },
      { "from": "工具栏", "to": "导出任务", "action": "点击导出按钮按当前筛选条件导出" }
    ]
  },
  "runtimeFlows": [
    {
      "id": "exportOrders",
      "trigger": { "element": "toolbar.exportButton", "event": "click" },
      "pipeline": [
        { "call": "FilterService.getCurrentFilters", "as": "filters" },
        { "call": "TableUiStateService.getCurrentState", "as": "tableState" },
        {
          "call": "ExportService.submitExportTask",
          "params": {
            "filters": "{{filters}}",
            "columns": "{{tableState.visibleColumns}}"
          }
        }
      ]
    }
  ],
  "patterns": [
    {
      "id": "table-with-server-filter",
      "target": "table",
      "config": {
        "entity": "Order",
        "pagination": true,
        "batchActions": ["export"]
      }
    },
    {
      "id": "filter-bar",
      "target": "filters",
      "config": {
        "inlineSearch": true,
        "showResetButton": true,
        "fields": ["status", "createdAt"]
      }
    },
    {
      "id": "toolbar-with-quick-edit",
      "target": "toolbar",
      "config": {
        "supportQuickEdit": true,
        "supportExport": true,
        "editableFields": ["remark"]
      }
    }
  ],
  "domain": {
    "entities": [
      {
        "name": "Order",
        "fields": [
          { "name": "id", "type": "string" },
          { "name": "status", "type": "enum", "values": ["PENDING", "PAID", "SHIPPED", "COMPLETED", "CANCELED"] },
          { "name": "createdAt", "type": "datetime" },
          { "name": "updatedAt", "type": "datetime" },
          { "name": "buyerName", "type": "string" },
          { "name": "totalAmount", "type": "number" },
          { "name": "remark", "type": "string" }
        ]
      }
    ],
    "apis": [
      {
        "name": "listOrders",
        "path": "/api/orders",
        "method": "GET",
        "query": [
          { "name": "keyword", "type": "string", "optional": true },
          { "name": "status", "type": "string", "optional": true },
          { "name": "createdAtFrom", "type": "datetime", "optional": true },
          { "name": "createdAtTo", "type": "datetime", "optional": true },
          { "name": "page", "type": "number" },
          { "name": "pageSize", "type": "number" }
        ],
        "returns": "Paginated<Order>"
      },
      {
        "name": "updateOrder",
        "path": "/api/orders/{id}",
        "method": "PATCH",
        "body": [
          { "name": "remark", "type": "string", "optional": true },
          { "name": "status", "type": "string", "optional": true }
        ]
      },
      {
        "name": "exportOrders",
        "path": "/api/orders/export",
        "method": "POST",
        "body": [{ "name": "filters", "type": "object" }]
      }
    ]
  },
  "openQuestions": [
    "导出是否需要限制最大条数？",
    "是否允许在快速编辑中修改订单状态？"
  ],
  "autoFill": [
    "根据 Order 字段自动生成表格列初稿（id/status/createdAt/totalAmount）",
    "根据 listOrders 查询参数自动生成过滤项"
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/filter-bar.pattern.json">
{
  "id": "filter-bar",
  "name": "顶部筛选条",
  "version": "v1",
  "status": "draft",
  "summary": "适用于列表页顶部的筛选区域，支持关键字搜索与多字段过滤。",
  "problem": "在 toB 列表页中，筛选区经常被随意实现，导致交互和布局不统一。filter-bar 模式提供统一的筛选区结构和状态管理约定。",
  "applicability": {
    "goodFor": ["list-page 顶部筛选区域", "需要关键字 + 多字段组合筛选的场景"],
    "badFor": ["只需要单个下拉选择的极简场景", "复杂分步筛选流程"],
    "requiredSceneType": ["list-page"]
  },
  "composition": {
    "roles": [
      {
        "id": "FilterComponent",
        "label": "筛选组件",
        "description": "渲染筛选表单控件并在筛选项变更时触发列表刷新。",
        "requires": ["FilterService"]
      },
      {
        "id": "FilterStore",
        "label": "筛选状态 Store",
        "description": "维护筛选条件的 UI 状态，提供读写接口。",
        "provides": "FilterService"
      }
    ]
  },
  "paramsSchema": {
    "entity": { "type": "string", "required": true },
    "fields": { "type": "array", "item": { "type": "string" } },
    "inlineSearch": { "type": "boolean", "default": true },
    "showResetButton": { "type": "boolean", "default": true }
  },
  "uiSchema": {
    "entity": { "widget": "select", "label": "绑定实体" },
    "fields": { "widget": "multi-select", "label": "筛选字段" },
    "inlineSearch": { "widget": "switch", "label": "启用关键字搜索" },
    "showResetButton": { "widget": "switch", "label": "显示重置按钮" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/service-adapter-query.pattern.json">
{
  "id": "service-adapter-query",
  "name": "服务层 + 适配器 + Query Hook",
  "version": "v1",
  "status": "draft",
  "summary": "统一 service / adapter / TanStack Query Hook 的分层与职责。",
  "composition": {
    "roles": [
      { "id": "ServiceModule", "label": "服务层模块", "description": "封装 HTTP 交互", "provides": "HttpService", "requires": ["HttpClient"] },
      { "id": "AdapterModule", "label": "适配器模块", "description": "负责领域模型转换", "provides": "DomainAdapter" },
      { "id": "QueryKeysModule", "label": "Query Keys 工厂", "description": "输出稳定 queryKey", "provides": "QueryKeysFactory" },
      { "id": "QueryHookModule", "label": "Query Hook", "description": "封装 TanStack Query 行为", "requires": ["HttpService", "DomainAdapter", "QueryKeysFactory"], "provides": "QueryHook" }
    ]
  },
  "paramsSchema": {
    "entity": { "type": "string", "required": true },
    "resourceName": { "type": "string", "required": true },
    "operations": { "type": "array", "item": { "type": "string", "enum": ["list", "detail", "create", "update", "delete"] }, "required": true },
    "hasPagination": { "type": "boolean", "default": false },
    "queryKeyNamespace": { "type": "string" }
  },
  "uiSchema": {
    "entity": { "widget": "text-input", "label": "领域实体名称" },
    "resourceName": { "widget": "text-input", "label": "资源名" },
    "operations": { "widget": "checkbox-group", "label": "支持的操作" },
    "hasPagination": { "widget": "switch", "label": "列表是否分页" },
    "queryKeyNamespace": { "widget": "text-input", "label": "Query Key 命名空间" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/table-with-server-filter.pattern.json">
{
  "id": "table-with-server-filter",
  "name": "服务端筛选表格",
  "version": "v1",
  "status": "draft",
  "summary": "适用于 toB 管理系统中的分页列表场景，通过服务端筛选、分页和批量操作统一实现列表展示与导出能力。",
  "problem": "后台列表重复实现分页/筛选/批量导出造成维护成本，该模式统一结构与服务接口。",
  "applicability": {
    "goodFor": ["大规模数据的后台列表", "需要支持多字段筛选并希望统一导出行为", "服务端分页返回"],
    "badFor": ["仅展示少量静态数据", "强流程型视图", "复杂交互式聚合视图"],
    "requiredSceneType": ["list-page"],
    "preconditions": ["至少定义一个实体", "存在分页列表接口"]
  },
  "composition": {
    "roles": [
      {
        "id": "TableComponent",
        "label": "列表组件",
        "description": "组合 Query Hook、Filter Store、Table Store，负责渲染数据表格和交互。",
        "requires": ["ListQueryService", "TableUiStateService"]
      },
      {
        "id": "ColumnsConfig",
        "label": "列配置",
        "description": "定义列 key/title/sortable，并作为导出字段来源"
      },
      {
        "id": "FilterStore",
        "label": "筛选状态 Store",
        "description": "维护筛选区 UI 状态",
        "provides": "FilterService"
      },
      {
        "id": "TableStore",
        "label": "表格 UI 状态 Store",
        "description": "维护分页/排序/列显隐",
        "provides": "TableUiStateService"
      },
      {
        "id": "ListQueryHook",
        "label": "列表查询 Hook",
        "description": "将 FilterStore 与 TableStore 的状态映射为 HTTP 请求参数",
        "provides": "ListQueryService",
        "requires": ["FilterService", "TableUiStateService"]
      },
      {
        "id": "ExportService",
        "label": "导出服务",
        "description": "根据筛选条件与列配置构造导出载荷并调用导出接口",
        "provides": "ExportService"
      }
    ]
  },
  "dataContract": {
    "requiredEntityFields": ["id", "status"],
    "recommendedEntityFields": ["createdAt", "updatedAt", "totalAmount"],
    "listApi": {
      "requiredQueryParams": ["page", "pageSize"],
      "optionalQueryParams": ["keyword", "status", "createdAtFrom", "createdAtTo"]
    }
  },
  "paramsSchema": {
    "entity": { "type": "string", "required": true },
    "pagination": { "type": "boolean", "default": true },
    "batchActions": {
      "type": "array",
      "item": { "type": "string", "enum": ["export", "bulkUpdate"] }
    },
    "columns": {
      "type": "array",
      "item": {
        "type": "object",
        "fields": {
          "key": { "type": "string", "required": true },
          "title": { "type": "string", "required": true },
          "sortable": { "type": "boolean", "default": false }
        }
      }
    },
    "pageSize": { "type": "number", "default": 20 }
  },
  "uiSchema": {
    "entity": { "widget": "select", "label": "绑定实体" },
    "pagination": { "widget": "switch", "label": "启用分页" },
    "batchActions": { "widget": "checkbox-group", "label": "批量操作" },
    "columns": { "widget": "column-picker", "label": "列配置" },
    "pageSize": { "widget": "number-input", "label": "默认每页条数" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/toolbar-with-quick-edit.pattern.json">
{
  "id": "toolbar-with-quick-edit",
  "name": "工具栏 + 快速编辑",
  "version": "v1",
  "status": "draft",
  "summary": "适用于列表页顶部工具栏，提供快速编辑入口与导出入口的组合模式。",
  "composition": {
    "roles": [
      {
        "id": "ToolbarComponent",
        "label": "工具栏组件",
        "description": "渲染顶部工具栏按钮（导出、快速编辑等），触发对应的交互事件。",
        "requires": ["QuickEditService", "ExportService"]
      },
      {
        "id": "QuickEditComponent",
        "label": "快速编辑组件",
        "description": "展示和提交快速编辑表单",
        "provides": "QuickEditService"
      }
    ]
  },
  "paramsSchema": {
    "supportQuickEdit": { "type": "boolean", "default": true },
    "supportExport": { "type": "boolean", "default": true },
    "entity": { "type": "string" },
    "editableFields": { "type": "array", "item": { "type": "string" } }
  },
  "uiSchema": {
    "supportQuickEdit": { "widget": "switch", "label": "启用快速编辑" },
    "supportExport": { "widget": "switch", "label": "启用导出" },
    "entity": { "widget": "select", "label": "绑定实体" },
    "editableFields": { "widget": "multi-select", "label": "可快速编辑字段" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/workbench-layout.pattern.json">
{
  "id": "workbench-layout",
  "name": "工作台布局",
  "version": "v1",
  "status": "draft",
  "summary": "适用于 toB 系统中的工作台场景，统一顶部指标 + 左列表 + 右详情布局。",
  "composition": {
    "roles": [
      {
        "id": "WorkbenchLayoutComponent",
        "label": "工作台布局组件",
        "description": "负责整体布局，不关心具体业务字段。",
        "provides": "WorkbenchLayoutShell"
      },
      {
        "id": "MetricsComponent",
        "label": "顶部指标组件",
        "description": "渲染关键指标卡"
      },
      {
        "id": "LeftPaneComponent",
        "label": "左侧列表组件",
        "description": "渲染任务列表并处理选中行",
        "requires": ["WorkbenchSelectionService"]
      },
      {
        "id": "RightPaneComponent",
        "label": "右侧详情组件",
        "description": "渲染当前选中任务详情",
        "requires": ["WorkbenchSelectionService"]
      }
    ]
  },
  "paramsSchema": {
    "layoutMode": {
      "type": "string",
      "enum": ["two-column", "three-row"],
      "default": "two-column"
    },
    "leftPanelId": { "type": "string", "required": true },
    "rightPanelId": { "type": "string", "required": true },
    "metricsRegionId": { "type": "string" },
    "responsiveBehavior": {
      "type": "string",
      "enum": ["collapse-right", "collapse-left", "tabs"],
      "default": "collapse-right"
    }
  },
  "uiSchema": {
    "layoutMode": { "widget": "select", "label": "布局模式" },
    "leftPanelId": { "widget": "text-input", "label": "左侧区域" },
    "rightPanelId": { "widget": "text-input", "label": "右侧区域" },
    "metricsRegionId": { "widget": "text-input", "label": "顶部指标" },
    "responsiveBehavior": { "widget": "select", "label": "窄屏行为" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/patterns/zustand-store-with-slices.pattern.json">
{
  "id": "zustand-store-with-slices",
  "name": "Zustand Store + Slice 拆分",
  "version": "v1",
  "status": "draft",
  "summary": "统一使用单一 Store + 多 Slice 的状态管理结构，保持 TanStack Query 职责清晰。",
  "composition": {
    "roles": [
      { "id": "StoreRoot", "label": "Store 聚合根", "description": "定义单一 Store 实例，聚合多个 Slice，暴露类型与 Hook。", "provides": "StoreHook" },
      { "id": "DataSlice", "label": "数据 Slice", "description": "管理某一领域的数据型 UI 状态", "provides": ["DataSliceState", "DataSliceActions"] },
      { "id": "UISlice", "label": "UI Slice", "description": "管理纯 UI 状态", "provides": ["UISliceState", "UISliceActions"] },
      { "id": "SelectorsModule", "label": "Selector 模块", "description": "输出可复用的派生 Selector", "provides": "StoreSelectors" }
    ]
  },
  "paramsSchema": {
    "storeName": { "type": "string", "required": true },
    "enableImmer": { "type": "boolean", "default": true },
    "slices": {
      "type": "array",
      "required": true,
      "item": {
        "type": "object",
        "fields": {
          "id": { "type": "string", "required": true },
          "kind": { "type": "string", "enum": ["data", "ui"], "required": true },
          "hasSelectors": { "type": "boolean", "default": false }
        }
      }
    }
  },
  "uiSchema": {
    "storeName": { "widget": "text-input", "label": "Store 名称前缀" },
    "enableImmer": { "widget": "switch", "label": "启用 immer" },
    "slices": { "widget": "table-editor", "label": "Slice 列表" }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/plans/order-management.plan.json">
{
  "intentId": "order-management",
  "version": "v1",
  "actions": [
    {
      "type": "create-file",
      "path": "src/features/order-management/order-management.page.tsx",
      "template": "list-page-shell",
      "patternId": "list-page",
      "params": {
        "title": "订单管理列表",
        "regions": ["filters", "toolbar", "table"]
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-filters.tsx",
      "template": "filter-bar",
      "patternId": "filter-bar",
      "params": {
        "entity": "Order",
        "fields": ["status", "createdAt"],
        "inlineSearch": true,
        "showResetButton": true
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-table.tsx",
      "template": "table-with-server-filter",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "columns": [
          { "key": "id", "title": "订单号", "sortable": true },
          { "key": "status", "title": "状态" },
          { "key": "createdAt", "title": "下单时间", "sortable": true },
          { "key": "totalAmount", "title": "金额" }
        ],
        "pagination": true,
        "batchActions": ["export"],
        "pageSize": 20
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-toolbar.tsx",
      "template": "toolbar-with-quick-edit",
      "patternId": "toolbar-with-quick-edit",
      "params": {
        "supportQuickEdit": true,
        "supportExport": true
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/components/order-quick-edit.tsx",
      "template": "quick-edit-dialog",
      "patternId": "toolbar-with-quick-edit",
      "params": {
        "entity": "Order",
        "editableFields": ["remark"]
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/stores/filter.slice.ts",
      "template": "filter-store-slice",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "fields": ["status", "createdAt"],
        "initialState": {
          "status": "ALL",
          "createdAtRange": null
        }
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/stores/table.slice.ts",
      "template": "table-store-slice",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "pageSize": 20
      }
    },
    {
      "type": "create-file",
      "path": "src/features/order-management/queries/use-orders-list.hook.ts",
      "template": "list-query-hook",
      "patternId": "table-with-server-filter",
      "params": {
        "entity": "Order",
        "apiName": "listOrders"
      }
    }
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/raw/templates/order-list-feature-skeleton.template.json">
{
  "id": "order-list-feature-skeleton",
  "name": "订单管理列表功能骨架模板",
  "version": "v1",
  "status": "draft",
  "description": "为 table-with-server-filter / filter-bar / toolbar-with-quick-edit 场景生成目录骨架。",
  "runtimeBindings": {
    "uiCapabilities": {
      "table": { "useComponent": "ProTable", "import": "@/components/ProTable" },
      "filterControls": {
        "useComponents": {
          "select": { "import": "@/components/Select" },
          "dateRange": { "import": "@/components/DateRangePicker" },
          "keyword": { "import": "@/components/KeywordInput" }
        }
      }
    }
  },
  "patterns": [
    {
      "patternId": "table-with-server-filter",
      "implements": [
        { "role": "TableComponent", "impl": "react-table-shell", "path": "src/features/__FEATURE__/components/__ENTITY__-table.tsx" },
        { "role": "ColumnsConfig", "impl": "columns-config", "path": "src/features/__FEATURE__/components/__ENTITY__-table.config.ts" },
        { "role": "FilterStore", "impl": "zustand", "path": "src/features/__FEATURE__/stores/filter.slice.ts" },
        { "role": "TableStore", "impl": "zustand", "path": "src/features/__FEATURE__/stores/table.slice.ts" },
        { "role": "ListQueryHook", "impl": "react-query", "path": "src/features/__FEATURE__/queries/use-__ENTITY__-list.hook.ts" },
        { "role": "ExportService", "optional": true, "impl": "http-export", "path": "src/features/__FEATURE__/services/__ENTITY__-export.service.ts" }
      ]
    },
    {
      "patternId": "filter-bar",
      "implements": [
        { "role": "FilterComponent", "impl": "filters-basic", "path": "src/features/__FEATURE__/components/__ENTITY__-filters.tsx" }
      ]
    },
    {
      "patternId": "toolbar-with-quick-edit",
      "implements": [
        { "role": "ToolbarComponent", "impl": "toolbar-basic", "path": "src/features/__FEATURE__/components/__ENTITY__-toolbar.tsx" },
        { "role": "QuickEditComponent", "optional": true, "impl": "quick-edit-dialog", "path": "src/features/__FEATURE__/components/__ENTITY__-quick-edit.tsx" }
      ]
    }
  ],
  "params": {
    "FEATURE": { "desc": "功能目录名（kebab-case，例如 order-management）", "required": true },
    "ENTITY": { "desc": "实体名（PascalCase，例如 Order）", "required": true }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/requirements/index.ts">
import orderExport from './order-export.usecase.json'
import opsWorkbench from './ops-workbench.usecase.json'

export const requirementCases = [orderExport, opsWorkbench]

export type RequirementCase = (typeof requirementCases)[number]
export type RequirementId = RequirementCase['id']
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/requirements/ops-workbench.usecase.json">
{
  "id": "ops-workbench-demand",
  "title": "运营工作台接入任务派发",
  "summary": "需要一个统一工作台来处理指派、状态切换、看板指标。",
  "painPoints": [
    "任务列表与详情分散在多个 tab",
    "没有统一状态管理",
    "新成员很难记住操作路径"
  ],
  "readyIntentId": "ops-workbench",
  "document": "## 背景\n- 运营每天需要处理各类任务（指派、状态更新、SLA 问题）\n- 现状：列表与详情分散在多个 Tab，状态变化没有统一存储\n\n## 目标\n1. 单屏可同时查看任务列表 + 指标 + 当前任务详情\n2. 任务状态切换需有统一 store（支持 undo / redo）\n3. 支持批量指派、批量完成，减少重复操作\n\n## 核心能力\n- workbench 布局（左列表、右详情、顶部指标）\n- 列表通过 table-with-server-filter + service-adapter-query 接入\n- 状态切片以 zustand-store-with-slices 维护选中项与 UI\n",
  "llmSummaryBullets": [
    "工作台布局 + 列表 + 详情 + 指标的经典组合",
    "模式：workbench-layout、table-with-server-filter、zustand-store-with-slices",
    "行为：选中任务后自动同步 WorkbenchSelectionService"
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/requirements/order-export.usecase.json">
{
  "id": "order-export-demand",
  "title": "导出订单列表并批量标记备注",
  "summary": "运营希望在同一个工作台完成订单筛选、导出、快速备注更新，避免来回跳转。",
  "painPoints": [
    "现有 CRM 中的导出入口分散在多个页面",
    "筛选条件无法复用，每次导出都要重新填写",
    "快速备注只能单条提交，效率低"
  ],
  "readyIntentId": "order-management",
  "document": "## 背景\n- 运营日常需要在订单列表上完成筛选、导出、备注维护\n- 当前系统中导出按钮散落在多个子页面，筛选条件无法复用，单条备注效率低\n\n## 目标\n1. 一个页面内完成 80% 订单处理动作\n2. 所有筛选条件可复用（导出沿用同一条件）\n3. 备注支持单行弹层快速修改\n\n## 核心功能\n- 顶部筛选区：状态、时间区间、关键字\n- 列表：分页、列显隐、批量选中\n- 工具栏：导出、快速编辑备注\n- 行为：导出任务应带上当前筛选，快速编辑调用 updateOrder\n",
  "llmSummaryBullets": [
    "识别出“列表 + 筛选 + 导出 + 快速编辑”的典型 BackOffice 场景",
    "适配模式：table-with-server-filter、filter-bar、toolbar-with-quick-edit",
    "运行时 Flow：toolbar.export → FilterService/TableUiStateService → ExportService"
  ]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/data/index.ts">
import orderManagement from './raw/intents/order-management.intent.json'
import opsWorkbench from './raw/intents/ops-workbench.intent.json'
import tablePattern from './raw/patterns/table-with-server-filter.pattern.json'
import filterBarPattern from './raw/patterns/filter-bar.pattern.json'
import toolbarPattern from './raw/patterns/toolbar-with-quick-edit.pattern.json'
import workbenchPattern from './raw/patterns/workbench-layout.pattern.json'
import serviceAdapterPattern from './raw/patterns/service-adapter-query.pattern.json'
import zustandPattern from './raw/patterns/zustand-store-with-slices.pattern.json'
import orderListTemplate from './raw/templates/order-list-feature-skeleton.template.json'
import orderPlan from './raw/plans/order-management.plan.json'
import exportOrdersFlow from './raw/flows/export-orders.flow.ts?raw'

import type {
  IntentSpec,
  PatternSpec,
  PlanSpec,
  TemplateSpec,
} from '../types'

export const intents: IntentSpec[] = [
  orderManagement as IntentSpec,
  opsWorkbench as IntentSpec,
]

export const patterns: PatternSpec[] = [
  tablePattern as PatternSpec,
  filterBarPattern as PatternSpec,
  toolbarPattern as PatternSpec,
  workbenchPattern as PatternSpec,
  serviceAdapterPattern as PatternSpec,
  zustandPattern as PatternSpec,
]

export const patternsById = Object.fromEntries(
  patterns.map((pattern) => [pattern.id, pattern])
)

export const templates: TemplateSpec[] = [orderListTemplate as TemplateSpec]

export const plans: Record<string, PlanSpec> = {
  'order-management': orderPlan as PlanSpec,
}

export const flowSources: Record<string, string> = {
  exportOrders: exportOrdersFlow,
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/hooks/use-plan-simulator.ts">
import { useMemo, useState } from 'react'
import { useMutation } from '@tanstack/react-query'
import { plans } from '../data'
import type { IntentSpec, PlanSpec } from '../types'

const wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

interface GenerateResult {
  plan: PlanSpec
  logs: string[]
}

interface ExecuteResult {
  logs: string[]
}

export function usePlanSimulator(intent: IntentSpec | undefined) {
  const [plan, setPlan] = useState<PlanSpec | undefined>(() =>
    intent ? plans[intent.id] : undefined
  )
  const [logs, setLogs] = useState<string[]>([])

  const appendLogs = (entries: string[]) => {
    setLogs((prev) => [...prev, ...entries])
  }

  const generatePlan = useMutation<GenerateResult, Error, void>({
    mutationFn: async () => {
      if (!intent) throw new Error('No intent selected')
      await wait(420)
      const referencePlan = plans[intent.id]
      const synthesizedPlan: PlanSpec =
        referencePlan ?? ({ intentId: intent.id, version: 'draft', actions: [] } as PlanSpec)
      const newLogs = [
        `[CLI] Loading intent ${intent.id} (${intent.title})`,
        `[CLI] Selecting patterns → ${intent.patterns.map((p) => p.id).join(', ')}`,
        `[CLI] Synthesizing actions (${synthesizedPlan.actions.length})...`,
        '[CLI] Plan ready (dry-run)'
      ]
      return { plan: synthesizedPlan, logs: newLogs }
    },
    onSuccess: ({ plan, logs }) => {
      setPlan(plan)
      appendLogs(logs)
    },
    onError: (error) => {
      appendLogs([`[ERROR] ${error.message}`])
    }
  })

  const executePlan = useMutation<ExecuteResult, Error, void>({
    mutationFn: async () => {
      if (!plan) throw new Error('Please generate plan first')
      await wait(520)
      const actionLogs = plan.actions.map(
        (action, index) =>
          `[${index + 1}/${plan.actions.length}] ${action.type} ${action.path} (${action.template})`
      )
      return {
        logs: [...actionLogs, '[CLI] Execution completed (virtual fs)']
      }
    },
    onSuccess: ({ logs }) => appendLogs(logs),
    onError: (error) => appendLogs([`[ERROR] ${error.message}`])
  })

  const summary = useMemo(() => ({ plan, logs }), [plan, logs])

  return {
    plan: summary.plan,
    logs: summary.logs,
    generatePlan: () => generatePlan.mutate(),
    executePlan: () => executePlan.mutate(),
    isGenerating: generatePlan.isPending,
    isExecuting: executePlan.isPending
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/lib/virtual-file-tree.ts">
import type { PlanSpec } from '../types'

export type FileTree = FileTreeNode[]

export type FileTreeNode =
  | { type: 'dir'; name: string; children: FileTree }
  | { type: 'file'; name: string; meta?: { template?: string; patternId?: string } }

const ensureDir = (children: FileTree, segment: string) => {
  let dir = children.find((child) => child.type === 'dir' && child.name === segment) as
    | FileTreeNode
    | undefined
  if (!dir) {
    dir = { type: 'dir', name: segment, children: [] }
    children.push(dir)
  }
  return dir
}

export function buildFileTree(plan?: PlanSpec): FileTree {
  if (!plan) return []
  const root: FileTree = []

  for (const action of plan.actions) {
    const segments = action.path.split('/')
    let cursor = root

    segments.forEach((segment, index) => {
      const isLast = index === segments.length - 1
      if (isLast) {
        cursor.push({
          type: 'file',
          name: segment,
          meta: { template: action.template, patternId: action.patternId },
        })
      } else {
        const dir = ensureDir(cursor, segment) as { type: 'dir'; name: string; children: FileTree }
        cursor = dir.children
      }
    })
  }

  return root
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/assets.tsx">
import { PlatformAssets } from '../components/platform-assets'

export function AssetsCenter() {
  return (
    <div className="workspace">
      <PlatformAssets />
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/dashboard.tsx">
export function Dashboard() {
  return (
    <div className="workspace">
      <section className="card">
        <h2>Intent-driven IDE</h2>
        <p className="panel-desc">仪表盘：汇总最新意图、Plan Runs、Copilot 动作。</p>
      </section>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/index.tsx">
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import App from '../App'
import { Dashboard } from './dashboard'
import { IntentsList } from './intents-list'
import { IntentCreateRoute } from './intent-create'
import { IntentPage } from './intent-page'
import { PatternsRoute } from './patterns'
import { PatternDetail } from './pattern-detail'
import { PatternCreateRoute } from './pattern-create'
import { PatternEditRoute } from './pattern-edit'
import { PatternRegistryRoute } from './pattern-registry'
import { AssetsCenter } from './assets'

const router = createBrowserRouter([
  {
    path: '/',
    element: <App />, // App renders shell (sidebar + main area) and uses Outlet
    children: [
      { index: true, element: <Dashboard /> },
      { path: 'intents', element: <IntentsList /> },
      { path: 'intents/new', element: <IntentCreateRoute /> },
      { path: 'intents/:intentId', element: <IntentPage /> },
      { path: 'patterns', element: <PatternsRoute /> },
      { path: 'patterns/new', element: <PatternCreateRoute /> },
      { path: 'patterns/:patternId/edit', element: <PatternEditRoute /> },
      { path: 'patterns/:patternId/registry', element: <PatternRegistryRoute /> },
      { path: 'patterns/:patternId', element: <PatternDetail /> },
      { path: 'assets', element: <AssetsCenter /> },
    ],
  },
])

export function AppRouter() {
  return <RouterProvider router={router} />
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/intent-create.tsx">
import { useIntentStore } from '../stores/use-intent-store'
import { PlanSimulationProvider } from '../contexts/plan-simulation-context'
import { RequirementIntake } from '../components/requirement-intake'
import { CopilotBar } from '../components/copilot-bar'
import { RolePanels } from '../components/role-panels'
import { ResultsDock } from '../components/results-dock'
import { PlatformAssets } from '../components/platform-assets'

export function IntentCreateRoute() {
  const intent = useIntentStore((state) => state.drafts[state.selectedIntentId])
  return (
    <PlanSimulationProvider intent={intent}>
      <div className="workspace">
        <RequirementIntake />
        <CopilotBar />
        <RolePanels />
        <PlatformAssets />
        <ResultsDock />
      </div>
    </PlanSimulationProvider>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/intent-detail.tsx">
import { useParams } from 'react-router-dom'
import { useIntentStore } from '../stores/use-intent-store'
import { PipelineShell } from '../components/pipeline-shell'

export function IntentDetail() {
  const params = useParams()
  const selectIntent = useIntentStore((state) => state.selectIntent)
  const intent = useIntentStore((state) => state.drafts[params.intentId ?? ''])

  if (!intent) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">未找到该意图。</div>
        </section>
      </div>
    )
  }

  if (params.intentId) {
    selectIntent(params.intentId)
  }

  return <PipelineShell />
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/intent-page.tsx">
import { useParams } from 'react-router-dom'
import { useIntentStore } from '../stores/use-intent-store'
import { PlanSimulationProvider } from '../contexts/plan-simulation-context'
import { CopilotBar } from '../components/copilot-bar'
import { RolePanels } from '../components/role-panels'
import { ResultsDock } from '../components/results-dock'
import { PlatformAssets } from '../components/platform-assets'

export function IntentPage() {
  const { intentId } = useParams()
  const selectIntent = useIntentStore((state) => state.selectIntent)
  const intent = useIntentStore((state) =>
    intentId ? state.drafts[intentId] : undefined
  )

  if (!intentId) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">请选择一个意图。</div>
        </section>
      </div>
    )
  }

  if (!intent) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">未找到意图 {intentId}。</div>
        </section>
      </div>
    )
  }

  selectIntent(intentId)

  return (
    <PlanSimulationProvider intent={intent}>
      <div className="workspace">
        <CopilotBar />
        <RolePanels />
        <PlatformAssets />
        <ResultsDock />
      </div>
    </PlanSimulationProvider>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/intents-list.tsx">
import { Link } from 'react-router-dom'
import { useIntentStore } from '../stores/use-intent-store'

export function IntentsList() {
  const intents = useIntentStore((state) => state.intents)
  return (
    <div className="workspace">
      <section className="card">
        <div className="badge" style={{ background: '#e0f2fe', color: '#0369a1' }}>Intents</div>
        <h2>意图资产库</h2>
        <p className="panel-desc">列出所有意图草稿与发布状态，演示真实平台的路由入口。</p>
        <ul className="asset-list">
          {intents.map((intent) => (
            <li key={intent.id}>
              <Link to={`/intents/${intent.id}`}>{intent.title}</Link>
              <span>{intent.description}</span>
            </li>
          ))}
        </ul>
      </section>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/pattern-create.tsx">
import { PatternStudio } from '../components/pattern-studio'
import { usePatternStore } from '../stores/use-pattern-store'

export function PatternCreateRoute() {
  const createDraft = usePatternStore((state) => state.createDraft)
  const draft = createDraft()
  return (
    <div className="workspace">
      <PatternStudio patternId={draft.id} />
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/pattern-detail.tsx">
import { useParams } from 'react-router-dom'
import { patternsById } from '../data'

export function PatternDetail() {
  const { patternId } = useParams()
  const pattern = patternId ? patternsById[patternId] : undefined
  if (!pattern) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">未找到该模式。</div>
        </section>
      </div>
    )
  }
  return (
    <div className="workspace">
      <section className="card">
        <div className="badge" style={{ background: '#ecfccb', color: '#4d7c0f' }}>Pattern Detail</div>
        <h2>{pattern.name}</h2>
        <p className="panel-desc">这里展示模式角色、schema、UI 等详情，模拟真实路由。</p>
        <pre className="code-block">{JSON.stringify(pattern, null, 2)}</pre>
      </section>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/pattern-edit.tsx">
import { useParams } from 'react-router-dom'
import { PatternStudio } from '../components/pattern-studio'
import { usePatternStore } from '../stores/use-pattern-store'

export function PatternEditRoute() {
  const { patternId } = useParams()
  const select = usePatternStore((state) => state.selectPattern)

  if (!patternId) {
    return (
      <div className="workspace">
        <section className="card">
          <div className="empty-state">请选择模式。</div>
        </section>
      </div>
    )
  }

  select(patternId)

  return (
    <div className="workspace">
      <PatternStudio patternId={patternId} />
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/pattern-registry.tsx">
import { PatternRegistryView } from '../components/pattern-registry-view'

export function PatternRegistryRoute() {
  return <PatternRegistryView />
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/routes/patterns.tsx">
import { PatternGallery } from '../components/pattern-gallery'
import { Link } from 'react-router-dom'

export function PatternsRoute() {
  return (
    <div className="workspace">
      <section className="card">
        <div className="badge" style={{ background: '#ecfccb', color: '#4d7c0f' }}>Patterns</div>
        <h2>平台模式库</h2>
        <div className="actions-row">
          <Link className="primary-button" to="/patterns/new">
            新建模式
          </Link>
        </div>
        <PatternGallery />
      </section>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/stores/use-intent-store.ts">
import { create } from 'zustand'
import { intents as seedIntents } from '../data'
import type { IntentSpec } from '../types'

const clone = <T>(input: T): T => JSON.parse(JSON.stringify(input))

interface IntentState {
  intents: IntentSpec[]
  drafts: Record<string, IntentSpec>
  selectedIntentId: string
  selectIntent: (id: string) => void
  loadIntentSnapshot: (intent: IntentSpec) => void
  updateIntent: (id: string, patch: Partial<IntentSpec>) => void
}

const initialDrafts = seedIntents.reduce<Record<string, IntentSpec>>((acc, intent) => {
  acc[intent.id] = clone(intent)
  return acc
}, {})

export const useIntentStore = create<IntentState>((set) => ({
  intents: seedIntents,
  drafts: initialDrafts,
  selectedIntentId: '',
  selectIntent: (id) => set({ selectedIntentId: id }),
  loadIntentSnapshot: (intent) =>
    set((state) => {
      const snapshot = clone(intent)
      return {
        ...state,
        drafts: {
          ...state.drafts,
          [snapshot.id]: snapshot,
        },
      }
    }),
  updateIntent: (id, patch) =>
    set((state) => {
      const current = state.drafts[id]
      if (!current) return state
      const next: IntentSpec = { ...current, ...patch }
      return { ...state, drafts: { ...state.drafts, [id]: next } }
    }),
}))
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/stores/use-pattern-store.ts">
import { create } from 'zustand'
import { patterns as seedPatterns } from '../data'
import type { PatternSpec } from '../types'

const clone = <T>(input: T): T => JSON.parse(JSON.stringify(input))

interface PatternState {
  patterns: PatternSpec[]
  drafts: Record<string, PatternSpec>
  selectedPatternId?: string
  selectPattern: (id: string) => void
  createDraft: () => PatternSpec
  updateDraft: (id: string, patch: Partial<PatternSpec>) => void
  saveDraft: (id: string) => void
  publishPattern: (id: string) => void
}

function createEmptyPattern(): PatternSpec {
  return {
    id: `pattern-${Date.now()}`,
    name: '新模式',
    version: 'v0.1.0',
    status: 'draft',
    summary: '模式简介',
    composition: { roles: [] },
    paramsSchema: {},
    uiSchema: {},
  }
}

export const usePatternStore = create<PatternState>((set) => ({
  patterns: seedPatterns,
  drafts: seedPatterns.reduce<Record<string, PatternSpec>>((acc, pattern) => {
    acc[pattern.id] = clone(pattern as PatternSpec)
    return acc
  }, {}),
  selectedPatternId: undefined,
  selectPattern: (id) => set({ selectedPatternId: id }),
  createDraft: () => {
    const draft = createEmptyPattern()
    set((state) => ({
      drafts: { ...state.drafts, [draft.id]: draft },
      selectedPatternId: draft.id,
    }))
    return draft
  },
  updateDraft: (id, patch) =>
    set((state) => {
      const current = state.drafts[id]
      if (!current) return state
      const next = { ...current, ...patch }
      return { ...state, drafts: { ...state.drafts, [id]: next } }
    }),
  saveDraft: (id) =>
    set((state) => {
      const draft = state.drafts[id]
      if (!draft) return state
      const isExisting = state.patterns.some((pattern) => pattern.id === id)
      return {
        ...state,
        patterns: isExisting
          ? state.patterns.map((pattern) => (pattern.id === id ? draft : pattern))
          : [...state.patterns, draft],
      }
    }),
  publishPattern: (id) =>
    set((state) => {
      const target = state.drafts[id] ?? state.patterns.find((pattern) => pattern.id === id)
      if (!target) return state
      const published = { ...target, status: 'published' as const }
      return {
        ...state,
        drafts: { ...state.drafts, [id]: published },
        patterns: state.patterns.some((pattern) => pattern.id === id)
          ? state.patterns.map((pattern) => (pattern.id === id ? published : pattern))
          : [...state.patterns, published],
      }
    }),
}))
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/stores/use-session-store.ts">
import { create } from 'zustand'

interface SessionState {
  hasRequirementInput: boolean
  setHasRequirementInput: (value: boolean) => void
}

export const useSessionStore = create<SessionState>((set) => ({
  hasRequirementInput: false,
  setHasRequirementInput: (value) => set({ hasRequirementInput: value }),
}))
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/styles/global.css">
:root {
  font-family: 'Inter', 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  line-height: 1.5;
  font-weight: 400;
  color: #111827;
  background-color: #f5f5f7;
  --surface: #ffffff;
  --surface-strong: #f2f2f7;
  --surface-muted: #e5e7eb;
  --border: #e2e8f0;
  --border-strong: #d1d5db;
  --text-muted: #6b7280;
  --accent: #2563eb;
  --accent-soft: #dbeafe;
  --accent-strong: #1d4ed8;
  --danger: #b91c1c;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
  background: #f5f5f7;
}

#root {
  min-height: 100vh;
}

.app-root {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.top-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 24px;
  background: #0f172a;
  color: #e2e8f0;
}

.top-nav .brand {
  font-weight: 700;
}

.top-nav nav {
  display: flex;
  gap: 12px;
}

.top-nav nav a {
  color: #cbd5e1;
  text-decoration: none;
  padding: 8px 12px;
  border-radius: 10px;
}

.top-nav nav a.active {
  background: rgba(255, 255, 255, 0.12);
  color: #fff;
}

.app-main {
  flex: 1;
  padding: 24px;
}

.workspace {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

a {
  color: inherit;
}

button,
input,
textarea,
select {
  font: inherit;
}


.app-shell {
  display: grid;
  grid-template-columns: 280px 1fr;
  min-height: 100vh;
  color: #0f172a;
}

.sidebar {
  width: 280px;
  background: #0f172a;
  color: #e2e8f0;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.sidebar h1 {
  font-size: 16px;
  margin: 0;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: #94a3b8;
}

.sidebar .intent-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar button {
  text-align: left;
  border: none;
  border-radius: 10px;
  background: transparent;
  color: inherit;
  padding: 14px 16px;
  cursor: pointer;
  transition: background 0.2s ease;
}

.sidebar button.active {
  background: rgba(255, 255, 255, 0.12);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.main {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 32px;
}


.panels-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 20px;
}


.card {
  background: var(--surface);
  border-radius: 18px;
  padding: 20px;
  border: 1px solid rgba(15, 23, 42, 0.08);
  box-shadow: 0 25px 60px rgba(15, 23, 42, 0.08);
}

.copilot-strip {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
}

.copilot-steps {
  margin-top: 16px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
}

.copilot-step {
  border: 1px solid rgba(15, 23, 42, 0.12);
  border-radius: 16px;
  padding: 16px;
  background: #fff;
}

.copilot-step.done {
  border-color: var(--accent);
  background: var(--accent-soft);
}

.copilot-step-title {
  font-weight: 600;
  margin-bottom: 4px;
}

.copilot-step-desc {
  font-size: 13px;
  color: var(--text-muted);
}

.copilot-step-status {
  margin-top: 12px;
  font-size: 13px;
  color: var(--accent-strong);
}

.role-switcher {
  display: flex;
  gap: 12px;
}

.role-switcher button {
  border: 1px solid rgba(15, 23, 42, 0.1);
  border-radius: 16px;
  padding: 12px 16px;
  background: #fff;
  min-width: 150px;
  text-align: left;
  cursor: pointer;
}

.role-switcher button.active {
  background: #111827;
  color: #fff;
  border-color: #111827;
}

.role-panel {
  margin-top: 24px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

.panel-desc {
  color: var(--text-muted);
  font-size: 14px;
  margin-bottom: 12px;
}

.role-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
}

.empty-state {
  border: 1px dashed var(--border-strong);
  border-radius: 16px;
  padding: 20px;
  text-align: center;
  color: var(--text-muted);
  background: #f8fafc;
  margin-top: 16px;
}

.error-text {
  margin-top: 12px;
  color: var(--danger);
  font-size: 13px;
}

.assets-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.asset-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.asset-list li {
  border: 1px solid rgba(15, 23, 42, 0.08);
  border-radius: 14px;
  padding: 12px;
  background: var(--surface-strong);
}

.asset-list span {
  display: block;
  margin-top: 4px;
  color: var(--text-muted);
  font-size: 12px;
}
.pipeline-grid {
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 24px;
}
.stepper {
  display: flex;
  gap: 16px;
}
.stepper-column {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 18px;
}
.step-card {
  border-radius: 20px;
  border: 1px solid rgba(15, 23, 42, 0.08);
  padding: 18px;
  position: relative;
  background: linear-gradient(145deg, #fff, #f8fafc);
}
.step-card::before {
  content: attr(data-step);
  position: absolute;
  top: -12px;
  left: 16px;
  font-size: 12px;
  letter-spacing: 0.08em;
  padding: 2px 8px;
  border-radius: 999px;
  background: var(--accent);
  color: #fff;
}
.flow-viewer-grid {
  display: grid;
  grid-template-columns: 0.8fr 1.2fr;
  gap: 20px;
}
.file-tree {
  background: #0b1120;
  color: #d1d5db;
  border-radius: 18px;
  padding: 16px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
}
.file-node {
  margin-left: 16px;
}
.file-node::before {
  content: '';
  width: 8px;
  height: 1px;
  background: rgba(148, 163, 184, 0.6);
  display: inline-block;
  margin-right: 8px;
}

.card h2,
.card h3 {
  margin-top: 0;
  margin-bottom: 16px;
}

.tabs {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.tabs button {
  border: none;
  border-radius: 999px;
  padding: 8px 18px;
  background: var(--surface-strong);
  color: var(--text-muted);
  cursor: pointer;
}

.tabs button.active {
  background: #111827;
  color: #f8fafc;
}

.tabs.compact button {
  padding: 6px 12px;
  border-radius: 10px;
  font-size: 13px;
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 16px;
}

.field {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.field label {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}

.field input,
.field textarea,
.field select {
  border-radius: 12px;
  border: 1px solid var(--border);
  padding: 12px 14px;
  background: var(--surface-strong);
  resize: vertical;
}

.pattern-list,
.plan-steps,
.flow-pipeline {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.pattern-card {
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px;
  background: #f9fafb;
}

.pattern-card header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.pattern-card small {
  font-size: 12px;
  color: var(--text-muted);
}

.badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 999px;
  font-size: 11px;
  padding: 2px 10px;
  background: var(--surface-strong);
  color: var(--text-muted);
}

.plan-console {
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 16px;
}

.console-window {
  background: #0f172a;
  color: #f8fafc;
  border-radius: 16px;
  padding: 16px;
  font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, monospace;
  font-size: 13px;
  height: 280px;
  overflow: auto;
}

.console-window h4 {
  margin-top: 0;
  margin-bottom: 12px;
}

.flow-card {
  background: #0b1120;
  color: #e2e8f0;
  border-radius: 16px;
  padding: 20px;
}

.flow-steps {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.flow-step {
  border-left: 3px solid var(--accent);
  padding-left: 12px;
}

.code-block {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  font-size: 12px;
  background: rgba(15, 23, 42, 0.8);
  padding: 16px;
  border-radius: 12px;
  overflow: auto;
}

.actions-row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.primary-button,
.secondary-button {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 10px 18px;
  font-weight: 600;
  cursor: pointer;
}

.primary-button {
  background: var(--accent);
  color: #fff;
}

.secondary-button {
  background: transparent;
  border-color: var(--border-strong);
  color: #111827;
}

.list-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 0;
  padding: 0;
  list-style: none;
}

.list-inline li {
  padding: 4px 10px;
  border-radius: 999px;
  background: var(--surface-muted);
  font-size: 12px;
}

.yaml-preview {
  background: #0f172a;
  color: #e2e8f0;
  border-radius: 16px;
  padding: 12px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  height: 240px;
  overflow: auto;
}

.split-panel {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 16px;
}

.section-label {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  margin-bottom: 8px;
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/types/index.ts">
export interface SceneRegion {
  id: string
  label: string
  role: string
}

export interface SceneLayout {
  regions?: SceneRegion[]
}

export interface SceneFlowEdge {
  from: string
  to: string
  action: string
}

export interface RuntimeFlowStep {
  call: string
  as?: string
  params?: Record<string, unknown>
}

export interface RuntimeFlow {
  id: string
  trigger?: {
    element: string
    event: string
  }
  pipeline: RuntimeFlowStep[]
}

export interface IntentPatternConfig {
  id: string
  target?: string
  config: Record<string, unknown>
}

export interface IntentEntityField {
  name: string
  type: string
  values?: string[]
}

export interface IntentEntity {
  name: string
  fields: IntentEntityField[]
}

export interface IntentApiParam {
  name: string
  type: string
  optional?: boolean
}

export interface IntentApi {
  name: string
  path: string
  method: string
  query?: IntentApiParam[]
  body?: IntentApiParam[]
  returns?: string
}

export interface IntentDomain {
  entities: IntentEntity[]
  apis: IntentApi[]
}

export interface IntentScene {
  type: string
  layout?: SceneLayout
  actors?: { role: string; description: string }[]
  flows?: SceneFlowEdge[]
}

export interface IntentSpec {
  id: string
  title: string
  description: string
  goals: string[]
  scene: IntentScene
  runtimeFlows?: RuntimeFlow[]
  patterns: IntentPatternConfig[]
  domain: IntentDomain
  openQuestions?: string[]
  autoFill?: string[]
}

export interface PatternRole {
  id: string
  label: string
  description: string
  provides?: string | string[]
  requires?: string[]
}

export interface PatternSpec {
  id: string
  name: string
  version: string
  status: string
  summary: string
  composition?: {
    roles: PatternRole[]
  }
  paramsSchema?: Record<string, unknown>
  uiSchema?: Record<string, unknown>
  runtimeBindings?: Record<string, { component?: string; service?: string }>
}

export interface TemplatePatternImpl {
  role: string
  impl: string
  path: string
  optional?: boolean
}

export interface TemplatePatternBinding {
  patternId: string
  implements: TemplatePatternImpl[]
}

export interface TemplateSpec {
  id: string
  name: string
  version: string
  status: string
  description: string
  runtimeBindings?: Record<string, unknown>
  patterns: TemplatePatternBinding[]
  params: Record<string, { desc: string; required?: boolean }>
}

export interface PlanAction {
  type: string
  path: string
  template: string
  patternId: string
  params: Record<string, unknown>
}

export interface PlanSpec {
  intentId: string
  version: string
  actions: PlanAction[]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/App.tsx">
import './styles/global.css'
import { NavLink, Outlet } from 'react-router-dom'

const navLinks = [
  { to: '/', label: 'Dashboard', end: true },
  { to: '/intents', label: 'Intents' },
  { to: '/patterns', label: 'Patterns' },
  { to: '/assets', label: 'Assets' },
]

export default function App() {
  return (
    <div className="app-root">
      <header className="top-nav">
        <div className="brand">Intent Studio</div>
        <nav>
          {navLinks.map((link) => (
            <NavLink
              key={link.to}
              to={link.to}
              end={link.end}
              className={({ isActive }) => (isActive ? 'active' : '')}
            >
              {link.label}
            </NavLink>
          ))}
        </nav>
      </header>
      <main className="app-main">
        <Outlet />
      </main>
    </div>
  )
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { AppRouter } from './routes'

const queryClient = new QueryClient()

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <AppRouter />
    </QueryClientProvider>
  </React.StrictMode>
)
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Intent Studio Prototype</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/package.json">
{
  "name": "intent-studio-prototype",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^4.7.0",
    "typescript": "~5.9.3",
    "vite": "^7.2.2"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.64.1",
    "clsx": "^2.1.1",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.9.6",
    "yaml": "^2.3.4",
    "zustand": "^5.0.8"
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noEmit": true,
    "types": ["node"]
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 4173,
  },
})
</file>

<file path="specs/intent-driven-ai-coding/v1/prd/README.md">
# Intent-driven Platform PRD · Interactive Prototype

该目录承载基于 **Vite + React + Zustand + TanStack Query** 的交互式原型，用真实编码与 mock 数据展示“意图 → 模式 → 模版 → Plan → Flow”全链路：

- `intent-studio-prototype/`：独立 Vite 子项目，可通过 `pnpm install && pnpm dev` 运行；
- 所有数据均来自 `docs/specs/intent-driven-ai-coding/v1` 既有 YAML，转换为 `src/data/raw/*` 下的 JSON/TS；
- UI 包括 Intent Studio、Pattern/Template Gallery、Plan 控制台和 Flow Viewer，支持实时编辑 Intent 元信息并查看行为 Flow 对应的 `.flow.ts` 片段。

运行示例：

```bash
cd docs/specs/intent-driven-ai-coding/v1/prd/intent-studio-prototype
pnpm install
pnpm dev
```

启动后即可看到左侧意图清单、右侧多面板 UI，以及 mock CLI log/Plan JSON 等内容。
</file>

<file path="specs/intent-driven-ai-coding/v1/schema/intent.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://imd.imile-inc.com/schema/intent-driven-ai-coding/intent.schema.json",
  "title": "Intent Asset",
  "type": "object",
  "additionalProperties": true,
  "required": ["id", "title", "scene", "domain"],
  "properties": {
    "id": { "type": "string" },
    "title": { "type": "string" },
    "description": { "type": "string" },
    "version": {
      "type": "string",
      "description": "Intent 版本（与代码/Plan 关联）。"
    },
    "status": {
      "type": "string",
      "description": "draft/prototype/stable/deprecated 等。",
      "enum": ["draft", "prototype", "stable", "deprecated"],
      "default": "draft"
    },
    "goals": {
      "type": "array",
      "items": { "type": "string" }
    },
    "scene": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "description": "场景类型，例如 list-page / workbench / approval / wizard。"
        },
        "layout": {
          "type": "object",
          "properties": {
            "regions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["id"],
                "properties": {
                  "id": { "type": "string" },
                  "label": { "type": "string" },
                  "role": { "type": "string" }
                },
                "additionalProperties": true
              }
            }
          },
          "additionalProperties": true
        },
        "actors": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "role": { "type": "string" },
              "description": { "type": "string" }
            },
            "additionalProperties": true
          }
        },
        "flows": {
          "type": "array",
          "description": "高层业务流描述（与 runtimeFlows 不同）。",
          "items": {
            "type": "object",
            "properties": {
              "from": { "type": "string" },
              "to": { "type": "string" },
              "action": { "type": "string" }
            },
            "additionalProperties": true
          }
        }
      },
      "additionalProperties": true
    },
    "patterns": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": { "type": "string" },
          "target": { "type": "string" },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        },
        "additionalProperties": true
      }
    },
    "domain": {
      "type": "object",
      "required": ["entities"],
      "properties": {
        "entities": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["name", "fields"],
            "properties": {
              "name": { "type": "string" },
              "fields": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["name", "type"],
                  "properties": {
                    "name": { "type": "string" },
                    "type": { "type": "string" }
                  },
                  "additionalProperties": true
                }
              }
            },
            "additionalProperties": true
          }
        },
        "apis": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["name", "path", "method"],
            "properties": {
              "name": { "type": "string" },
              "path": { "type": "string" },
              "method": { "type": "string" },
              "query": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": { "type": "string" },
                    "type": { "type": "string" },
                    "optional": { "type": "boolean" }
                  },
                  "additionalProperties": true
                }
              },
              "body": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": { "type": "string" },
                    "type": { "type": "string" },
                    "optional": { "type": "boolean" }
                  },
                  "additionalProperties": true
                }
              },
              "returns": { "type": "string" }
            },
            "additionalProperties": true
          }
        }
      },
      "additionalProperties": true
    },
    "runtimeFlows": {
      "type": "array",
      "description": "运行时行为流水线（Flow DSL）。",
      "items": {
        "type": "object",
        "required": ["id", "trigger", "pipeline"],
        "properties": {
          "id": { "type": "string" },
          "trigger": {
            "type": "object",
            "properties": {
              "element": { "type": "string" },
              "event": { "type": "string" }
            },
            "additionalProperties": true
          },
          "pipeline": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["call"],
              "properties": {
                "call": { "type": "string" },
                "as": { "type": "string" },
                "params": {
                  "type": "object",
                  "additionalProperties": true
                }
              },
              "additionalProperties": true
            }
          }
        },
        "additionalProperties": true
      }
    },
    "openQuestions": {
      "type": "array",
      "items": { "type": "string" }
    },
    "autoFill": {
      "type": "array",
      "items": { "type": "string" }
    }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/schema/pattern.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://imd.imile-inc.com/schema/intent-driven-ai-coding/pattern.schema.json",
  "title": "Intent-Driven Pattern",
  "type": "object",
  "additionalProperties": true,
  "required": ["id", "name"],
  "properties": {
    "id": {
      "type": "string",
      "description": "模式唯一标识，例如 table-with-server-filter / workbench-layout。"
    },
    "name": {
      "type": "string",
      "description": "人类可读名称。"
    },
    "summary": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "description": "模式定义版本，例如 v1 / 1.0.0。"
    },
    "status": {
      "type": "string",
      "description": "当前状态：draft/prototype/stable/deprecated 等。",
      "enum": ["draft", "prototype", "stable", "deprecated"],
      "default": "draft"
    },
    "changelog": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "模式变更记录的简短条目（可引用外部 ADR）。"
    },
    "problem": {
      "type": "string"
    },
    "applicability": {
      "type": "object",
      "properties": {
        "goodFor": {
          "type": "array",
          "items": { "type": "string" }
        },
        "badFor": {
          "type": "array",
          "items": { "type": "string" }
        },
        "requiredSceneType": {
          "type": "array",
          "items": { "type": "string" }
        },
        "preconditions": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    },
    "composition": {
      "type": "object",
      "properties": {
        "roles": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "label"],
            "properties": {
              "id": { "type": "string" },
              "label": { "type": "string" },
              "description": { "type": "string" },
              "provides": {
                "oneOf": [
                  { "type": "string" },
                  {
                    "type": "array",
                    "items": { "type": "string" }
                  }
                ]
              },
              "requires": {
                "type": "array",
                "items": { "type": "string" }
              }
            },
            "additionalProperties": true
          }
        }
      },
      "additionalProperties": true
    },
    "dataContract": {
      "type": "object",
      "description": "模式期望的实体字段和接口形态约束。",
      "additionalProperties": true
    },
    "paramsSchema": {
      "type": "object",
      "description": "该模式在具体意图下需要配置的参数集合定义。",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "type": { "type": "string" },
          "required": { "type": "boolean" },
          "default": {},
          "enum": {
            "type": "array",
            "items": {}
          },
          "desc": { "type": "string" }
        },
        "additionalProperties": true
      }
    },
    "uiSchema": {
      "type": "object",
      "description": "在平台 UI 中呈现 params 的表单配置（控件类型、标签、选项来源等）。",
      "additionalProperties": true
    },
    "capabilities": {
      "type": "array",
      "description": "该模式依赖或提供的能力标签（例如 table.pagination、filter.inlineSearch）。",
      "items": { "type": "string" }
    },
    "securityRequirements": {
      "type": "object",
      "description": "安全相关要求说明，例如权限检查、审计等。",
      "additionalProperties": true
    },
    "performanceContract": {
      "type": "object",
      "description": "性能相关约定（数据量级、响应时间预算等）。",
      "additionalProperties": true
    },
    "i18n": {
      "type": "object",
      "description": "国际化相关约定（文案位置、命名空间等）。",
      "additionalProperties": true
    },
    "accessibility": {
      "type": "object",
      "description": "可访问性要求（键盘操作、ARIA 标签等）。",
      "additionalProperties": true
    },
    "qualityGates": {
      "type": "object",
      "description": "测试/监控等质量门禁的建议。",
      "additionalProperties": true
    },
    "techPrerequisites": {
      "type": "array",
      "description": "使用该模式前需要满足的技术前提（库/架构约定等）。",
      "items": { "type": "string" }
    },
    "servicesProvided": {
      "type": "array",
      "description": "该模式在行为层提供的 Service ID 列表（用于 Flow DSL 与 Effect 绑定）。",
      "items": { "type": "string" }
    },
    "servicesRequired": {
      "type": "array",
      "description": "该模式依赖的 Service ID 列表。",
      "items": { "type": "string" }
    }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/schema/plan.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://imd.imile-inc.com/schema/intent-driven-ai-coding/plan.schema.json",
  "title": "Generation Plan",
  "type": "object",
  "additionalProperties": true,
  "required": ["intentId", "actions"],
  "properties": {
    "intentId": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "description": "Plan 版本，与 Intent / Pattern / Template 版本对应。",
      "default": "v1"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "preview", "applied"],
      "default": "draft"
    },
    "actions": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["type", "path", "patternId"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["create-file", "update-file", "delete-file"]
          },
          "path": { "type": "string" },
          "template": {
            "type": "string",
            "description": "模板 ID（兼容旧字段）。"
          },
          "templateId": {
            "type": "string",
            "description": "模板 ID（推荐字段名）。"
          },
          "patternId": { "type": "string" },
          "params": {
            "type": "object",
            "additionalProperties": true
          }
        },
        "additionalProperties": true
      }
    }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/schema/README.md">
---
title: Intent/Pattern/Template/Plan Schema 与校验
status: draft
version: v1
---

> 本目录下的 JSON Schema 描述了 v1 版本中 Intent / Pattern / Template / Plan 的“硬骨架”。  
> 目标是：让 YAML/JSON 资产可以被工具和 LLM 严格解析、校验和演进，而不是依赖隐含约定。

## 1. Schema 文件一览

- `pattern.schema.json`
  - 约束 Pattern 定义的结构（id/name/summary/applicability/composition.roles/paramsSchema/uiSchema 等）；
  - 预留了 version/status/changelog/capabilities/servicesProvided/servicesRequired 等字段；
  - 示例对应文件：`../patterns/table-with-server-filter.pattern.yaml` 等。
- `intent.schema.json`
  - 约束 Intent 资产的结构（id/title/scene/patterns/domain/runtimeFlows 等）；
  - 支持 scene.layout/actors/flows/domain.entities/apis；
  - 示例对应文件：`../intents/order-management.intent.yaml`、`../intents/ops-workbench.intent.yaml` 等。
- `template.schema.json`
  - 约束 Template Meta 的结构（id/name/description/runtimeBindings/patterns/params 等）；
  - 示例对应文件：`../templates/order-list-feature-skeleton.template.yaml`、`../templates/workbench-feature-skeleton.template.yaml`。
- `plan.schema.json`
  - 约束 Generation Plan 的结构（intentId/version/status/actions[] 等）；
  - 示例对应文件：`../plans/order-management.plan.json` 以及 PoC 执行时生成的 Plan 对象。

## 2. 约定与演进策略

- Schema 以 draft-07 为基础，约束“必须有的字段”和关键结构形状；
- 为未来演进预留了大量可选字段（如 status/changelog/capabilities/securityRequirements 等）：
  - 初期标记为可选（不破坏现有 YAML）；
  - 后续可在平台成熟后按需提升为必填。
- 所有 Schema 均允许 `additionalProperties: true`，以适应 PoC 阶段的动态试验字段；
  - 对于真正要长期保留的字段，应同步补充到 Schema 中，避免“幽灵字段”。

## 3. 校验策略（规划）

短期（PoC 阶段）：

- PoC CLI / 脚本可以只在开发者主动执行时调用 Schema 校验（例如通过 Ajv 等库）；
- 将校验脚本封装为一个简单命令，例如：
  - `node scripts/validate-intent-schemas.mjs`
  - `node scripts/validate-pattern-schemas.mjs`

中期（平台 UI 出现后）：

- Intent Studio / Pattern Studio / Template 编辑器在保存前必须通过 Schema 校验；
- YAML 预览仅作为“权威视图”，但不允许绕过 Schema 往里写不合法字段；
- CLI 的 `imd intent plan` / `imd intent apply` 在执行前也应校验相关文件。

长期：

- 当 Pattern/Template/Plan 引入 version/status/changelog 等字段后，
  可基于 Schema 进一步检查兼容性（例如 Plan 引用的 patternId@version 是否存在）。

## 4. 与其它文档的关系

- `01-overview.md` / `02-patterns-and-intents.md`：
  - 解释 Intent/Pattern 的语义与分层；
  - 本目录的 Schema 则是它们在文件中的物理形态约束。
- `04-platform-design.md` / `06-platform-ui-and-interactions.md`：
  - 描述平台 UI 工作流（Intent Studio / Pattern Studio / Plans）；
  - Schema 是这些 UI 表单的后端契约。
- `08-flow-dsl-and-ast.md` / `services.md`：
  - 描述 Flow DSL / AST 与 Service ID；
  - Intent Schema 中的 `runtimeFlows` 与 Pattern Schema 中的 `servicesProvided/servicesRequired` 将与之对齐。

在 v1 中，Schema 的主要目标是“把骨架定下来”，  
后续可以围绕这些 Schema 渐进实现 CLI 校验、UI 表单约束和版本兼容检查。
</file>

<file path="specs/intent-driven-ai-coding/v1/schema/template.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://imd.imile-inc.com/schema/intent-driven-ai-coding/template.schema.json",
  "title": "Template Meta",
  "type": "object",
  "additionalProperties": true,
  "required": ["id"],
  "properties": {
    "id": {
      "type": "string",
      "description": "模板 ID。"
    },
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "version": {
      "type": "string"
    },
    "status": {
      "type": "string",
      "enum": ["draft", "prototype", "stable", "deprecated"],
      "default": "draft"
    },
    "runtimeBindings": {
      "type": "object",
      "description": "将 uiCapabilities 映射到具体组件实现的配置。",
      "additionalProperties": true
    },
    "patterns": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["patternId", "implements"],
        "properties": {
          "patternId": { "type": "string" },
          "implements": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["role", "impl", "path"],
              "properties": {
                "role": { "type": "string" },
                "impl": { "type": "string" },
                "path": { "type": "string" },
                "optional": { "type": "boolean" }
              },
              "additionalProperties": true
            }
          }
        },
        "additionalProperties": true
      }
    },
    "params": {
      "type": "object",
      "description": "模板级参数定义（例如 FEATURE/ENTITY 等），用于 Plan→CodeGen。",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "desc": { "type": "string" },
          "required": { "type": "boolean" },
          "default": {}
        },
        "additionalProperties": true
      }
    }
  }
}
</file>

<file path="specs/intent-driven-ai-coding/v1/templates/order-list-feature-skeleton.template.yaml">
id: order-list-feature-skeleton
name: 订单管理列表功能骨架模板
version: v1
status: draft
description: >
  在 React + 状态管理栈下，为基于 table-with-server-filter / filter-bar /
  toolbar-with-quick-edit 模式的订单管理列表功能生成目录骨架和核心组件/Store/Hook。

runtimeBindings:
  uiCapabilities:
    table:
      useComponent: ProTable
      import: "@/components/ProTable"
    filterControls:
      useComponents:
        select:
          import: "@/components/Select"
        dateRange:
          import: "@/components/DateRangePicker"
        keyword:
          import: "@/components/KeywordInput"

patterns:
  - patternId: table-with-server-filter
    implements:
      - role: TableComponent
        impl: react-table-shell
        path: src/features/__FEATURE__/components/__ENTITY__-table.tsx
      - role: ColumnsConfig
        impl: columns-config
        path: src/features/__FEATURE__/components/__ENTITY__-table.config.ts
      - role: FilterStore
        impl: zustand
        path: src/features/__FEATURE__/stores/filter.slice.ts
      - role: TableStore
        impl: zustand
        path: src/features/__FEATURE__/stores/table.slice.ts
      - role: ListQueryHook
        impl: react-query
        path: src/features/__FEATURE__/queries/use-__ENTITY__-list.hook.ts
      - role: ExportService
        optional: true
        impl: http-export
        path: src/features/__FEATURE__/services/__ENTITY__-export.service.ts
  - patternId: filter-bar
    implements:
      - role: FilterComponent
        impl: filters-basic
        path: src/features/__FEATURE__/components/__ENTITY__-filters.tsx
  - patternId: toolbar-with-quick-edit
    implements:
      - role: ToolbarComponent
        impl: toolbar-basic
        path: src/features/__FEATURE__/components/__ENTITY__-toolbar.tsx
      - role: QuickEditComponent
        optional: true
        impl: quick-edit-dialog
        path: src/features/__FEATURE__/components/__ENTITY__-quick-edit.tsx

params:
  FEATURE:
    desc: 功能目录名（kebab-case，例如 order-management）
    required: true
  ENTITY:
    desc: 实体名（PascalCase，例如 Order）
    required: true
</file>

<file path="specs/intent-driven-ai-coding/v1/templates/workbench-feature-skeleton.template.yaml">
id: workbench-feature-skeleton
name: 工作台特性骨架模板
version: v1
status: draft
description: >
  在 React + 状态管理栈下，为基于 workbench-layout / table-with-server-filter /
  service-adapter-query / zustand-store-with-slices 等模式的运营工作台场景生成目录骨架和核心组件/Store/Hook。

runtimeBindings:
  uiCapabilities:
    table:
      useComponent: ProTable
      import: "@/components/ProTable"
    layout:
      workbench:
        useComponent: WorkbenchLayout
        import: "@/components/WorkbenchLayout"

patterns:
  - patternId: workbench-layout
    implements:
      - role: WorkbenchLayoutComponent
        impl: react-workbench-shell
        path: src/features/__FEATURE__/pages/__ENTITY__-workbench.page.tsx
      - role: MetricsComponent
        impl: metrics-basic
        path: src/features/__FEATURE__/components/__ENTITY__-metrics.tsx
      - role: LeftPaneComponent
        impl: tasks-list-slot
        path: src/features/__FEATURE__/components/__ENTITY__-tasks-list.slot.tsx
      - role: RightPaneComponent
        impl: task-detail-slot
        path: src/features/__FEATURE__/components/__ENTITY__-task-detail.slot.tsx
  - patternId: table-with-server-filter
    implements:
      - role: TableComponent
        impl: react-table-shell
        path: src/features/__FEATURE__/components/__ENTITY__-tasks-table.tsx
      - role: ColumnsConfig
        impl: columns-config
        path: src/features/__FEATURE__/components/__ENTITY__-tasks-table.config.ts
      - role: FilterStore
        impl: zustand
        path: src/features/__FEATURE__/stores/tasks-filter.slice.ts
      - role: TableStore
        impl: zustand
        path: src/features/__FEATURE__/stores/tasks-table.slice.ts
      - role: ListQueryHook
        impl: react-query
        path: src/features/__FEATURE__/queries/use-__ENTITY__-tasks-list.hook.ts
      - role: ExportService
        optional: true
        impl: http-export
        path: src/features/__FEATURE__/services/__ENTITY__-tasks-export.service.ts
  - patternId: service-adapter-query
    implements:
      - role: ServiceModule
        impl: http-service
        path: src/features/__FEATURE__/services/__ENTITY__-task.service.ts
      - role: AdapterModule
        impl: domain-adapter
        path: src/features/__FEATURE__/adapters/__ENTITY__-task.adapter.ts
      - role: QueryKeysModule
        impl: query-keys
        path: src/features/__FEATURE__/queries/__ENTITY__-task.query-keys.ts
      - role: QueryHookModule
        impl: react-query
        path: src/features/__FEATURE__/queries/use-__ENTITY__-task-detail.hook.tsx
  - patternId: zustand-store-with-slices
    implements:
      - role: StoreRoot
        impl: zustand-main-store
        path: src/features/__FEATURE__/stores/__ENTITY__-task.store.ts
      - role: DataSlice
        impl: zustand-data-slice
        path: src/features/__FEATURE__/stores/__ENTITY__-task-data.slice.ts
      - role: UISlice
        impl: zustand-ui-slice
        path: src/features/__FEATURE__/stores/__ENTITY__-task-ui.slice.ts

params:
  FEATURE:
    desc: 功能目录名（kebab-case，例如 ops-workbench）
    required: true
  ENTITY:
    desc: 实体名（PascalCase，例如 Task）
    required: true
</file>

<file path="specs/intent-driven-ai-coding/v1/01-overview.md">
---
title: 意图驱动的声明式 AI 编码体系 · 总览
status: draft
version: v1
---

> 本文给出一套**可独立理解**的高层方案，用来描述：在以 toB 管理系统为主的前端团队中，如何围绕「意图 → 模式 → 模板」组织 AI 辅助编码与出码前工具。

## 0. 背景与原始诉求（精简版）

这一套规划并不是为了一般意义上的“低代码平台”，而是基于以下前提：

- **LLM 优先**：如果没有今天这样的 LLM，仅靠 Intent/Pattern/Template/YAML 只是在给人类增加负担；
  真正的目标是：让 LLM 在面对未知需求时，有一套结构化的“跑道”可以沿着 Intent → Pattern → Plan → Flow/Effect 稳定工作。
- **意图为起点**：开发者面对新场景时，理想方式是只需要把需求讲清楚（自然语言），在平台的帮助下把它变成结构化 Intent，
  后续的模式选择、Plan 生成、行为编排和代码骨架落地尽量由 LLM + 内核协作完成。
- **IMD / best-practice 是养分，不是圣经**：现有 IMD 仓库和 best-practice 仓库提供的是组件库、文件/状态规范和代码片段，
  它们是平台实现 Intent/Pattern/Flow 的“供体”，可以随着意图体系的成熟被调整或升级（包括在行为层逐步引入 Effect/Flow）。
- **行为层要有自己的 SSoT**：Zustand + TanStack Query 已经很好地承载了“状态”和“缓存”，
  但对于跨 Store/跨 Service 的行为（导出、审批、批量任务等），我们希望通过 Flow DSL + Effect 程序 + `.flow.ts` 文件
  建立一个独立的“行为层事实来源”，便于平台和 LLM 长期维护、解释与重构。

在这个背景下，本体系的唯一“神圣不可侵犯”的东西，不是某个具体库或规范仓库，而是：  
**能在真实工程里持续提供提效价值的、以意图为中心的人机协同开发流水线。**

## 1. 要解决的核心问题

在典型的 AI 辅助编码实践中，常见问题包括：

- 开发者的真实意图（业务目标、交互需求、场景结构）散落在脑子、需求文档和对话里，很难成为可复用资产。
- 模板和脚手架变成“高级复制粘贴”：只负责铺代码，不说明“适用什么场景、为什么这样写”。
- AI 频繁被当做“生成一段代码”的工具，而不是和开发者一起维护设计决策图的同伴。

目标是：

> 让「意图」在整个开发过程里成为一等公民，  
> 让「模式库」沉淀可复用的编码套路，  
> 让「模板」只是模式在具体技术栈下的实现，  
> AI 和工具都围绕这三者工作，而不是反过来。

## 2. 意图层级（L0–L4）

为了避免一上来就掉进实现细节，我们把信息分成五个层级：

- **L0：目标与约束（Why）**
  - 业务目标、性能/安全/合规等非功能约束。
  - 例：“提升运营处理效率 30%”“必须支持 1440 + 窄屏”“沿用现有权限体系”。
- **L1：场景结构（What – 场景视角）**
  - 页面类型、用户流程、主要入口/出口。
  - 例：“任务工作台：左侧任务列表 + 右侧详情”“三步向导表单”。
- **L2：模式（What – 设计/编码视角）**
  - 可跨多个业务场景复用的交互/编码模式。
  - 例：“列表 + 详情模式”“分页表格 + 服务器过滤”“工作台布局（左 tabs + 指标 + 右详情）”。
- **L3：领域与数据契约（What – 领域视角）**
  - 实体与字段、状态机、接口形态。
  - 例：“Task 含 id/status/assignee…；列表接口返回分页结构”；“状态从待处理 → 处理中 → 已完成”。
- **L4：实现与技术约束（How – 实现视角）**
 - 技术栈、框架、组件库、状态管理、代码组织方式。
  - 例：“React + 某组件库 + 某状态库；列表用通用 Table 组件封装”。

约定：

- 意图资产至少覆盖 L1–L3，尽量带关键 L0 信息。
- 模板/代码主要在 L4，但必须声明“自己是为哪些 L2 模式服务”的。

## 2.x 当前默认落地环境（说明）

本规划在设计时尽量保持与具体技术栈解耦，但在当前阶段，我们主要服务于团队内部的这套组合环境：

- IMD 组件库仓库：`/Users/yoyo/projj/git.imile.com/ux/imd`
- best-practice 规范与片段仓库：`/Users/yoyo/projj/git.imile.com/ux/best-practice`

这两者提供了：

- UI 组件与注册表（IMD）
- 文件类型与目录约定、状态管理与组件设计规范
- 服务层 / 适配器 / Query / 测试等代码片段与 LLM 模板（best-practice）

需要强调的是：

- Intent / Pattern / Template / Plan 仍然是本体系的核心抽象，尽量保持“实现无关”；
- IMD 与 best-practice 是当前阶段的默认实现土壤和养分，而不是高于 Intent 的“终极规范源”；
- 当实现方式或技术栈在未来演进时，优先调整的是“如何在新环境下承接这些 Intent/Pattern”，而不是推翻 Intent 本身。

## 3. 三个一等公民：意图 / 模式 / 模板

在这套体系中，一切围绕三个概念展开：

1. **意图（Intent）**
   - 某个功能或模块“想要达成什么效果”的结构化表达。
   - 包含：目标、场景结构、所选模式、关键数据契约。
2. **模式（Pattern）**
   - 一段可复用的“编码思路 + 最佳实践 + 反模式”。
   - 描述“某类交互/需求在不同业务下应该怎么写”，刻意不带具体业务名词或文件路径。
3. **模板（Template）**
   - 在具体技术栈中对一个或多个模式的实现。
   - 负责落盘代码、配置、测试，是对模式的“物理实现”。

高层关系可以概括为：

```text
意图（Intent） → 选择/组合模式（Pattern） → 选择/组合模板（Template） → 生成/演进代码
```

需要强调的是：上述三者都**站在现有技术栈与组件库之上**工作，而不是替代它们。更完整的视角是：

```text
设计系统 & 组件库  ←  模式运行时实现  ←  模板/Plan  ←  模式/意图
```

- 设计系统 & 基础组件：提供表格、表单、布局、弹层等可复用 UI 能力。
- 模式：规定在这些能力之上如何拆分“代码角色”（例如 TableComponent / FilterStore / ListQueryHook 等），以及推荐的组织方式。
- 模板：在具体工程中，把模式定义的角色映射为实际组件/文件和目录结构。
- 意图：描述业务需求选择哪些模式，并为这些模式提供实体/接口/配置等参数。

## 4. 出码前 vs 运行时

在以 toB 管理系统为主的前端团队中，我们刻意区分：

- **出码前（类似低代码）世界**
  - 意图资产：对功能/场景的结构化描述。
  - 模式库：可复用的编码模式说明及约束。
  - 模板元数据：模板实现了哪些模式、需要哪些参数、有哪些变体。
  - 出码计划：基于意图+模式+模板推导出的“生成/修改文件计划”。
  - 工具与平台：意图编辑器、模式库管理界面、生成控制台、CLI 等。
- **出码后（运行时）世界**
  - 生成出来的页面、组件、Hook、Store 等业务代码。
  - 通用运行时库：表格/表单/状态/权限/错误处理等。
  - 模式的 UI/逻辑实现：标准工作台布局、列表+详情容器等。

约束：

- 出码前所有决策应尽量沉淀为意图资产 + 模式选择 + 出码计划；
- 出码前的平台内核可以使用 Effect/DI 等技术栈实现（详见 `05-effect-ts-integration.md`），
  但出码后的业务项目仍采用常规 React/TS 栈，不强制使用同样的内核技术；
- 运行时代码可以局部偏离，但重大变更建议回写到意图层。

## 5. 角色与分工（聚焦 toB 管理后台团队）

在本方案的默认假设下，**平台的直接使用者是前端开发**。产品/运营等需求方通过文档、会议等形式提供输入，由前端在平台中整理为意图资产。  
角色大致分为三类（其中“产品”角色目前由前端暂代）：

- **前端业务开发**
  - 兼任“产品（前端暂代）”角色，负责：
    - 基于外部需求输入，描述业务目标（L0）、场景结构（L1）、关键业务流程；
    - 在意图工作台中创建和维护意图草稿，与 AI 一起澄清需求与约束；
    - 选择和配置模式（L2）、补全领域与数据契约（L3）；
    - 审阅并确认出码计划，触发生成/更新代码。
- **前端架构师 / 平台前端**
  - 负责：
    - 维护模式库、模板清单及其参数契约、生成规则；
    - 定义“什么场景可以自动生成、什么场景必须手写”的边界；
    - 审阅关键 Intent / Pattern / Template 变更，保证整体一致性。
- **产品角色（概念上的）**
  - 在成熟阶段，可由真正的产品/运营同学参与：
    - 在平台中参与或驱动 L0/L1 的意图录入；
    - 与前端一起在 Intent 层做权衡和确认。
  - 在过渡阶段，由前端业务开发代为履行。
- **AI 代理（平台的一部分）**
  - 负责：引导意图结构化、推荐模式、自动填充部分模板参数、给出解释与风险提示；
  - 不直接做最终决策，所有重要决策需体现在 Intent/Pattern/Plan 等结构化资产中。

## 6. 后续文档结构

本 v1 版本下的其他文档从不同角度展开：

- `02-patterns-and-intents.md`  
  详细定义模式库与意图资产的结构，给出示例和约束。
- `03-pre-code-vs-runtime.md`  
  明确哪些概念/资产属于出码前，哪些属于运行时，并结合 toB 管理系统做分类。
- `04-platform-design.md`  
  描述“意图/模式工作台”的形态：有哪些工作区、角色如何在其中协作、交付物如何流转。
- `05-effect-ts-integration.md`  
  讨论平台内核如何利用函数式 Effect/DI 框架承载能力抽象与生成管线（面向平台实现开发者，可选阅读）。
</file>

<file path="specs/intent-driven-ai-coding/v1/02-patterns-and-intents.md">
---
title: 模式库与意图资产
status: draft
version: v1
---

> 本文深入定义「模式库（Pattern Library）」与「意图资产（Intent Asset）」，并说明它们在 toB 管理系统场景中的结构与关系。

## 1. 模式（Pattern）是什么？

### 1.1 定义

一个模式是这样一块东西：

- 来自业务开发的反复经验：某类交互/需求，在不同场景下编码思路高度相似；
- 背后有一套相对稳定的结构和最佳实践，可以在多个模块中复用；
- 可以清晰地说出“适用场景”和“反模式”，而不是模糊的“感觉差不多”。

因此，一个模式至少包含三部分：

1. **问题场景**
   - 这一类问题在业务里长什么样？
   - 有哪些典型使用场景？（例如“运营工作台”，“订单管理列表 + 详情”等）
2. **推荐结构与编码思路**
   - 推荐的 UI 结构 / 状态拆分 / 数据流 / 依赖关系。
   - 如何拆组件、如何设计 Store、如何管理副作用等。
3. **最佳实践与反模式**
   - 应该怎样写：清晰的约束和建议。
   - 不该怎样写：常见错误用法及其后果。

### 1.2 模式 vs 组件 vs 模板

- **组件**
  - 关注“元素级”复用：按钮、表单项、图表等。
  - 通常只解决 UI 层的一小块问题。
- **模板**
  - 关注“一次性生成一套骨架”：一个页面、一组文件、一段基础逻辑。
  - 强烈依赖具体技术栈与目录结构。
- **模式**
  - 关注“如何把组件、状态和数据组织成一个可复用的解决方案”。
  - 一套模式可以对应多个不同技术栈/项目中的不同模板实现。

模式位于组件之上、模板之下，是整个体系的“中枢抽象”。

## 2. 模式库（Pattern Library）

### 2.1 内容结构

对每个模式，建议用结构化文档维护（YAML 或 Markdown+Frontmatter），至少包括：

- `id`：模式唯一标识，如 `workbench-layout`、`list-detail`。
- `name`：人类可读名称，如“工作台布局”“列表 + 详情”。
- `problem`：要解决的典型问题描述。
- `applicability`：
  - 适用场景：在哪些业务/页面下适用；
  - 不适用场景：在哪些情况应该避免使用。
- `composition`：组成部分：
  - 需要哪些 UI 区块（列表、详情、工具栏、指标卡等）；
  - 需要哪些状态和数据流（过滤条件、分页状态、选中项等）。
- `dataContract`：抽象的数据约定：
  - 必须具备的实体/字段类型；
  - 接口形态（例如“支持分页 + 排序 + 筛选”的列表接口）。
- `bestPractices`：推荐用法。
- `antiPatterns`：反模式与常见坑。

在 UI 层面，模式还需要对底层组件库提出**能力约束**，而不是直接绑定某个具体组件名。可通过 `uiCapabilities` 字段表达，例如：

- 列表模式可能声明自己需要：
  - `table` 能力：支持分页、服务端筛选、列排序、列显隐等；
  - `filterControls` 能力：支持下拉选择、日期区间、关键字搜索等。
- 具体使用哪一个表格/表单组件由模板阶段和项目配置决定，模式只描述“我要什么”，不描述“用谁来做”。


为了支撑模板层与生成管线，模式在沉淀期还应补充：

- `composition.roles`：实现该模式时所需的“代码角色”列表：
  - 每个角色描述一个逻辑部件的职责边界（例如 TableComponent、FilterStore、ListQueryHook 等）；
  - 不直接绑定文件路径或具体技术栈，只说明“需要有这样一块东西”。
- `paramsSchema`：该模式在具体场景下需要向前端“询问”的参数集合（结构化 Schema）。
- `uiSchema`（可选但推荐）：如何将这些参数在平台 UI 中呈现为表单/控件：
  - 使用什么控件（select、checkbox-group、column-picker 等）；
  - 选项从何而来（例如从 Intent 的实体字段列表推导）。

这三项构成了“模式沉淀期的最低交付物”：  
在不写任何模板代码之前，团队已经就**部件拆分、参数契约和配置方式**达成共识。

角色分工（推荐）：

- 前端架构师 / 平台前端：主责创建和维护模式文档、定义角色、参数 Schema 与 UI 能力约束；
- 前端业务开发：参与补充“问题场景、适用性、反模式”等一线经验，使用模式但不直接维护模式定义；
- 产品（前端暂代）：在有条件时参与 problem/applicability 文本的校正和补充。

### 2.2 在 toB 管理系统中的典型模式

示例（非穷举）：

- `list-page`：列表页壳模式，统一“筛选区 + 工具栏 + 列表区”的页面布局（定义示例见 `patterns/list-page.pattern.yaml`）。
- `list-detail`：列表 + 详情模式。
- `workbench-layout`：左侧任务/列表 + 右侧详情 + 顶部指标卡。
- `table-with-server-filter`：分页表格 + 服务端筛选 + 批量操作（完整定义示例见 `patterns/table-with-server-filter.pattern.yaml`）。
- `wizard-form`：多步向导表单。
- `approval-flow`：审批流页面（待办+已办+详情+操作历史）。

这些模式都可以跨“订单、工单、用户、配置”等不同业务实体复用。

约定示例（信息权威）：

- 对于“筛选字段”的选择，本方案约定：
  - `filter-bar` 模式的 `fields` 参数作为权威来源；
  - 其他依赖筛选信息的模式（例如 `table-with-server-filter`）应从 `filter-bar` 配置推导，而不再单独声明一套筛选字段。
  - 这样可以避免在多个模式中重复声明同一组字段，减少意图资产中的歧义与冲突。

## 3. 意图资产（Intent Asset）

### 3.1 定义

意图资产是对“这个功能到底想要做什么”的结构化记录，至少要回答：

- 这个功能/页面的目标和成功标准是什么？
- 参与者是谁？用户在页面上做什么？
- 选用了哪些模式？每个模式作用于哪个子区域？
- 涉及哪些领域实体和接口？

它既是 AI 和工具的输入，也是人类讨论、评审和回顾的基础。

角色分工（推荐）：

- 前端业务开发：主责创建和维护具体功能的 Intent（含 L0–L3），在没有专职产品时兼任产品角色；
- 前端架构师：在关键/高风险场景下 review Intent，确保与整体架构和模式库契合；
- 产品（前端暂代）：在成熟阶段可直接参与 Intent 的 L0/L1 部分（目标与场景结构）的录入与确认。

#### 3.4 行为流（runtimeFlows，进阶）

在部分复杂场景中，除了静态的页面结构和模式选择，还需要对“按钮点击后发生什么”进行更精确、可编排的描述。  
为此，可选地在 Intent 中使用 `runtimeFlows` 字段，以声明式 DSL 的形式描述行为流水线。例如：

```yaml
runtimeFlows:
  - id: exportOrders
    trigger:
      element: toolbar.exportButton
      event: click
    pipeline:
      - call: FilterService.getCurrentFilters
        as: filters
      - call: TableUiStateService.getCurrentState
        as: tableState
      - call: ExportService.submitExportTask
        params:
          filters: "{{filters}}"
          columns: "{{tableState.visibleColumns}}"
```

要点：

- `call` 前缀部分（例如 `FilterService`、`ExportService`）对应 Pattern 中 `provides/requires` 声明的 Service ID（详见 `services.md`）；
- `as` 将调用结果写入临时上下文变量；
- 后续步骤可以通过 `{{变量名}}` 从上下文中取值；
- 当前阶段 `runtimeFlows` 主要用于表达和文档，未来可演进为生成可执行工作流（例如 Effect 程序）的数据源。

术语提示：

- **`runtimeFlows`**：Intent 中用于描述“运行时行为流水线”的字段，是行为层的声明式 DSL，专门回答“按钮点击后要依次调用哪些 Service、如何传递中间结果”。  
  结构定义与示例见本节和 `08-flow-dsl-and-ast.md`。
- **`Env`（环境）**：在 `Effect<Env, E, A>` 这类类型中，`Env` 表示“这段行为执行时可用的全部依赖集合”，
  例如 FilterService/TableUiStateService/ExportService 等服务接口的组合（出码前场景则是 FileSystem/CodeGen/Logger 等）。  
  Flow DSL 对应的 Effect 程序会通过 `Env` 注入这些服务，具体说明见 `05-effect-ts-integration.md` 与 `services.md`。

### 3.2 结构示例（toB 工作台场景）

示例 YAML（简化版）：

```yaml
id: ops-workbench
title: 运营工作台
description: 统一处理运营任务的桌面工作台

goals:
  - 提升任务处理效率 30%
  - 支持 1440px 桌面 + 窄屏折叠

scene:
  type: workbench
  actors:
    - role: operator
      description: 日常处理任务的运营人员
  flows:
    - from: "待处理列表"
      to: "详情面板"
      action: "开始处理任务"
    - from: "详情面板"
      to: "待处理列表"
      action: "完成任务后返回"

patterns:
  - id: workbench-layout
    config:
      leftPanel: tasks-list
      rightPanel: task-detail
  - id: table-with-server-filter
    target: tasks-list
    config:
      pagination: true
      batchActions: [assign, complete]

domain:
  entities:
    - name: Task
      fields:
        - id: string
        - status: enum[TODO, DOING, DONE]
        - assignee: string
        - priority: enum[LOW, MEDIUM, HIGH]
  apis:
    - name: listTasks
      path: /api/tasks
      method: GET
      returns: Paginated<Task>
    - name: getTaskDetail
      path: /api/tasks/{id}
      method: GET
      returns: Task

openQuestions:
  - "任务优先级是否影响排序规则？"
  - "列表是否需要实时刷新？"

autoFill:
  - "根据 Task 字段自动生成列表列配置初稿"
```

要点：

- `patterns` 显式引用模式库中的模式 ID，并对每个模式给出配置。
- `domain` 只描述必要的实体和接口，避免深度侵入业务实现细节。
- `openQuestions` 和 `autoFill` 显示“空白”与“可由 AI 补全”的位置。

### 3.3 约束与最佳实践

- 意图资产应对人类可读，不只是机器用的配置。
- 重大结构变更（例如模式替换、实体重构）应先落在意图资产，再通过生成工具推到代码。
- 意图资产应纳入版本控制，并与代码版本建立关联（例如在提交信息中引用意图 ID）。

## 4. 模式与意图的关系

### 4.1 从意图到模式

- 意图资产中 L1/L3 信息（场景结构 + 领域数据）构成模式选择的基础。
- 工具或 AI 可以根据这些信息：
  - 推荐适用模式（如场景包含“列表+详情”，则推荐 `list-detail`）；
  - 提示不适用模式（例如“数据流不支持分页，暂不能使用分页表格模式”）。

### 4.2 从模式到意图

- 模式定义中可以声明：要应用该模式，需要意图中具备哪些字段/结构。
- 工具可以根据模式 schema 自动生成意图草稿片段：
  - 例如插入一段标准的 `flows` 或 `domain.entities` 模板，提示开发者补全。

### 4.3 一致性与演进

- 当模式演进（增加约束或变体）时：
  - 不应直接在代码里“悄悄改实现”，而是先更新模式文档；
  - 再根据模式更新意图资产，再生成或 refactor 代码。
- 当发现多个意图在“绕着同一类问题打补丁”时：
  - 说明需要上升一个新模式，或扩展已有模式；
  - 模式库是长期沉淀业务经验的地方，而不是单个项目的私有知识。

## 附录 A：与 best-practice 仓库的对齐（可选）

本节仅说明当前团队在 best-practice 仓库中的推荐落地方式，帮助阅读者把抽象的 Pattern 角色与具体代码文件对上号。它属于实现层实践，不是 Pattern 定义本身的硬约束。

参考文档：

- 文件类型与命名规范：`/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/05-file-conventions.md`
- 状态管理标准（Zustand / TanStack Query）：`/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/06-state-management.md`
- 组件设计规范：`/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/07-component-design.md`
- 接口集成开发指南：`/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/03-api-integration-guide.md`
- 适配器模式指引：`/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/11-adapter-pattern-guide.md`

### A.1 典型角色到文件类型的映射示例

以 `table-with-server-filter` 等列表类模式为例，常见角色与 best-practice 文件类型之间的推荐对应关系为：

- `FilterStore` / `TableStore`（筛选状态、表格 UI 状态）
  - 推荐落地为：
    - 聚合 Store：`*.store.ts`（如 `features/order/stores/order.store.ts`）
    - 领域 slice：`*.slice.ts`（如 `features/order/stores/slices/filter.slice.ts`）
  - 依据：`*.store.ts` / `*.slice.ts` 作为 Zustand 状态与行为的基本粒子。

- `ListQueryHook`（列表查询 Hook）
  - 推荐落地为：
    - TanStack Query Hook：`*.hook.tsx`，位于 `features/[domain]/queries/` 目录，例如 `features/order/queries/use-order-list.hook.tsx`。
  - 依据：best-practice 要求服务端缓存统一由 TanStack Query 承担。

- `ExportService`（导出服务）
  - 推荐落地为：
    - 原始 HTTP 通信：`*.service.ts`，如 `features/order/services/order.service.ts`；
    - 数据结构转换：`*.adapter.ts`，如 `features/order/adapters/order.adapter.ts`。
  - 依据：服务层只管 IO，结构转换集中在 adapter，避免污染领域模型。

- `ColumnsConfig`（列配置与静态 UI 配置）
  - 推荐落地为：
    - 组件静态配置：`*.config.tsx`，如 `features/order/components/order-table.config.tsx`。
  - 依据：大体量的表格列配置与表单字段配置集中在 `.config.tsx`，方便复用与测试。

这些映射的原则是：

- Pattern 只定义“需要哪些角色 / 能力”；
- 具体落到哪种文件类型、目录与命名方式，由当前的实现规范来约束（目前主要参考 best-practice 仓库）；
- 当实现规范演进时，可以在不改变 Pattern 定义的前提下，更新这类“角色 → 文件类型”的对齐规则。
</file>

<file path="specs/intent-driven-ai-coding/v1/03-pre-code-vs-runtime.md">
---
title: 出码前 vs 运行时 · 概念与资产划分
status: draft
version: v1
---

> 本文聚焦 toB 管理系统前端团队，明确意图驱动体系中哪些概念和资产属于「出码前」（类似低代码阶段），哪些属于「出码后」运行时。

## 1. 为什么要刻意区分？

如果不区分出码前/出码后，很容易出现两个极端：

- 要么把所有东西都塞进“低代码平台”，最后所有人都绕着平台写 hack；
- 要么完全放弃平台，只拿 AI 当自动补全，意图和模式停留在 PPT 上。

我们希望：

- 出码前：集中在**表达意图、选择模式、制定生成计划**；
- 出码后：集中在**在约束内写好业务逻辑与 UI**；
- 平台和 AI 在中间做可靠的“翻译和执行”。

## 2. 出码前资产（Pre-code Assets）

出码前资产主要是“设计与规划层”的东西，通常不会直接进入生产运行时。

> 当前团队的出码前资产，主要落地在 IMD 仓库 `/Users/yoyo/projj/git.imile.com/ux/imd` 与 best-practice 仓库 `/Users/yoyo/projj/git.imile.com/ux/best-practice` 的组合环境中：前者提供组件库与注册表结构，后者提供文件/状态/服务层的实践规范与代码片段。但它们都是本规划的输入与实现载体，真正的抽象核心仍然是 Intent / Pattern / Template Meta / Plan。

### 2.1 意图资产（Intent）

- 描述业务目标、场景结构、所选模式、领域契约；
- 形式：`*.intent.yaml` + 说明文档；
- 读/写：产品、前端、AI 共同参与；
- 用途：
  - 作为生成/重构的入口；
  - 作为需求与实现之间的桥梁。

### 2.2 模式定义（Pattern）

- 描述可复用的编码模式及其约束；
- 形式：`*.pattern.yaml`/`*.pattern.md`；
- 读/写：架构/平台前端为主，业务前端阅读和选择；
- 用途：
  - 提供模式选型依据；
  - 指导模板实现和代码评审。

### 2.3 模板元数据（Template Meta）

- 描述模板实现了哪些模式、需要哪些参数、有哪些变体；
- 不含具体代码，只含契约；
- 形式：`*.template.yaml`；
- 读/写：模板作者、平台前端；
- 用途：
  - 帮工具把意图/模式参数映射到具体模板；
  - 帮 AI 了解“可以自动填哪些、必须人工选哪些”。

### 2.4 生成计划（Generation Plan）

- 从意图 + 模式 + 模板推导出的“出码计划”；
- 形式：`*.plan.json`；
- 内容包含：
  - 将创建/更新/删除哪些文件；
  - 每个文件来源于哪个模板/模式；
  - 参数/插槽的具体值；
  - 执行顺序、依赖关系；
- 读/写：
  - 由平台/工具生成；
  - 由业务前端审阅、裁剪、确认。

### 2.5 执行日志与映射（Execution Log & Mapping）

- 记录每次执行计划时的具体行为和结果；
- 形式：结构化日志 + “意图/模式/模板 ↔ 代码”的映射表；
- 用途：
  - 追溯一段代码是如何生成的；
  - 反向导航：从代码跳回对应意图和模式；
  - 支持 AI 做“解释”和“重构建议”。

## 3. 出码后资产（Runtime Assets）

出码后资产是在浏览器/前端运行时真正被加载执行的东西。

### 3.1 业务页面与组件

- 生成/手写的页面组件、表单组件、图表组件等；
- 格式：实际的 `*.tsx` / `*.vue` / 其他前端文件；
- 读/写：
  - 业务前端维护；
  - 平台侧工具可能执行“增量修改”，但不应随意覆盖。

### 3.2 公共运行时库

- 表格组件、表单框架、状态管理封装、权限控制、错误边界等；
- 由平台/架构提供和维护；
- 模式通常会基于这些库来实现行为一致性。

### 3.3 模式的运行时实现

- 标准工作台布局组件、列表+详情容器、审批流容器等；
- 这些可以看作是“模式在运行时的物理形态”；
- 模板生成的代码通常会组合使用这些组件/Hook。

### 3.4 运行时流程内核（可选）

- 某些跨页面、跨组件的复杂流程（例如导入导出、批量任务执行）可以有一个小的“流程内核”；
- 内部可以使用更复杂的技术（例如函数式 Effect/DI 框架），对外用简单 API 或 Hook 封装。

## 4. 角色在出码前/出码后各做什么？

> 默认假设：平台的直接用户是前端开发。产品/运营等需求方通过其他渠道提供输入，但不直接在平台中操作。

### 4.1 业务前端（兼任产品角色）

- 出码前：
  - 基于外部需求输入创建和维护意图草稿；
  - 补全意图资产中的模式/领域信息；
  - 审阅生成计划，决定哪些部分自动生成、哪些部分手写；
  - 触发生成/更新代码。
- 出码后：
  - 在生成的代码基础上做业务特化；
  - 当变更涉及结构/模式层时，推动回写意图资产。

### 4.3 平台 / 架构前端

- 出码前：
  - 维护模式库和模板元数据；
  - 把“常犯错的写法”抽象成模式层的约束，而不是埋在评审口头意见里；
  - 迭代生成引擎和校验规则。
- 出码后：
  - 维护公共运行时库和模式实现；
  - 为业务团队提供“从代码返回意图/模式”的导航工具。

### 4.4 AI 代理

- 出码前：
  - 辅助意图结构化、模式匹配、参数填充；
  - 在计划生成前做一致性和缺失检查；
  - 用自然语言解释“为什么推荐某模式/模板”。
- 出码后：
  - 结合映射信息，解释某段代码背后的意图与模式；
  - 为小规模改动提议：是直接在代码里改，还是先改意图再生成。

## 5. 与 toB 管理系统场景的契合点

在 toB 管理后台里，这种划分尤其重要：

- 场景稳定但需求变化频繁：  
  很多页面本质上是“列表+详情”“工作台”“审批流”的变种，适合用模式+意图统一管理。
- 团队成员角色分明：  
  产品/前端/架构划分清晰，有利于把意图编辑、模式维护、模板实现分角色落地。
- 长期演进：  
  管理后台通常长期存在，意图与模式的沉淀可以显著降低后续迭代成本。

因此，把“意图/模式/模板/计划”视为**出码前资产**，把“页面/组件/运行时库”视为**出码后资产**，是整个体系落地的关键前提。
</file>

<file path="specs/intent-driven-ai-coding/v1/04-platform-design.md">
---
title: 意图 / 模式工作台 · 平台设计
status: draft
version: v1
---

> 本文描述一个面向 toB 管理系统前端团队的「意图 / 模式工作台」应如何运作：有哪些工作区、每个角色在其中做什么、交付物如何定义与流转。

## 1. 平台一句话定位

> 这是一个专门承载「需求 → 意图 → 模式选择 → 出码计划」的工作台，  
> 不替代 IDE，也不直接面向终端用户，而是服务于前端团队的设计与出码前阶段。

其职责是：

- 接住需求文档和口头沟通；
- 引导团队用结构化方式整理意图；
- 基于模式库进行模式选择和配置；
- 计算并展示“出码计划”，最终驱动代码生成/更新。

补充说明：

- 平台默认对接的是 IMD 仓库 `/Users/yoyo/projj/git.imile.com/ux/imd` 与 best-practice 仓库 `/Users/yoyo/projj/git.imile.com/ux/best-practice` 提供的组件、规范与代码片段；
- 这些仓库提供的是当前阶段的最佳实践与实现素材，而不是高于 Intent / Pattern / Plan 的终极真理；
- 一条 Intent → Pattern → Template → Plan 流水线是否被长期采纳，取决于它在真实项目中的提效效果和稳定性反馈；
- 当发现某条规则、模板或片段在实践中“负收益”时，允许在平台内替换或降级它，而无需推翻上层 Intent/Pattern 资产。

## 2. 三个核心工作区

### 2.1 意图工作台（Intent Studio）

面向：业务前端 / AI。

职责：

- 以“场景”为单位创建和编辑意图资产；
- 支持自然语言 + 结构化表单组合的输入方式；
- 帮助用户从 L0/L1/L3 角度讲清楚这个场景。

关键能力：

- 意图草稿管理：
  - 创建 `feature-id.intent.yaml`；
  - 维护状态：`draft` / `ready-for-pattern` / `ready-for-plan` 等。
- 结构化引导：
  - 引导填写目标（goals）、场景（scene）、领域实体（domain）等；
  - 利用 schema 做基本校验。
- AI 辅助：
  - 提问和澄清不完整的描述；
  - 根据已有内容给出“类似场景”的参考；
  - 帮忙把散文式描述转成结构化字段。

### 2.2 模式库管理（Pattern Studio）

面向：平台 / 架构前端，业务前端/AI 阅读。

职责：

- 把团队认同的“通用编码套路”沉淀为模式文档；
- 提供模式的浏览、搜索、比对、适用性提示；
- 把“经验”从口头花絮变成可索引的知识资产。

关键能力：

- 模式列表与详情：
  - 展示每个模式的适用场景、组成部分、最佳实践与反模式；
  - 支持示意图和代码片段示例。
- 模式与意图的匹配：
  - 对当前意图评估模式适配度；
  - 提示“缺少哪些信息无法判断适配性”；
  - 支持开发者手工绑定/解绑模式。
- 模式版本管理：
  - 支持模式演进（增加约束、拆分模式等）；
  - 标记哪些旧意图仍引用旧版本模式，提示是否迁移。

### 2.3 生成控制台（Generation Console）

面向：业务前端 / 平台 / AI。

职责：

- 把意图 + 模式组合转换为一份具体的“出码计划”；
- 可视化地展示计划对代码库的影响；
- 触发并监控生成/更新过程。

关键能力：

- 计划生成：
  - 根据意图和已绑定模式，选择合适模板；
  - 生成 `feature-id.plan.json`；
  - 标注每一步需要的参数和目前的填充状态。
- 计划可视化：
  - 列出将创建/更新/删除的文件及路径；
  - 展示模板来源、模式来源；
  - 对 AI 生成的参数/slot 提供“编辑和修正”界面。
- 执行与回滚：
  - 执行计划，将更改应用到代码仓库；
  - 记录执行日志和“意图/模式/模板 ↔ 代码”的映射；
  - 提供回滚或重放某个计划的能力（至少记录差异）。

## 3. 中间交付物及生命周期

### 3.1 Intent Spec（意图说明）

- 产生：在意图工作台中，由业务前端（兼任产品角色）+AI 基于外部需求输入协作创建；
- 内容：goals, scene, patterns, domain, openQuestions, autoFill 等；
- 生命周期：
  - 初稿 → 模式匹配 → 生成计划 → 标记“已落地某版本”；
  - 后续变更时优先修改 Intent，再重新生成或迁移。

### 3.2 Pattern Spec（模式定义）

- 产生：在模式库管理中，由前端架构师 / 平台前端撰写；
- 内容：problem、applicability、composition、dataContract、bestPractices、antiPatterns 等；
- 生命周期：
  - 被多个 Intent 引用；
  - 演进时需评估对已有 Intent 的影响，必要时提供迁移指南。

### 3.3 Template Meta（模板元数据）

- 产生：由前端架构师 / 平台前端在平台中维护；
- 内容：
  - patternId、variant、参数列表、slot 定义、依赖约束；
  - 对应模式角色的文件路径模式（`implements.roles`）；
  - 针对模式声明的 `uiCapabilities`，在当前项目中绑定到具体组件的 `runtimeBindings`
    （例如 table 能力绑定到某个 ProTable 组件，filterControls 能力绑定到一组表单控件）。
- 生命周期：
  - 被生成控制台用来从模式映射到具体模板；
  - 模板演进时更新元数据，以便工具捕获不兼容变更。

### 3.4 Generation Plan（出码计划）

- 产生：生成控制台根据 Intent + Pattern + Template 推导；
- 内容：
  - 目标文件及改动类型；
  - 来源模式/模板；
  - 参数/slot 的具体值；
  - 执行顺序和依赖关系；
- 生命周期：
  - 由平台生成器根据 Intent/Pattern/Template Meta 自动生成；
  - 由业务前端审阅和调整（选择执行/跳过部分 action）；
  - 执行后连同日志一起归档，可用来对比不同 Intent 版本之间的差异。

### 3.5 Execution Log & Mapping（执行日志与映射）

- 产生：执行计划时自动记录；
- 内容：
  - 每一步操作的结果（成功/失败/跳过）；
  - 对代码文件的具体 diff；
  - 某段代码与 Intent/Pattern/Template 的对应关系；
- 生命周期：
  - 由平台在执行 Plan 时自动生成；
  - 被前端业务开发与前端架构师用于追溯、调试和重构；
  - 支持从代码导航回 Intent/Pattern，支持 AI 解释“这段代码为什么长这样”，并为后续自动迁移/重构提供依据。

## 4. 一次“新工作台”从无到有的示例流程

以 toB 场景中一个“运营工作台”为例：

1. **产品在意图工作台起草**
   - 新建 `ops-workbench` 意图；
   - 填写目标（提高效率、支持窄屏等）、角色（operator）、主要流程；
   - AI 提问澄清未说明的部分（例如是否需要批量操作）。
2. **业务前端补全意图与模式选择**
   - 补充 Task 实体、接口草案、状态机；
   - 在模式库中选择：
     - `workbench-layout`（左任务+右详情+指标）；
     - `table-with-server-filter`（列表部分）。
   - 配置模式参数（例如使用分页、启用批量完成）。
3. **生成控制台生成并展示 Plan**
   - 系统选出适配的模板（布局模板、表格模板等）；
   - 生成 Plan，列出将创建/更新的文件与参数；
   - AI 用 Task 字段自动生成列配置初稿，前端在 UI 中微调。
4. **执行 Plan，生成代码**
   - 一键执行，生成工作台页面骨架及相关组件；
   - 记录执行日志与 Intent/Pattern/Template ↔ 代码的映射。
5. **业务前端微调 & 回写意图**
   - 在生成的代码上添加业务特例逻辑；
   - 如有结构性变更（新增 tab、重构指标区），回到意图工作台更新 Intent；
   - 根据新 Intent 再次生成/迁移，避免长期偏离。

## 5. 平台设计的关键原则

- **意图优先**：没有清晰的 Intent，就不允许进入模式选择和生成环节。
- **模式显性化**：开发者明确知道自己选择了哪个模式，而不是“某个模板偷偷做了很多事”。
- **模板退居二线**：模板是实现模式的手段，而不是业务讨论的对象。
- **交付物可版本化**：Intent/Pattern/Template Meta/Plan/Log 都应可追踪、可 diff。
- **AI 辅助而非主导**：AI 负责补全、解释、提示；真正的决策记录在 Intent 与 Pattern 中。

## 6. 技术架构草案（POC 视角）

> 本节从“只给前端团队用”的前提出发，给出一个可以落地的最小可行技术架构，方便做 PoC。

### 6.1 边界与部署形态

最小版本可以是：

- 一个运行在本地仓库根目录的 **Node 服务 / CLI**：
  - 负责读写意图/模式/模板/计划文件；
  - 对外暴露一组 HTTP API 或直接提供 CLI 子命令。
- 一个前端单页应用（SPA）：
  - 运行在浏览器中，供前端开发者使用；
  - 通过 API 或本地桥接与 Node 服务通信。

简化边界：

- 平台只需要访问：
  - 代码仓库的文件系统；
  - （可选）本地 Git，用于查询 diff 和提交信息；
  - （可选）LLM 接口，用于 AI 辅助。
- 不直接依赖生产运行时环境（后端服务、数据库等），避免耦合。

### 6.2 数据模型与存储约定

为方便落地，可约定以下最小目录结构（仅示例，具体路径可调整）：

- 意图资产：`intents/<feature-id>.intent.yaml`
- 模式定义：`patterns/<pattern-id>.pattern.yaml`
- 模板元数据：`templates/<template-id>.template.yaml`
- 出码计划：`.plans/<feature-id>.plan.json`
- 执行日志与映射：`.plans/logs/<feature-id>/<timestamp>.log.json`

其中：

- 文件格式统一使用 YAML/JSON + 明确的 Schema，方便校验和 AI 消化；
- 所有文件纳入 Git 管理，作为长期资产；
- 生成器执行时：
  - 从 `intents/` 读取 Intent；
  - 从 `patterns/` 读取 Pattern；
  - 从 `templates/` 读取 Template Meta；
  - 生成 `.plans/` 下的 Plan，再按 Plan 对业务代码目录进行变更。

### 6.3 典型请求链路（从“编辑 Intent”到“执行 Plan”）

以“新建工作台场景”为例，链路可以细化为：

1. **编辑 Intent**
   - 前端在 SPA 中打开 `ops-workbench` 场景：
     - 若文件不存在，平台调用 Node 服务创建空的 `intents/ops-workbench.intent.yaml`。
     - UI 提供表单（目标、场景结构、实体与接口等），可在右侧展示原始 YAML 视图。
   - 前端修改字段 → 前端通过 API 把完整 Intent 对象 POST 回 Node 服务 → 服务校验 Schema 后写盘。

2. **模式匹配与绑定**
   - 前端点击“推荐模式”按钮：
     - SPA 调用 API：`POST /patterns/match`，传入当前 Intent 摘要；
     - Node 服务调用模式匹配逻辑（可引入 AI）返回候选模式列表及匹配度；
     - 前端展示候选模式列表，允许勾选并配置模式参数；
     - 选择结果写回 Intent 的 `patterns` 字段。

3. **生成 Plan**
   - 前端点击“生成计划”：
     - 调用 API：`POST /plans/generate?intentId=ops-workbench`；
     - Node 服务读取 Intent + Patterns + Template Meta，构建 Plan：
       - 选择模板；
       - 计算将生成/更新的文件列表；
       - 识别所需参数/slot 并尝试自动填充。
     - Plan 持久化到 `.plans/ops-workbench.plan.json`，并返回给前端。
   - 前端用“变更预览”组件展示 Plan：
     - 比如文件树 + 操作类型（新增/修改）；
     - 单个文件的预览 diff（可选，基于 dry-run 生成）。

4. **审阅与执行**
   - 前端在 UI 中：
     - 可禁用某些计划项（只生成骨架，不生成测试/文档等）；
     - 手动调整 AI 生成的参数/slot 内容。
   - 点击“执行计划”：
     - 调用 API：`POST /plans/execute?intentId=ops-workbench`；
     - Node 服务按 Plan 对仓库文件进行修改：
       - 写文件、应用模板、做文本 patch；
       - 记录每步操作结果和 diff。
     - 写入执行日志与映射文件。

5. **后续导航与回滚**
   - SPA 可以：
     - 在查看代码文件时，通过映射信息跳回对应 Intent/Pattern/Template；
     - 在 Plan 历史中对比不同版本的 Plan 和执行日志；
     - 提供“重放某个 Plan”或“撤销本次 Plan 所有变更”的操作（结合 Git）。

### 6.4 有效性保障：为什么不是“又一个看起来很美的工具”？

要让这套平台“真的有效”，关键是让**每一步交互都减少实际工作量**：

- 编辑 Intent：比直接写文档更结构化，可被后续工具/AI 利用；
- 选择模式：比每次从零设计页面架构省脑子，减少踩坑；
- 生成 Plan：提前看到改动范围，减少“生成完才知道改多大”；
- 执行 Plan：把重复性的目录/文件/骨架操作交给工具做，前端专注于业务代码；
- 映射与日志：解决“代码为什么是这样”的追溯问题，让后续人/AI 都有依据。

如果某一步“只增加负担，不减轻负担”，那它的交互和实现就需要被删减或重做，而不是继续往上叠抽象。

## 7. 模式沉淀期与模板阶段的关系（补充）

在平台落地时应刻意区分两个阶段：

1. **模式沉淀阶段**
   - 目标：把“套路”沉淀出来，而不是立刻绑死具体模板或技术栈。
   - 输出：
     - Pattern 文档：问题场景、适用性、组成部分、数据约定、最佳实践/反模式。
     - Implementation Profile：在 `composition.roles` 中声明该模式所需“代码角色”（组件/Store/Hook 等）的职责边界。
     - `paramsSchema` + `uiSchema`：该模式在具体场景下需要向前端“询问”的参数集合，以及这些参数在平台 UI 中应如何呈现。
   - 不做：
     - 不在模式里写死文件路径或状态管理库；
     - 不要求模式定义阶段就已经有完整模板实现。

2. **模板与出码阶段**
  - 目标：在具体技术栈下，为模式的各个“角色”提供模板实现，并生成出码计划。
  - 输出：
    - Template Meta：声明 `patternId`，并通过 `implements.roles` 将抽象角色映射到具体文件路径模式；
    - Generation Plan：基于 Intent + Pattern + Template Meta 推导出的具体文件操作列表。

这样，平台可以先在“模式沉淀期”就支撑意图编辑与模式配置（哪怕暂时没有模板），  
再在“模板阶段”逐步补齐不同技术栈下的模板实现，避免“一开始就卡在所有模板没写完”的状态。

## 8. Plan 执行链路与 LLM 介入点（概览）

以单个 `create-file` 类型的 action 为例（例如生成 `use-orders-list.hook.ts`），整个链路可以拆分为两个阶段：

### 8.1 规划阶段：从 Intent / Pattern / Template Meta 到 Plan

1. 读取 Intent：
   - 从 `intents/<id>.intent.yaml` 解析出场景、模式绑定、领域实体与接口。
2. 匹配模式与角色：
   - 根据 Intent 中绑定的模式 ID（如 `table-with-server-filter`），在模式定义中找到对应角色（如 `ListQueryHook`）。
3. 解析模板 Meta：
   - 在 Template Meta 中查找声明实现了该模式角色的模板（例如 `list-query-hook` 对应某个文件路径模式）。
4. 推导路径与参数：
   - 根据模板路径模式 + Intent（featureId/entity）计算出目标文件路径；
   - 根据模式的 `paramsSchema` + Intent（domain.entities/apis、patterns.config）推导出 `params`（例如 `entity=Order`、`apiName=listOrders`）。
5. 写入 Plan：
   - 将上述信息固化为一条 action：
     - `type` / `path` / `template` / `patternId` / `params`。

LLM 在此阶段可以参与：

- 帮助从 Intent 的自然语言描述中推导/补全结构化字段（例如猜测哪个 API 是列表接口）；
- 在参数不完全时提出建议（例如推荐默认列集合、筛选字段集合）；
- 用自然语言解释“为什么推荐这个模式/模板组合”，辅助前端做决策。

### 8.2 执行阶段：从 Plan 到实际代码与映射

执行 `executePlan(plan)` 时，对于每个 `create-file` action：

1. 参数校验：
   - 根据 `patternId` 读取模式定义，使用 `paramsSchema` 校验 `params` 是否符合约束；
   - 可选：检查 `params` 中引用的实体/接口在 Intent 中确实存在。
2. 查找模板实现：
   - 通过 `template` 字段在模板仓库中找到对应的模板实现（例如某个 `render(intent, params)` 函数）。
3. 渲染代码骨架：
   - 调用模板的 `render`，传入 Intent 与 `params`，生成目标文件的源码字符串；
   - 模板内部会使用 Intent 的领域信息（实体字段、接口参数）以及模式参数（列/筛选字段等）拼装出骨架代码。
4. 写入文件与记录溯源：
   - 将生成的源码写入 `path`；
   - 在映射表中记录该文件由哪个 Intent / Pattern / Template / params 生成，便于后续追溯。

LLM 在执行阶段一般不直接操作文件系统，而是可以通过受控能力参与：

- 在模板渲染内部，为复杂片段提供初稿（例如根据字段生成更复杂的过滤条件映射函数），由模板以插槽形式注入；
- 在 Plan 执行前后，用自然语言解释 action 的作用和潜在影响，帮助前端审阅变更；
- 在执行失败时，对结构化错误（参数缺失、约束不满足）进行可读性高的错误说明与修复建议。

整条链路中，LLM 被限制在“生成和解释结构化/代码片段”的角色，  
真正的决策（Plan 内容）与副作用执行（写文件）始终由平台管线与模板代码负责。

## 9. 内核视图（架构师视角）

从平台内核的角度，可以把核心概念抽象成三块并通过 Service 连接起来：

```text
          +------------------+
          |   Intent (YAML)  |
          |  - scene         |
          |  - domain        |
          |  - patterns      |
          |  - runtimeFlows  |
          +---------+--------+
                    |
                    | 绑定模式 ID / Flow DSL
                    v
          +---------+--------+
          |   Pattern (YAML) |
          |  - roles         |
          |  - provides      |
          |  - requires      |
          |  - uiCapabilities|
          +---------+--------+
                    |
                    | Service ID（见 services.md）
                    v
          +---------+--------+
          | Template Meta    |
          |  - implements    |
          |  - impl          |
          |  - runtimeBind   |
          +---------+--------+
                    |
                    | 规划阶段：buildPlan
                    v
          +---------+--------+
          |   Plan (JSON)    |
          |  - actions[]     |
          +---------+--------+
                    |
                    | 执行阶段：executePlan
                    v
          +---------+--------+
          |  代码骨架 / Diff |
          +------------------+
```

对应关系简要说明：

- **Intent**
  - 描述场景结构（scene）、实体与接口（domain）、使用哪些模式（patterns），以及通过 `runtimeFlows` 声明行为流水线；
  - Flow DSL 中的 `call: Service.method` 使用的是在 Pattern 中 `provides`、`services.md` 中列出的 Service ID。
- **Pattern**
  - 通过 `roles`/`provides`/`requires` 声明模式内部的服务角色图；
  - 通过 `uiCapabilities` 描述对底层组件库的能力需求；
  - 为 Intent 的结构提供“套路”和 Service 语义基础。
- **Template Meta**
  - 通过 `implements.roles` 将抽象角色映射到具体文件路径模式；
  - 通过 `impl` 与未来的 Layer/实现风格标签对齐；
  - 通过 `runtimeBindings` 将 uiCapabilities 绑定到具体组件库。
- **Plan**
  - 是 Intent + Pattern + Template Meta 的具体展开结果：  
    每个 action 都携带 `patternId` / `template` / `params`，以及隐含的 Service 背景；
  - 平台可以基于 Plan 做可视化、审阅、执行与追溯。

对架构师而言，上图可以作为“平台内核脑内模型”：  
上游只有 Intent/Pattern/Template 三类声明式配置，下游只有 Plan 和代码/ Diff，中间的 Service 与 Flow 由平台内核（可选用 Effect/DI 实现）负责解释和执行。
</file>

<file path="specs/intent-driven-ai-coding/v1/05-effect-ts-integration.md">
---
title: 平台内核实现方案：以 Effect/DI 承载能力与生成管线
status: draft
version: v1
---

> 本文讨论一种面向未来的平台内核实现思路：  
> 在出码前平台中使用函数式 Effect + 依赖注入（例如 effect-ts 一类的库）作为“能力抽象与生成工作流”的内核。  
> 这些内容主要面向平台 / 架构开发者，对理解 Intent / Pattern / Template / Plan 概念本身并非必需。

## 1. 适用前提

本文讨论的前提是：

- 场景聚焦于 Web 端 toB 管理系统前端团队；
- 不追求多端（浏览器 / Node / 云函数）极致抽象，只需覆盖本地工具链与前端工程；
- 希望在“出码前管线”中，把各种生成/修改行为建模得更可组合、更可测试。

## 2. 三层映射：意图 / 模式 / 模板 → Effect 世界

### 2.1 意图层：纯数据 + Schema

- 意图资产（Intent）保持为**纯数据结构**：
  - TypeScript 类型；
  - Schema（用于解析/校验 YAML/JSON）；
  - 文本说明。
- 这里不引入 Effect，仅使用 Schema 做：
  - 从文件解析为内存对象；
  - 运行时校验和默认值填充。

这样，意图可以脱离任何运行时框架，由人和 AI 直接阅读与修改。

### 2.2 模式层：Intent → Plan 的纯逻辑

- 模式的核心是把某一类意图映射为“生成/修改的抽象计划（Plan）”：
  - 最理想是**纯函数**：`Intent -> Plan`；
  - 如需复杂校验或错误处理，可以使用只依赖工具函数的 Effect：
    ```ts
    type Plan = GenerationPlan

    const planWorkbench: (intent: WorkbenchIntent) =>
      Effect.Effect<never, ValidationError, Plan>
    ```
- 这一层尽量不做 IO，不依赖文件系统或进程，只关心：
  - 模式是否适配当前意图；
  - 需要生成/修改哪些逻辑单元（“页面骨架”“列表容器”“详情视图”等抽象对象）。

### 2.3 模板执行层：Plan → 实际代码操作

- 将 Plan 落实到真实代码，需要一组“能力服务”：
  - 文件系统访问；
  - 模板仓库访问；
  - 代码生成/文本 patch；
  - 日志与进度反馈。
- 可以用 “服务接口 + DI” 的形式建模：
  ```ts
  interface FileSystem {
    read(path: string): Effect.Effect<never, FsError, string>
    write(path: string, content: string): Effect.Effect<never, FsError, void>
  }

  interface CodeGen {
    applyTemplate(
      templateId: string,
      params: Record<string, unknown>
    ): Effect.Effect<never, CodegenError, GeneratedFile[]>
  }
  ```
- 执行 Plan 的主流程可以是：
  ```ts
  const applyPlan = (plan: GenerationPlan) =>
    Effect.gen(function* (_) {
      const fs = yield* _(FileSystem)
      const codegen = yield* _(CodeGen)
      // 根据 plan 逐步读写文件、应用模板
    })
  ```

这里的 `Env`（环境）由若干服务接口组成，运行时通过 Layer 或工厂函数注入不同实现。

## 3. 出码前 / 出码后分别如何使用

### 3.1 出码前：生成管线内核

在出码前的平台/工具层，可以全面使用 Effect/DI 来：

- 表达“从 Intent + Pattern 到 Plan 再到 Code Diff”的整个工作流；
- 组合多个模式/模板的执行步骤，显式建模依赖关系；
- 把错误（例如意图缺字段、模板参数不完整、IO 失败）用结构化方式传出，而不是散落在日志字符串中。

业务开发者不需要看到 Effect 的细节，只需要调用简单 API：

```ts
await generateFeature(intent) // 内部调用 Effect 程序
```

### 3.2 出码后：谨慎、少量地使用

在运行时（浏览器中的业务代码）：

- 多数业务组件/页面无需引入 Effect/DI，保持常规 async/await + Hook 结构即可；
- 如有复杂跨页面流程（导入/导出、批量任务执行等），可以在“基础设施层”使用 Effect：
  - 定义少量流程服务；
  - 用 Hook 提供简单调用接口给业务代码；
  - 隔离复杂度，不要求业务开发者理解 Effect 类型系统。

原则：Effect/DI 是“内核工具”，而不是所有业务代码的强制标准。

## 4. 对“前置化定义意图/模式”的帮助

利用 Effect/DI，有两点特别契合意图驱动体系：

1. **模式只依赖抽象能力，和具体实现解耦**
   - 模式的规划逻辑只依赖抽象服务（例如 TemplateRepo、CodeGen），可以在没有具体模板实现的情况下先定义好；
   - 这使得“意图和模式的定义”可以极早落地，模板和工具实现可以晚一些演进。
2. **意图与配置只依赖 Schema，不依赖运行时**
   - 意图资产的 Schema 与解析逻辑不依托任何 Effect/DI；
   - 对于工具/AI 来说，只需理解 Schema，不必了解内核实现。

这正好符合“意图和模式前置，具体实现后置”的设计目标。

## 5. 使用建议（toB 管理系统团队视角）

- **推荐使用场景**
  - 出码前平台的生成管线；
  - 少数需要强一致错误处理与组合能力的运行时流程；
  - 平台/架构团队内部的工具脚本和服务。
- **不推荐的场景**
  - 业务页面内部的日常交互和布局；
  - 复杂类型暴露给所有业务开发者使用；
  - 用 Effect/DI 把本就简单的逻辑搞得晦涩难懂。

简而言之：

- 在“平台内部”，Effect/DI 可以成为能力抽象与流水线的坚实内核；
- 在“业务层”，应以简单 API/Hook 暴露这些能力，避免把实现细节变成团队的额外心智负担。

## 6. 行为层文件形态（.flow.ts）与运行时集成建议

为了承载 Intent.runtimeFlows 中上升为“意图化行为”的流程，本规划推荐在运行时引入一层专门的“行为文件”：

- 文件后缀建议：`*.flow.ts`
  - 用于存放 Effect 形式的行为程序（例如导出流程、审批流程等）；
  - 不直接依赖 React，仅依赖 Service 接口与 Effect/DI 环境。
- 典型结构：
  - 每个 Flow（Intent.runtimeFlows 中的一个 `id`）在对应的 `.flow.ts` 中有一个导出的 Effect 程序；
  - Service 接口（如 `FilterService`、`ExportService` 等）通过 Env 注入；
  - UI 层通过 Hook 封装调用，例如：
    - `useExportOrders` 内部调用 `runEffect(exportOrdersFlow, env)`；
    - 组件只关心 `handleExport`，不关心 Effect 的细节。

推荐实践：

- 对未进入 Intent.runtimeFlows 的轻量逻辑，继续使用 async/await + Hook 组合，不强制 `.flow.ts`；
- 一旦某个行为被提升到 Intent.runtimeFlows（需要平台/LLM 长期维护与重构），
  优先为其创建 `.flow.ts` 行为文件，并将 Flow DSL 编译/映射为 Effect 程序：
  - Flow DSL / AST：声明层；
  - `.flow.ts` 中的 Effect：行为层 SSoT；
  - Hook / 组件事件处理器：调用层（桥接到 UI）。

这样，Zustand + TanStack Query 继续承担状态/缓存职责，  
Flow + Effect + `.flow.ts` 则自然成为“行为层”的承载方式。

## 7. PoC 级别代码结构示意

> 本节不绑定具体库，仅用“Effect/DI”一类抽象代称。若使用某个具体实现（如某款 Effect 库），可直接按其 Tag/Layer 机制落地。

### 6.1 核心模块划分

在出码前平台内部，可以按以下模块拆分：

- `intent` 模块：
  - 定义 Intent 的类型与 Schema；
  - 负责从文件加载/保存 Intent。
- `pattern` 模块：
  - 定义 Pattern 的类型与 Schema；
  - 提供“模式匹配”与“适配性检查”逻辑。
- `template` 模块：
  - 定义 Template Meta；
  - 提供对模板仓库的访问与查询能力。
- `planning` 模块：
  - 提供 `buildPlan(intentId)` 等函数，将 Intent+Pattern+Template Meta 转成 Plan。
- `execution` 模块：
  - 提供 `executePlan(plan)`，执行真正的文件改动和模板应用。
- `services` 模块：
  - 抽象底层能力：文件系统、代码生成、日志、AI 调用等。

### 6.2 能力服务与环境类型

伪代码示意：

```ts
// 能力服务定义
interface FileSystem {
  read(path: string): Effect<never, FsError, string>
  write(path: string, content: string): Effect<never, FsError, void>
  exists(path: string): Effect<never, never, boolean>
}

interface TemplateRepo {
  getMeta(id: string): Effect<never, TemplateError, TemplateMeta>
}

interface CodeGen {
  applyTemplate(
    meta: TemplateMeta,
    params: Record<string, unknown>
  ): Effect<never, CodegenError, GeneratedFile[]>
}

interface Logger {
  info(message: string): Effect<never, never, void>
  error(message: string): Effect<never, never, void>
}
```

环境类型可以是这些服务的交叉类型：

```ts
type PlanningEnv = FileSystem & TemplateRepo & Logger
type ExecutionEnv = FileSystem & CodeGen & Logger
```

实际实现时，可以通过某种 `Layer`/工厂模式，在 Node 环境中用真实 FS/日志实现这些接口，在测试中用内存实现替代。

### 6.3 规划与执行函数签名

在这种拆分下，核心管线可以长成：

```ts
// IntentId -> Plan 的规划
const buildPlan = (
  intentId: string
): Effect<PlanningEnv, PlanningError, GenerationPlan> => {
  // 1. 从文件系统加载 Intent
  // 2. 根据 Intent 引用加载 Pattern 和 Template Meta
  // 3. 运行模式逻辑，生成 Plan
}

// Plan -> 实际改动
const executePlan = (
  plan: GenerationPlan
): Effect<ExecutionEnv, ExecutionError, void> => {
  // 1. 遍历 Plan 中的每一步操作
  // 2. 调用 CodeGen 生成内容，或直接写文件/patch
  // 3. 记录日志与执行结果
}
```

从 HTTP API 或 CLI 看，只需要提供薄薄一层封装：

```ts
// CLI 示例
async function generate(intentId: string) {
  const plan = await Effect.runPromise(buildPlan(intentId).provide(PlanningLayer))
  await Effect.runPromise(executePlan(plan).provide(ExecutionLayer))
}
```

业务前端只需要知道：

- 有一个 `generate(intentId)` 命令/按钮；
- 出错时错误信息里会指向 Intent/Pattern/Template 的具体问题；
- 日志和映射会被写到约定目录下。

### 6.4 错误模型与测试策略

为了避免“Effect 只是把错误藏深了一层”，需要刻意设计错误模型与测试策略：

- 错误类型分层：
  - `IntentError`：意图资产不合法或缺字段；
  - `PatternError`：模式不适配或约束被违反；
  - `TemplateError`：模板元数据缺失/冲突；
  - `PlanningError`：无法根据 Intent+Pattern+Template 生成一致的 Plan；
  - `ExecutionError`：IO/Codegen 过程中的具体错误。
- 测试策略：
  - 为模式逻辑编写纯单元测试（不依赖 FS），验证 Intent→Plan 的映射；
  - 为执行层编写集成测试，在临时目录中跑真实写盘流程；
  - 利用 Effect/DI 的特性，在测试环境下注入内存 FS 和 Fake CodeGen，做到快速且可控。

这样，Effect/DI 的引入不是为了炫技，而是为了：

- 让“出码前管线”这一坨复杂逻辑可以拆分、组合和测试；
- 在错误发生时给出结构化、可追踪的反馈，而不是“某个脚本报错了，自己看日志吧”。
</file>

<file path="specs/intent-driven-ai-coding/v1/06-platform-ui-and-interactions.md">
---
title: 平台侧界面与交互设计（ASCII 草图）
status: draft
version: v1
---

> 本文只讨论「意图 / 模式 / 出码计划」平台的前端界面与交互，不涉及具体实现技术栈。  
> 目标是让前端业务开发和前端架构师都能直观想象：平台长什么样、每一步怎么用。

## 1. 整体信息架构

平台可以被视为三个主要工作区 + 若干辅助视图：

```text
+-------------------------------------------------------------+
| Top Bar: [Logo] [Intent Studio] [Pattern Studio] [Plans]    |
+-------------------------------+-----------------------------+
| Left Sidebar                  | Main Panel                  |
| - 场景列表 / 模式列表 / Plan | - 当前工作区具体内容       |
|   历史                       |                             |
+-------------------------------+-----------------------------+
```

- **Intent Studio**：按场景管理意图（Intent），主要给前端业务开发用。
- **Pattern Studio**：管理模式（Pattern），主要给前端架构师用。
- **Plans / Generation Console**：查看/审阅/执行出码计划（Plan）。

以下章节分别展开。

## 2. Intent Studio（意图工作台）

### 2.1 布局草图

```text
+-------------------------------------------------------------+
| Top Bar: [Intent Studio]* [Pattern Studio] [Plans]          |
+----------------------+--------------------------------------+
| Intent List          | Intent Editor                       |
|                      |                                      |
| [新建场景]           | +-------------------------------+   |
|                      | | Tabs: [概览] [场景结构] ...  |   |
| - order-management   | +-------------------------------+   |
| - ops-workbench      | |  表单区域（Goals/Scene/...） |   |
| - user-list          | |                               |   |
|                      | |  [ 使用向导 / Ask AI 补全 ]   |   |
|                      | +-------------------------------+   |
|                      | | YAML 预览（只读/高级编辑）   |   |
|                      | +-------------------------------+   |
+----------------------+--------------------------------------+
```

- 左侧：场景列表 + “新建场景”按钮。
- 右侧：当前场景的编辑区域，采用“分步表单 + YAML 预览”的形式。

### 2.2 关键交互流程

**流程 A：新建场景 / 意图**

1. 点击左上角 `[新建场景]`：
   - 弹出对话框：输入场景名称、ID（例如 `订单管理列表 / order-management`）。
2. 创建后，右侧进入“意图向导”：
   - Step 1：目标（goals）与简介；
   - Step 2：场景结构（页面类型、布局区域）；
   - Step 3：实体与接口（Domain）；
   - Step 4：主要流程（Flows）。
3. 每一步都有“用 AI 继续补全”按钮，AI 会：
   - 从已有描述推测缺失字段；
   - 给出建议（例如“是否需要导出能力？”）。
4. 点击“保存”后，平台：
   - 校验 Schema；
   - 写入 `intents/<id>.intent.yaml`；
   - 将当前状态标记为：`ready-for-pattern`。

**流程 B：模式推荐入口**

在 Intent Editor 的“场景结构”/“概览”页，底部提供：

```text
[ 推荐模式 ]  [ 手动选择模式 ]  [ 查看已绑定模式 ]
```

- 点击“推荐模式”：
  - 调用后端 `/patterns/match`，传入当前 Intent 摘要；
  - 右侧弹出“模式候选侧栏”，展示推荐模式卡片；
  - 每张卡片有：名称、摘要、适用场景、风险提示、[详情] 链接。
- 前端业务开发可直接**勾选**需要的模式：
  - 被勾选的模式会写入 Intent 的 `patterns` 字段；
  - 若模式有必填参数，平台自动导航至“模式配置表单”（见下一节）。

### 2.3 模式配置表单（从 Intent 侧进入）

当一个模式被选中后，Intent Editor 中会出现“模式配置”页签：

```text
Tabs: [概览] [场景结构] [领域模型] [模式配置] [YAML 预览]

[ 模式配置 ]

模式：table-with-server-filter
目标区域：table

字段：       控件：
------------------------------------------
实体:        [ Order v ]                  (select，选自 intent.domain.entities)
分页:        [ 开关 on/off ]              (switch)
批量操作:    [x] 导出 [ ] 批量更新        (checkbox-group)
列配置:      [ 列选择器组件 ]             (column-picker)
筛选字段:    [ status, createdAt ]       (multi-select)
------------------------------------------
           [ 保存配置 ]   [ 用 AI 推荐 ]
```

- UI 的字段来源于 Pattern 的 `paramsSchema` 与 `uiSchema`。
- “用 AI 推荐”：
  - 例如自动推荐列集合（常用字段）；
  - 自动推荐筛选字段（有枚举/时间语义的字段）。
- 保存后：
  - 更新 Intent 中对应模式的 `patterns[].config`；
  - 标记意图为 `ready-for-plan`。

## 3. Pattern Studio（模式库管理）

### 3.1 布局草图

```text
+-------------------------------------------------------------+
| Top Bar: [Intent Studio] [Pattern Studio]* [Plans]          |
+----------------------+--------------------------------------+
| Pattern List         | Pattern Detail / Editor              |
|                      |                                      |
| [新建模式]           | +-------------------------------+   |
|                      | | table-with-server-filter    v |   |
| - list-detail        | +-------------------------------+   |
| - workbench-layout   | | Summary / Problem /           |   |
| - table-with-server… | | Applicability / Roles         |   |
| - wizard-form        | +-------------------------------+   |
|                      | | Params Schema / UI Schema     |   |
|                      | | [ YAML 视图 ] [ 示例引用 ]    |   |
|                      | +-------------------------------+   |
+----------------------+--------------------------------------+
```

- 左侧：模式列表 + 新建模式。
- 右侧：模式详情与编辑，包括：
  - 基础信息；
  - `composition.roles`；
  - `paramsSchema`/`uiSchema`；
  - 示例 Intent/Plan 关联。

### 3.2 关键交互流程

**流程 C：新建/编辑模式**

1. 架构师点击 `[新建模式]`：
   - 填写：`id/name/summary`；
   - 在“问题与适用性”标签页录入 problem / applicability。
2. 在“组成与角色”标签页：
   - 添加 roles（如 TableComponent、FilterStore 等）；
   - 对每个角色写职责说明。
3. 在“参数与 UI”标签页：

```text
[ 参数定义 ]
- entity: string (required)
- pagination: boolean (default: true)
- batchActions: string[] (enum: export, bulkUpdate)
...

[ UI Schema 预览 ]
entity        -> select       (options: intent.domain.entities)
batchActions  -> checkbox-group (options: export/bulkUpdate)
columns       -> column-picker  (options: entity.fields)
```

4. 在“UI 能力约束与组件绑定”标签页（架构师视图）：

```text
[ UI 能力约束 ]

table:
  required: [ pagination, serverSideFilter, sortableColumns ]
  optional: [ rowSelection, columnVisibility ]

filterControls:
  required: [ select, dateRangePicker ]
  optional: [ keywordSearch ]

[ 组件绑定（当前项目） ]

table:
  useComponent: ProTable
  import:      "@/components/ProTable"

filterControls.select:
  useComponent: Select
  import:      "@/components/Select"

filterControls.dateRangePicker:
  useComponent: DateRangePicker
  import:      "@/components/DateRangePicker"
```

这一页的配置会写入 Template Meta 中的 `runtimeBindings`，决定“模式需要的 UI 能力在当前项目里由哪些组件来实现”。前端业务开发通常只关心模式与参数，组件绑定由前端架构师维护。

4. 保存时，平台：
   - 验证 `paramsSchema` 结构正确；
   - 写入 `patterns/<id>.pattern.yaml`。

**流程 D：从 Intent 跳回模式**

在 Intent Studio 中，点击某个模式卡片上的 `[详情]` 或 `[在模式库中打开]`：

- 跳转到 Pattern Studio，并定位到对应模式；
- 右侧直接展示该模式的 Problem/Applicability/Roles/Params；
- 支持从这里导航回“使用了该模式的 Intent 列表”，方便架构师看“谁依赖了这个模式”。

## 4. Generation Console（出码计划 / Plans）

### 4.1 布局草图

```text
+-------------------------------------------------------------+
| Top Bar: [Intent Studio] [Pattern Studio] [Plans]*          |
+----------------------+--------------------------------------+
| Plan List            | Plan Detail / Preview                |
|                      |                                      |
| [按 Intent 筛选]     | Intent: order-management            |
|                      | 状态: 未执行 / 已执行               |
| - order-management   | Version: v1                         |
|   (2024-xx-xx)       |                                      |
| - ops-workbench      | +-------------------------------+   |
|   (2024-xx-yy)       | | 文件树 / Action 列表          |   |
|                      | +-------------------------------+   |
|                      | | 右侧：Diff / Params 详情      |   |
|                      | +-------------------------------+   |
|                      | [ 执行计划 ]  [ 仅生成部分 ]    |
+----------------------+--------------------------------------+
```

### 4.2 Action 列表交互（以 CRUD 示例为例）

Action 列表可以用“文件树 + 勾选框”的形式呈现：

```text
[x] src/features/order-management/order-management.page.tsx         (list-page-shell)
[x] src/features/order-management/components/order-filters.tsx     (filter-bar)
[x] src/features/order-management/components/order-table.tsx       (table-with-server-filter)
[x] src/features/order-management/components/order-toolbar.tsx     (toolbar-with-quick-edit)
[x] src/features/order-management/components/order-quick-edit.tsx  (quick-edit-dialog)
[x] src/features/order-management/stores/filter.slice.ts           (filter-store-slice)
[x] src/features/order-management/stores/table.slice.ts            (table-store-slice)
[x] src/features/order-management/queries/use-orders-list.hook.ts  (list-query-hook)
```

- 点击某一行：
  - 右侧展示该 action 的详情：

```text
Action: create-file
Path:   src/features/order-management/queries/use-orders-list.hook.ts
Pattern:  table-with-server-filter
Template: list-query-hook

Params:
- entity:  Order
- apiName: listOrders

[ 展开 Intent 区域 / 展开 Pattern 定义 / 展开 Template Meta ]
```

- 前端业务开发可以：
  - 取消勾选某些 action（例如暂不生成 quick-edit 相关文件）；
  - 调整部分 params（如果允许），例如覆盖默认 pageSize；
  - 通过右侧链接快速查看相关 Intent/Pattern/Template 定义。

### 4.3 执行与日志查看

执行流程：

1. 业务前端审阅无误后点击 `[ 执行计划 ]`：
   - 平台调用 `/plans/execute?intentId=...`；
   - 即时展示进度条和每个 action 的执行状态（成功/失败/跳过）。
2. 执行结束后：
   - 提供链接打开执行日志视图：

```text
执行结果: 成功 (8/8)

步骤:
1. create-file src/features/order-management/order-management.page.tsx ... OK
2. create-file src/features/order-management/components/order-filters.tsx ... OK
...

[ 查看日志 JSON ] [ 在 Git 中对比 diff ]
```

LLM 可在此视图中提供：

- 针对失败 action 的解释（参数缺失、模式约束不满足等）；
- 针对整个 Plan 的高层总结（例如“本次生成新增 8 个文件，均为新建，无破坏性修改”）。

## 5. 角色在界面中的具体操作范围汇总

### 5.1 前端业务开发

- 在 Intent Studio：
  - 新建/编辑 Intent（包括目标、场景结构、实体与接口等）；
  - 触发模式推荐，选择和配置模式；
  - 查看 YAML 预览，确认结构化结果。
- 在 Generation Console：
  - 查看与当前 Intent 相关的 Plans；
  - 审阅 action 列表和 Params 详情；
  - 决定哪些 action 执行，哪些跳过；
  - 触发 Plan 执行，查看执行日志。

### 5.2 前端架构师 / 平台前端

- 在 Pattern Studio：
  - 创建/编辑模式定义（含 roles、paramsSchema、uiSchema）；
  - 查看哪些 Intent 引用了某个模式；
  - 评估/指导模式演进对下游的影响。
- 在 Template 管理界面（可在 Pattern Studio 或 Plans 侧栏中）：
  - 定义 Template Meta，绑定模式角色与文件路径模式；
  - 维护模板与技术栈/目录结构的关系；
  - 配合生成器设计 Plan 中 action 的粒度。

### 5.3 AI 代理（在 UI 层可以看到的能力入口）

UI 中建议提供显式的 AI 入口，例如：

- Intent Studio：
  - “用 AI 补全本节”；
  - “用 AI 从 PRD 摘要生成初版 Intent”。
- Pattern Studio：
  - “用 AI 帮我从现有代码提取候选模式文档”；
  - “用 AI 生成 paramsSchema 初稿（由架构师 review）”。
- Generation Console：
  - “用 AI 解释当前 Plan 的影响”；
  - “用 AI 给出执行前/后的风险提示或回滚建议”。

LLM 只通过这些明确的入口参与，不直接对文件写入做最终决策，从而保证平台的可控性和可审计性。
</file>

<file path="specs/intent-driven-ai-coding/v1/07-ui-capabilities-and-design-system.md">
---
title: UI 能力与设计系统约定（uiCapabilities & runtimeBindings）
status: draft
version: v1
---

> 本文是对「意图 → 模式 → 模板」体系中 UI 层约束的补充，回答两个问题：  
> 1）模式声明的 `uiCapabilities` 到底是什么；  
> 2）它们如何与具体设计系统 / 组件库通过 `runtimeBindings` 对上号，并保持可演进。

## 1. 为什么要引入 uiCapabilities？

如果模式直接写死“要用某个组件（例如 ProTable）”，会带来几个问题：

- 模式无法在不同项目/技术栈间复用（强绑具体组件库）。
- 模式文档会变成某个库的使用手册，而不是抽象的编码套路。
- 后续替换组件库时，需要重写所有模式和模板，成本极高。

我们希望：

- 模式只说“我需要一个**具备某些能力的表格/筛选控件**”，不关心具体组件名；
- 不同项目可以用自己的组件库去满足这些能力；
- 模式和意图不用因为组件库迁移而重写，只需要调整绑定关系。

这就是 `uiCapabilities` 的作用：  
**在模式层抽象 UI 能力，在模板层绑定具体组件实现。**

## 2. uiCapabilities 的基本形态

### 2.1 能力命名规则

建议使用「领域 + 能力」的命名方式，并在模式中集中声明，例如：

```yaml
uiCapabilities:
  table:
    required:
      - pagination          # 支持分页
      - serverSideFilter    # 支持服务端筛选
      - sortableColumns     # 支持列排序
    optional:
      - rowSelection        # 行选择能力
      - columnVisibility    # 列显隐

  filterControls:
    required:
      - select
      - dateRangePicker
    optional:
      - keywordSearch
```

命名建议：

- 第一层 key 表示“能力域”（例如 `table` / `filterControls` / `layout`）。
- 第二层为该能力域下的能力标识（`pagination` / `serverSideFilter` 等），使用 kebab-case 或 camelCase，保持短小清晰。

### 2.2 能力语义约定

每个能力标识（如 `pagination`）需要在文档中给出语义定义，例如：

- `pagination`：表格组件需要支持 `page`、`pageSize`、`total` 三个参数，并暴露 `onPageChange`、`onPageSizeChange` 回调。
- `serverSideFilter`：表格组件不负责本地过滤，而是将 filter 参数透传给调用方，以便调用方发起新的请求。
- `sortableColumns`：允许为每一列单独开启排序，并通过回调告知当前排序字段与方向。

这些定义应写入模式文档或一个集中约定文件中，作为组件库适配和模板实现的依据。

## 3. runtimeBindings：能力到组件的映射

在 Template Meta 中，通过 `runtimeBindings` 把 uiCapabilities 映射到具体组件实现。例如：

```yaml
runtimeBindings:
  uiCapabilities:
    table:
      useComponent: ProTable
      import: "@/components/ProTable"
    filterControls:
      useComponents:
        select:
          import: "@/components/Select"
        dateRange:
          import: "@/components/DateRangePicker"
        keyword:
          import: "@/components/KeywordInput"
```

含义：

- 对于模式声明的 `table` 能力域：
  - 当前项目用 `ProTable` 组件来承载；
  - 模板生成代码时会统一从 `"@/components/ProTable"` 引入。
- 对于 `filterControls` 能力域：
  - `select/dateRange/keyword` 分别映射到对应组件；
  - 模板生成表单控件时，根据这些绑定渲染正确的 JSX。

注意：

- 一个项目可以有多套 Template Meta（例如用于不同 UI 库）；
- 只要 `runtimeBindings` 满足模式声明的能力要求，模式和 Intent 不需要修改。

## 4. 对模板和代码生成的影响

### 4.1 模板内部如何使用 uiCapabilities？

以列表查询 Hook + 表格组件为例，模板在渲染代码时可以这样使用绑定：

```ts
function renderTableComponent(args: {
  bindings: RuntimeBindings
  params: { entity: string; columns: ColumnSpec[] }
}) {
  const { bindings, params } = args
  const tableComponentImport = bindings.uiCapabilities.table.import
  const tableComponentName = bindings.uiCapabilities.table.useComponent

  return `
import { ${tableComponentName} } from '${tableComponentImport}'

export function ${params.entity}Table() {
  // ...
  return (
    <${tableComponentName}
      columns={columns}
      data={data}
      page={page}
      pageSize={pageSize}
      total={total}
      onPageChange={setPage}
      onPageSizeChange={setPageSize}
    />
  )
}
`
}
```

模板不需要关心“是 ProTable 还是别的表格”，只用绑定信息做字符串插值即可。

### 4.2 能力不满足时的行为

当某个模板需要用到某项能力（例如 `rowSelection`），但当前 Template Meta 中的绑定没有声明该能力时：

- 生成器应拒绝执行或给出明确警告；
- 可以提示“当前模板依赖 table.rowSelection 能力，但项目绑定中未声明，请由架构师在 Template Meta 中补齐绑定或者关闭该能力”。

这避免了“生成的代码在 UI 上缺某些关键行为”的隐性问题。

## 5. 对阅读者的入门路径提示

对于第一次接触这套规划文档的人，推荐的阅读顺序是：

1. `01-overview.md`：理解意图 / 模式 / 模板三层抽象和 L0–L4 分层。
2. `02-patterns-and-intents.md`：理解模式文档和意图资产的结构。
3. `07-ui-capabilities-and-design-system.md`（本文件）：理解模式与底层组件库是如何通过能力+绑定解耦的。
4. `04-platform-design.md`：理解平台侧的交付物（Intent/Pattern/Template Meta/Plan/Log）和角色分工。
5. `06-platform-ui-and-interactions.md`：用 ASCII 草图具体感受平台 UI 工作流。
6. `v1/patterns/*.pattern.yaml`、`v1/intents/*.intent.yaml`、`v1/templates/*.template.yaml`、`v1/plans/*.plan.json`：通过订单管理 CRUD 示例把概念对上真实文件。

这样，即使从 0 接触该体系，也可以先从抽象层逐步走到“组件库绑定”和“实际代码生成”的细节。

## 6. 角色视角下的 UI 能力与绑定维护

- 前端业务开发：
  - 不直接维护 `uiCapabilities` 和 `runtimeBindings`；
  - 只需要知道：模式在当前项目里会用哪些基础组件（通过文档或平台 UI 显示）；
  - 重点在于选对模式、填好参数、审阅 Plan。
- 前端架构师 / 平台前端：
  - 定义和维护 `uiCapabilities` 含义（能力命名与语义）；
  - 在 Template Meta 中维护 `runtimeBindings`，确保与项目设计系统/组件库吻合；
  - 在组件库升级或替换时，负责调整绑定，而不破坏模式与 Intent。
- 产品（前端暂代）：
  - 更多关心模式带来的“交互一致性”与“可用性”，不直接参与能力/绑定配置。

通过这层抽象，模式与意图可以专注表达“场景与套路”，  
Template Meta 和组件库则负责“具体怎么画出来”，两者解耦但有清晰接口。 

## 7. 与 IMD / best-practice 的关系（说明）

在当前团队环境中：

- UI 组件与设计系统主要来自 IMD 仓库：`/Users/yoyo/projj/git.imile.com/ux/imd`（例如 `apps/www2/registry/default/ui/` 下的组件）；
- 与 UI 互动的状态管理、服务层与适配器等实现实践则主要来自 best-practice 仓库：`/Users/yoyo/projj/git.imile.com/ux/best-practice`。

在本规划中：

- `uiCapabilities` 只在模式层描述“需要什么能力”（表格、筛选控件、布局等），不直接绑定某个具体 UI 库或组件实现；
- 具体在 IMD 中由哪些组件承载这些能力、在 best-practice 中使用哪些状态/服务/适配器模式来驱动这些组件，属于实现层细节，可以通过单独的约定或文档（例如 IMD 内部的 registry 规范、best-practice 内的 file-conventions 与 state-management 指南）进行协调；
- 当组件库或实现实践需要演进时，优先调整的是“能力与组件/代码之间的绑定”，而不是修改 `uiCapabilities` 的概念本身。
</file>

<file path="specs/intent-driven-ai-coding/v1/08-flow-dsl-and-ast.md">
---
title: Flow DSL · AST · Effect 程序
status: draft
version: v1
---

> 本文专门解释：Intent 中的 `runtimeFlows` 是什么、与 Flow AST 和 Effect 程序的关系是什么，  
> 帮助读者从“YAML 声明”理解到“可执行行为”这一条链路，而不涉及具体实现代码。

## 1. 三层一条链

在本方案中，行为编排相关的“程序”可以分为三层：

```text
Intent.runtimeFlows (YAML Flow DSL)
        ↓ parse
FlowAst（内存中的 Flow 抽象语法树）
        ↓ backend A：Effect 程序（Effect<Env, E, A>） ← 行为层 SSoT
        ↓ backend B：TS 代码生成（Hook / 事件处理器）
业务代码骨架（TS/React 源码）
```

- **Flow DSL（YAML）**：面向平台界面和配置，记录在 Intent 的 `runtimeFlows` 字段中；
- **Flow AST**：平台内部使用的中间结构（TypeScript 类型），便于校验、可视化和转换；
- **Effect 程序**：Flow AST 映射到 Effect 世界的“行为真身”（可以是 effect-ts 或等价实现的 `Effect<Env, E, A>`）；  
  在出码前平台内核中，Effect 程序被视为运行时行为的 SSoT；
- **TS 代码生成**：根据 Flow AST / Effect 程序生成 Hook/事件处理器等业务代码骨架，实现“出码”。

## 2. Flow DSL（YAML）回顾

以 `order-management.intent.yaml` 中的导出流程为例：

```yaml
runtimeFlows:
  - id: exportOrders
    trigger:
      element: toolbar.exportButton
      event: click
    pipeline:
      - call: FilterService.getCurrentFilters
        as: filters
      - call: TableUiStateService.getCurrentState
        as: tableState
      - call: ExportService.submitExportTask
        params:
          filters: "{{filters}}"
          columns: "{{tableState.visibleColumns}}"
```

DSL 的关键元素：

- `id`：流程唯一标识（例如 `exportOrders`）。
- `trigger`：触发条件（例如某个按钮的 click 事件）。
- `pipeline`：若干步骤构成的“流水线”，每一步都是一类操作：
  - `call: Service.method`：调用由 Pattern 提供的某个 Service（详见 `services.md`）；
  - `as`：将调用结果保存到上下文变量中；
  - `params`：调用参数，可以通过 `{{变量名}}` 从上下文中取值。

## 3. Flow AST（中间抽象）

为方便说明，可以构造一个示意性的 TypeScript 类型（实现时可根据实际需要调整）：

```ts
type FlowStep =
  | {
      _tag: 'Call'
      service: 'FilterService' | 'TableUiStateService' | 'ExportService'
      method: string
      as?: string
      params?: Record<string, unknown>
    }

interface FlowAst {
  id: string
  trigger: { element: string; event: string }
  pipeline: FlowStep[]
}
```

解析过程就是：

1. 从 YAML 中读取 `runtimeFlows`；
2. 将 `call: "FilterService.getCurrentFilters"` 拆分为 `service = "FilterService"`、`method = "getCurrentFilters"`；
3. 把 `as/params` 等字段映射到 AST 对象；
4. 将整条 `pipeline` 组装为 `FlowAst`。

这一层只是平台内部的“中间表示”，用途包括：

- 语义校验（例如引用的 Service 是否在 Pattern 中被 `provides`）；
- 静态分析（例如 pipeline 中是否使用了未定义的变量）；
- 可视化（在 UI 中画出流程图）。

## 4. 从 Flow AST 到 Effect 程序（示意）

在使用 Effect/DI 作为平台内核时，可以为 FlowAst 写一个“解释器”，将其转换为 Effect 程序。  
在本规划中，Effect 程序被视为运行时行为的 SSoT：Flow DSL 和 AST 是声明层，Effect 程序是可执行的行为模型。

```ts
// 这里的 Effect 可以是 effect-ts 的 Effect<Env, E, A>，
// 也可以是 v1/poc/effect.ts 中的简化版本。
type Effect<R, E, A> = (env: R) => Promise<A>

function interpretFlow(flow: FlowAst): Effect<Env, never, void> {
  // 伪代码：遍历 flow.pipeline，将每个 Call 步骤映射为对应 Service 的方法调用，
  // 并用 Effect 组合起来。具体实现留给平台内核。
}
```

对于上面的 `exportOrders` 流程，其 Effect 形态（伪代码）类似：

```ts
const exportOrdersEffect: Effect<Env, never, void> =
  FilterService.getCurrentFilters.pipe(
    Effect.bindTo('filters'),
    Effect.bind('tableState', () => TableUiStateService.getCurrentState),
    Effect.flatMap(({ filters, tableState }) =>
      ExportService.submitExportTask({
        filters,
        columns: tableState.visibleColumns,
      })
    )
  )
```

要点：

- Service 名（`FilterService`、`TableUiStateService`、`ExportService`）与 Pattern 中 `provides`/`requires` 声明的 Service ID 一致；
- Effect 程序本身是平台内核的实现细节，业务前端不会直接看到，只通过“点击导出按钮”这一交互体验到其行为。

## 5. 从 Flow AST 到代码生成（示意）

除了解释执行，还可以基于同一份 FlowAst 生成业务代码骨架。例如：

- FlowAst → `useExportOrders` Hook；
- FlowAst → 集成 Service 调用的按钮组件代码。

伪代码示意：

```ts
function generateFlowHookCode(flow: FlowAst): string {
  // 读取 flow.id / pipeline，拼出一个 TS Hook 源码字符串，
  // 例如 useExportOrders(() => ExportService.submitExportTask(...))
}
```

这样，Flow DSL 就既可以驱动平台内部的执行，又可以驱动“出码”，实现真正的“行为即配置”。

## 5. 什么时候值得“上 Flow + Effect”？（与简单 async 的边界）

- 适合使用 Flow + Effect 的场景：
  - 行为跨多个 Service / Store / 页面（例如导出、复杂审批操作、批量任务执行）；
  - 行为需要在 Intent 层“意图化”，希望被平台和 LLM 长期维护与重构；
  - 行为需要统一观测/审计（例如每次导出都要打日志、做权限检查）。
- 可以继续用简单 async 函数 + Hook 的场景：
  - 单一页面内的轻量交互（普通 CRUD 保存按钮、简单表单提交）；
  - 不需要进入 Intent.runtimeFlows 的行为，只在本地组件或 Store 内部使用。

推荐实践：

- 不强迫所有 CRUD 按 Flow + Effect 写；  
- 一旦某个行为被写入 Intent.runtimeFlows，且需要由平台/LLM 维护，优先用 Flow DSL → FlowAst → Effect 程序这条链路承载。

## 6. 与现有文档 / 文件的关系

- Intent：
  - `runtimeFlows` 字段定义了 Flow DSL 的数据结构；
  - 是本文件所述链路的入口。
- Pattern：
  - 通过 `composition.roles.provides/requires` 与 `services.md` 中的 Service ID 对齐；
  - 为 Flow DSL 中的 `call: Service.method` 提供语义基础。
- Template / Plan：
  - 继续负责“静态结构”（页面壳、组件、Store、Hook 等）；
  - Flow DSL 则负责“动态行为”的声明。

当前 v1 版本仅定义了 DSL 与 AST 的大致形状，并未强制平台在短期内实现全部解释与代码生成能力。  
这是一条面向未来的扩展路径：当平台需要更强的行为编排时，可以在本设计基础上增量实现。
</file>

<file path="specs/intent-driven-ai-coding/v1/09-llm-collaboration-and-intent-workflow.md">
---
title: LLM 协同视角下的意图驱动工作流
status: draft
version: v1
---

> 本文站在 “LLM 第一视角” 重述整套意图驱动体系：  
> 假设我们已经拥有 IMD 仓库 `/Users/yoyo/projj/git.imile.com/ux/imd` 与 best-practice 仓库 `/Users/yoyo/projj/git.imile.com/ux/best-practice`，  
> 目标是让开发者在面对未知场景时，只需要把需求讲清楚，剩下交给「LLM + Intent + Pattern + 模板」协同完成。

## 1. 定位：Intent 是 LLM 的结构化 Prompt

如果没有今天的 LLM，这套 Intent / Pattern / Template / Plan 体系基本是自找麻烦：  
人类直接看文档 + 写代码更快。

有了 LLM，Intent 的意义在于：

- 从 LLM 的角度，Intent 是一份**结构化的需求 Prompt**：
  - 比散文式 prompt 强在：可解析、可校验、可复用、可追溯；
  - 可以作为后续 Pattern 匹配、Plan 生成、重构建议的稳定输入。
- Pattern / Template / best-practice 则分别扮演：
  - **Pattern YAML**：LLM 的“可索引经验库”（什么场景用什么套路）；
  - **Template / snippets**：LLM 的“代码积木”；  
    通过模板 + 片段约束结构，LLM 只填 slot，而不是自由发挥；
  - **rules-registry**：LLM 的“硬性红线”，例如禁止在 Zustand 中放服务端数据。

本文件聚焦一件事：

> 描述在 “订单 CRUD” 这种典型场景下，一个 LLM 实例如何沿着  
> 「自然语言需求 → Intent → Pattern → Plan → 代码骨架 → 增量重构」这条链条工作，  
> 以及这些现有 YAML/文档在每一步给它提供了什么支撑。

## 2. 四类一等工件：LLM 眼中的世界

从 LLM 视角看，平台需要它理解和操作的“硬货”只有四种：

1. **Intent（意图说明）**  
   - 文件：`intents/<feature-id>.intent.yaml`  
   - 描述内容：goals（目标）、scene（场景结构）、patterns（已选模式）、domain（实体 + 接口）。
   - 示例：`order-management.intent.yaml` 描述订单列表 + 筛选 + 快速编辑 + 导出等需求。

2. **Pattern（模式）**  
   - 文件：`patterns/*.pattern.yaml`  
   - 描述内容：某类场景的一贯套路：问题、适用性、roles（代码角色）、dataContract、paramsSchema、uiSchema 等。
   - 示例：
     - 列表页壳：`list-page.pattern.yaml`
     - 筛选条：`filter-bar.pattern.yaml`
     - 服务端筛选表格：`table-with-server-filter.pattern.yaml`
     - 工具栏 + 快速编辑：`toolbar-with-quick-edit.pattern.yaml`
     - 服务层 + 适配器 + Query Hook：`service-adapter-query.pattern.yaml`
     - Zustand Store + Slice 拆分：`zustand-store-with-slices.pattern.yaml`
     - CRUD 垂直特性骨架：`crud-feature-skeleton.pattern.yaml`

3. **Template Meta（模板元数据）**  
   - 文件：`templates/*.template.yaml` 以及 IMD 内部的模板 meta 文件。  
   - 描述内容：某个模式在当前工程环境（IMD + best-practice）下如何被实现：
     - 实现了哪些 `patternId` / `roles`；
     - 需要哪些参数；
     - 引用了哪些 snippet/template（例如 `tpl-service-layer`、`tpl-zustand-basic-store` 等）。
   - 典型来源：
     - best-practice 模板索引：`/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/03-templates.yaml`
     - IMD registry 模板：`/Users/yoyo/projj/git.imile.com/ux/imd/apps/www2/registry/default/templates/*`

4. **Plan + Execution Log（出码计划与执行日志）**  
   - 文件：
     - Plan：`.plans/<feature-id>.plan.json`
     - Log：`.plans/logs/<feature-id>/<timestamp>.log.json`
   - 描述内容：
     - 将创建/修改/删除哪些文件；
     - 每个 action 对应的 `patternId` / `templateId` / params；
     - 实际执行结果和 diff。

LLM 与 CLI 的职责分工：

- LLM 负责：补全 Intent、匹配 Pattern、选模板、填参数，生成 **Plan 草稿** 和解释；
- CLI / 平台内核负责：验证、执行 Plan，真正写文件、记录日志。

## 3. 阶段一：自然语言需求 → 初版 Intent YAML

**目标**：开发者只需要“讲需求”，LLM 帮忙产出一份结构化 `order-management.intent.yaml` 草稿。

### 3.1 LLM 需要知道什么？

LLM 角色可以称为「Intent Builder」。system prompt 中需要挂载的关键文档包括：

- Intent/Pattern 规划：
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/01-overview.md`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/02-patterns-and-intents.md`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/intents/order-management.intent.yaml`（作为风格示例）
- best-practice 的基础约束和命名习惯：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/00-constitution.md`
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/05-file-conventions.md`
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/06-state-management.md`
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/03-api-integration-guide.md`
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/11-adapter-pattern-guide.md`

LLM 必须遵守：

- 输出严格符合 Intent YAML 结构（goals/scene/domain/patterns/openQuestions/autoFill 等）；
- 字段命名与接口风格尽量贴近 best-practice 中的约定。

### 3.2 典型输入与输出

**开发者输入（自然语言）：**

> “我要做一个订单管理模块：  
>  - 列表要按状态、下单时间、买家名称筛选  
>  - 要能查看详情、修改备注、导出当前筛选条件下的订单  
>  - 后端会提供 listOrders / getOrder / updateOrder / exportOrders 四个接口  
>  你帮我生成一份 Intent YAML 草稿。”

**LLM 输出：**

一份结构化 Intent YAML，例如：

- `id: order-management`
- `goals`：提效、统一导出能力等；
- `scene`：`type: list-page`，regions: filters/toolbar/table，actors/flows 基于描述推导；
- `domain.entities[Order]`：字段列表（id/status/createdAt/updatedAt/buyerName/totalAmount/remark 等）；
- `domain.apis`：listOrders, getOrder, updateOrder, exportOrders 的 path/method/参数；
- `patterns`：可以先只声明场景类型（如 `list-page`），后续由 Pattern 阶段补全具体模式。

**节省了什么？**

- 开发者只需用自然语言解释业务，不必自己手写 YAML 结构；
- 字段和接口命名自动对齐 best-practice 的术语和风格，减少“想名字 + 查规范”的时间；
- 为后续 Pattern 匹配和 Plan 生成提供稳定结构。

## 4. 阶段二：Intent → Pattern 选择与配置

**目标**：基于 Intent，自动挑选合适的 Pattern 组合，并初步填好各自的 config。

### 4.1 LLM 需要知道什么？

LLM 角色可称为「Pattern Advisor」，system prompt 挂载：

- 所有 Pattern 定义：
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/list-page.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/filter-bar.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/table-with-server-filter.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/toolbar-with-quick-edit.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/service-adapter-query.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/zustand-store-with-slices.pattern.yaml`
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/patterns/crud-feature-skeleton.pattern.yaml`
- best-practice 的关键规则（用来约束 LLM 的选择）：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/01-rules-registry.yaml`

约束：

- 只能从上述 Pattern 列表中选择 `id`，不得随意创造新 patternId；
- 填写各模式的 `config` 时必须遵循该模式的 `paramsSchema`。

### 4.2 典型行为：订单 CRUD 场景

LLM 根据 Intent 的 `scene` + `domain` 推断：

- 这是一个标准列表页场景：`list-page`；
- 有顶部筛选区：`filter-bar`；
- 顶部工具栏包含导出/快速编辑：`toolbar-with-quick-edit`；
- 表格需要服务端筛选/分页：`table-with-server-filter`；
- 需要规范的服务层/适配器/Query Hook：`service-adapter-query`；
- 需要跨组件的 UI 状态（筛选、当前行、弹层）：`zustand-store-with-slices`；
- 整个特性可以由一条“垂直骨架”模式串起：`crud-feature-skeleton`。

LLM 输出（直接写回 Intent 的 `patterns` 字段，例如）：

- `list-page`：
  - `target: page`
  - `config.regions: ["filters", "toolbar", "table"]`
- `filter-bar`：
  - `target: filters`
  - `config.entity: Order`
  - `config.fields: ["status", "createdAt", "buyerName"]`
  - `inlineSearch: true`
- `toolbar-with-quick-edit`：
  - `target: toolbar`
  - `config.supportQuickEdit: true`
  - `config.supportExport: true`
  - `editableFields: ["remark"]`
- `table-with-server-filter`：
  - `target: table`
  - `config.entity: Order`
  - `config.columns`: 根据 Order 字段生成列配置初稿
  - `config.batchActions: ["export"]`
- `service-adapter-query`：
  - `config.entity: Order`
  - `config.resourceName: "orders"`
  - `config.operations: ["list","detail","update","export"]`
  - `config.hasPagination: true`
- `zustand-store-with-slices`：
  - `config.storeName: "order"`
  - `config.enableImmer: true`
  - `config.slices`: data/ui 等 slice 描述
- `crud-feature-skeleton`：
  - `config.entity: Order`
  - `config.routePath: "/orders"`
  - `config.enableQuickEdit: true`
  - `config.enableExport: true`
  - `config.enableDetailPage: true`

**节省了什么？**

- 开发者不再需要每次“凭经验”决定：要不要抽 Store、要不要写 Query、要不要写 adapter；  
- LLM 基于 Pattern 文档和 best-practice 约束，把常见 CRUD 场景自动映射到一套标准模式组合；
- 对未知场景，你只要解释业务，LLM 会用 Pattern 帮你选择技术落地路线。

## 5. 阶段三：Pattern → Template/snippet → Plan 草稿

**目标**：基于 Intent + Pattern 配置，生成 `.plans/order-management.plan.json` 草稿——一份可审阅的“出码施工图”。

### 5.1 LLM 需要知道什么？

LLM 角色可以称为「Plan Drafter」，system prompt 中需要挂载：

- 模板与片段索引：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/03-templates.yaml`
- 文件/目录约定：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/05-file-conventions.md`
- Pattern 的 roles 定义（上一阶段已加载）：
  - 如 service-adapter-query 中的 ServiceModule/AdapterModule/QueryHookModule 等；
  - zustand-store-with-slices 中的 StoreRoot/DataSlice/UISlice 等。

约束：

- 所有目标文件路径必须满足 file-conventions 中的后缀和目录要求；
- `templateId` 必须来自 `03-templates.yaml` 或 IMD 内部的模板 meta，不得随意捏造。

### 5.2 Plan 草稿示例

LLM 输出一个 Plan 草稿（不直接写盘，由 CLI 审核/执行），如：

```json
{
  "featureId": "order-management",
  "actions": [
    {
      "type": "createFile",
      "path": "features/order/services/order.service.ts",
      "patternId": "service-adapter-query",
      "role": "ServiceModule",
      "templateId": "tpl-service-layer",
      "params": {
        "entity": "Order",
        "resourceName": "orders",
        "operations": ["list", "detail", "update", "export"]
      }
    },
    {
      "type": "createFile",
      "path": "features/order/adapters/order.adapter.ts",
      "patternId": "service-adapter-query",
      "role": "AdapterModule",
      "templateId": "tpl-adapter-basic",
      "params": {
        "entity": "Order"
      }
    },
    {
      "type": "createFile",
      "path": "features/order/queries/order.query-keys.ts",
      "patternId": "service-adapter-query",
      "role": "QueryKeysModule",
      "templateId": "tpl-query-keys",
      "params": {
        "resourceName": "orders"
      }
    },
    {
      "type": "createFile",
      "path": "features/order/queries/use-order-list.hook.tsx",
      "patternId": "service-adapter-query",
      "role": "QueryHookModule",
      "templateId": "tpl-query-hook",
      "params": {
        "entity": "Order",
        "operation": "list"
      }
    }
  ]
}
```

类似的 action 会覆盖：

- Zustand Store 聚合根与 slices；
- 特性级测试骨架；
- IMD 里的页面/表格/筛选区/工具栏模板入口等。

**节省了什么？**

- 开发者不必再手动列出“一个完整特性需要哪些文件、在哪些目录、用哪些模板”；
- LLM 基于 Pattern.roles + file-conventions + 模板索引，自动生成一个可以审查的施工计划；
- CLI 可以在此基础上做 schema 校验、冲突检测和 diff 预览。

## 6. 阶段四：执行 Plan + LLM 填 slot + 增量重构

**目标**：在执行 Plan 时，让 CLI/模板负责结构，LLM 只对需要经验判断的“slot”负责；需求变更时，利用 Intent/Plan diff 做增量重构。

### 6.1 执行阶段：结构由模板决定，LLM 只填局部

执行 `imd intent apply order-management` 时：

- CLI 对每个 `createFile` action：
  - 读取对应模板文件（如 `/Users/yoyo/projj/git.imile.com/ux/best-practice/snippets/services/entity.service.ts`）；
  - 拼出固定部分结构（import、函数签名、基本流程）；
  - 对标记为 “由 LLM 填充” 的 slot（列配置、表单字段校验、自定义渲染函数等），调用 LLM；
- LLM 在 slot 内生成代码时必须遵守：
  - `rules-registry` 中的相关规则：`/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/01-rules-registry.yaml`
  - 对应 guide（状态管理、组件设计、错误处理等）。

### 6.2 维护阶段：Intent diff → Plan diff → 局部代码 diff

需求变更示例：

- “导出时需要多过滤一个字段”；  
- “快速编辑里多一个可编辑字段”；  
- “列表上增加新的状态枚举”。

推荐流程：

1. 开发者只更新 Intent：
   - 在 `domain.entities` 或 `domain.apis` 中增加/修改字段；
   - 调整 `patterns.config` 中 filter-bar/table-with-server-filter/toolbar-with-quick-edit 的参数。
2. 调用类似命令：`imd intent plan-diff order-management`：
   - LLM 对比旧 Intent / 新 Intent + 旧 Plan；
   - 输出一个“增量 Plan”：只包含需要新增/修改/删除的 action。
3. CLI 执行增量 Plan：
   - 只对受影响的模板和 slot 生成 patch；
   - LLM 再次只在 slot 内调整局部代码。

**节省了什么？**

- 你不用亲自搜索“这次需求影响了哪些 service/adapter/query/store/组件”；
- LLM 利用结构化 diff（Intent + Plan + Log），做自己最擅长的事：  
  在约束下提出一组三明治式的 patch 建议，而不是随机重写整段代码。

## 7. 渐进落地建议（订单 CRUD 试点）

要验证这套东西是不是“看起来很美”，建议从最小闭环开始：

1. **只做阶段 1 + 2 的 PoC**：
   - 从自然语言需求出发，看 LLM 能否稳定生成高质量的 Intent + patterns.config；
   - 衡量指标：开发者用 LLM 辅助写 Intent 所花的时间 vs 手工写结构 +查规范的时间。

2. **扩展到阶段 3：Plan 草稿**：
   - 让 LLM 在 best-practice 的模板索引与 file-conventions 约束下生成 Plan 草稿；
   - 先不执行，只靠人工审查 Plan 是否合理。

3. **最后才引入阶段 4：模板执行 + slot 填充**：
   - 挑一个订单 CRUD 场景，让 CLI + 模板 + LLM 合作真正生成一套骨架；
   - 对比从零手写订单 CRUD 所需时间与质量。

通过这种渐进方式，可以清楚地看到：

- Intent / Pattern / Template / Plan 这些资产在 LLM 协同下是否真的减少了你的心智开销；
- 哪些 Pattern/模板是“高收益”的，值得继续沉淀；哪些是“噪音”，应该删减或重写。

最终，如果在多个典型场景（CRUD、审批流、工作台等）里都证明“只要把需求讲清楚，LLM + 意图驱动流水线就能帮你稳稳铺出 70% 的骨架”，  
这套平台才配得上被称为“ai 时代下以意图为中心的新一代低代码基座”。

## 8. UI/UX 映射：LLM 在平台界面中的位置

> 本节将上述四个阶段，与平台 UI 中的三个核心工作区对应起来。  
> UI 草图详见：`/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/06-platform-ui-and-interactions.md`。

### 8.1 Intent Studio：自然语言 → Intent（阶段一）

对应 `06-platform-ui-and-interactions.md` 中的 **Intent Studio** 区域。

- 左侧：Intent 列表（场景列表），右侧：Intent Editor 表单 + YAML 预览。
- LLM 入口：
  - 在“新建场景”向导的每一步（Goals / Scene / Domain / Flows）提供 **[用 AI 补全]** 按钮：
    - 用户先写一两句自然语言说明；
    - LLM 根据当前部分 + 既有上下文补全结构化字段；
    - 结果以可编辑表单和 YAML 预览呈现。
  - 在顶部提供 **[从说明生成 Intent]**：
    - 用户粘贴需求/PRD 摘要；
    - LLM 直接生成一份完整 Intent 草稿，填入编辑器。
- Intent Studio 是“阶段一”的主要 UI 承载地：  
  LLM 在这里主要担任 **Intent Builder**，帮助把自然语言需求转成结构化 YAML。

### 8.2 Intent Studio：推荐与配置 Pattern（阶段二）

同样在 Intent Studio 中，Pattern 相关交互通过“模式推荐”和“模式配置”页签呈现。

- 模式推荐：
  - 在 Intent 概览/场景结构页底部有按钮：
    - `[ 推荐模式 ] [ 手动选择模式 ] [ 查看已绑定模式 ]`
  - 点击“推荐模式”：
    - 前端调用 `/patterns/match`；
    - 后端由 LLM 充当 **Pattern Advisor**，根据当前 Intent 摘要返回候选模式列表及解释。
  - UI 在右侧弹出模式候选侧栏，每个卡片包括：
    - 模式名称 / 摘要 / 适用场景 / 风险提示 / docRefs 链接。
  - 用户勾选模式后，写回 Intent 的 `patterns` 字段。
- 模式配置：
  - 被选中的每个模式，在“模式配置” tab 中有对应的配置表单；
  - 表单结构由 Pattern 的 `paramsSchema` / `uiSchema` 决定；
  - 每个配置块内提供 **[用 AI 推荐]**：
    - LLM 根据 Intent 的 domain 信息（实体字段、接口）和 best-practice 规则，填充默认列集合/筛选字段/操作集等。
- 这一步的 UI 体验可以概括为：
  - 开发者在同一个编辑器里，逐步把“场景结构 → 模式选择 → 模式参数”补齐；
  - LLM 不替代决策，只提供“推荐模式”和“推荐参数”的快捷按钮。

### 8.3 Pattern Studio：沉淀/演进 Pattern（底座准备）

对应 `06-platform-ui-and-interactions.md` 中的 **Pattern Studio**。

- 主要面向：前端架构师 / 平台前端。
- UI 功能：
  - 模式列表视图：显示已有模式（包括新加的 service-adapter-query、zustand-store-with-slices、crud-feature-skeleton 等）；
  - 模式详情：展示 problem/applicability/composition/paramsSchema/uiSchema/docRefs 等；
  - 引用信息：列出当前模式被哪些 Intent / Plan 使用。
- LLM 在 Pattern Studio 中可以提供的能力：
  - 从现有代码反推 Pattern 草稿（比如分析多个类似 CRUD 特性，提取公共 roles + paramsSchema）；
  - 根据 best-practice 文档，给出 paramsSchema / uiSchema 初稿，由架构师审核修改；
  - 提示演进影响（某模式修改后，会影响哪些 Intent/Plan）。
- Pattern Studio 是“静态经验库”的编辑界面，为阶段二和阶段三提供模式定义支撑。

### 8.4 Generation Console（Plans）：Plan 草稿与执行（阶段三 + 四）

对应 `06-platform-ui-and-interactions.md` 中的 **Generation Console / Plans**。

- Plans 列表视图：
  - 按 Intent 分组显示 Plan 历史：`order-management.plan.json` 等；
  - 每条 Plan 显示生成时间、状态（草稿/已执行/部分执行）、说明。
- Plan 详情视图：
  - 上方：Intent 摘要 + 已选模式列表；
  - 中间：action 列表（类似表格形式）：
    - path / type / patternId / templateId / 关键 params 简要；
    - 每行支持查看详细 params 与对应 Pattern / Template Meta；
  - 侧栏：LLM 提供的 Plan 解读：
    - “本次 Plan 将新建 8 个文件，其中服务层 2 个、Query 2 个、Store 2 个、测试文件 2 个”；
    - “不会修改现有文件，风险较低”。
- 交互：
  - 用户可以在 UI 中取消某些 action（例如暂不生成测试），或调整部分 params；
  - 点击 `[ 用 AI 解释本 Plan ]`：LLM 以自然语言解释 Plan 的整体影响和潜在风险。

执行视图：

- 执行 Plan 时，UI 展示实时进度：
  - 每个 action 的执行状态（成功 / 失败 / 跳过）；
  - 失败时显示错误信息和 LLM 的“可能原因解释 + 修复建议”。
- 执行完成后：
  - 提供“查看执行日志 JSON”“在 Git 中对比 diff”等链接；
  - LLM 可以生成执行结果摘要，例如：
    - “本次执行新增 8 个文件，无修改/删除；后续建议补充以下手工逻辑：……”

在这一工作区中，LLM 的主要角色是：

- Plan Drafter：在后端生成 Plan 草稿（阶段三）；
- Plan Interpreter：在前端为开发者解释 Plan 和执行结果（阶段四）。

### 8.5 整体交互链路小结（UI + LLM）

综合来看，整条链路在 UI/UX 层的映射是：

- **Intent Studio**
  - 用户：前端业务开发；
  - LLM 角色：Intent Builder + Pattern Advisor；
  - 关键操作：自然语言 → Intent；Intent → Pattern 选择与配置。
- **Pattern Studio**
  - 用户：前端架构师 / 平台前端；
  - LLM 角色：Pattern Author Assistant；
  - 关键操作：从代码/文档沉淀模式，维护 paramsSchema/uiSchema/docRefs。
- **Generation Console（Plans）**
  - 用户：前端业务开发（偶尔架构师参与审阅）；
  - LLM 角色：Plan Drafter + Plan Interpreter；
  - 关键操作：Pattern → Plan 草稿；Plan 执行结果解读与增量重构建议。

这样的 UI/UX 设计，可以保证：

- 开发者始终在“场景/模式/计划”三个可见视图中工作，不会被 YAML 细节淹没；
- LLM 的能力被包装成具体按钮和侧栏解释，而不是隐形“黑箱决策”；
- Intent / Pattern / Plan 这三类资产既对 LLM 友好（结构化、可解析），也对人类友好（可视化、可审阅）。
</file>

<file path="specs/intent-driven-ai-coding/v1/10-best-practice-effect-integration-roadmap.md">
---
title: best-practice 仓库与 Effect/Flow 行为层的整合建议
status: draft
version: v1
---

> 本文不是对 IMD 仓库的直接实现要求，而是一份面向 `/Users/yoyo/projj/git.imile.com/ux/best-practice` 的后续优化建议。  
> 目标是：在不干扰现有 CRUD 最佳实践的前提下，为“意图驱动 + Flow/Effect 行为层”铺好必要的路。

## 1. 前提与目标

- 当前 best-practice 仓库已经定义了：
  - 文件类型与命名规范（`05-file-conventions.md`）；
  - 状态管理与 Query 规范（Zustand + TanStack Query）；
  - 服务层 / 适配器 / Query Hook 的分层与模板；
  - 规则注册表与 LLM 模板索引（`llms/01-rules-registry.yaml`、`03-templates.yaml`）。
- Intent-driven 规划希望：
  - 将复杂行为（导出、审批、批量任务等）提升为 Intent.runtimeFlows；
  - 用 Flow DSL → Flow AST → Effect 程序 承载“行为层”的 SSoT；
  - 让平台和 LLM 能在行为层安全地生成、解释和重构逻辑。

目标：让 best-practice 在**行为层**对 Effect/Flow 友好，而不会要求所有日常 CRUD 都改成 Effect 风格。

## 2. 建议一：新增“行为层（Effect/Flow）”规范文档

在 best-practice 仓库中新增一篇规范，例如：

- 路径建议：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/02-principles-and-architecture/XX-effect-behavior-layer.md`
- 内容要点：
  - 定义“行为层”的范围：
    - 跨 Service / 跨 Store / 跨页面的流程；
    - 需要统一审计/监控/回放的复杂行为；
    - 需要由平台/LLM 长期维护的流程（出现在 Intent.runtimeFlows 中）。
  - 约定：
    - 对这类行为，推荐用 Effect 程序表达，而不是在组件或单一 Store 中散落 async 逻辑；
    - Flow DSL（在 IMD 仓库中定义）可作为声明层，Effect 程序作为实现层；
    - Effect 可以是 effect-ts，也可以是精简版 `Effect<R, E, A>`，但接口形状应与 Intent 规划对齐。
  - 文件/命名建议：
    - 为行为层引入统一的文件后缀，例如 `*.flow.ts`；
    - 这些文件只定义 Effect 工作流（不直接依赖 React），作为 Intent.runtimeFlows 对应的运行时实现载体。
  - 明确“不强制”：
    - 对普通 CRUD 行为，不强制使用 Flow/Effect；
    - 行为只有在“进入 Intent.runtimeFlows”时才需要考虑 Effect 化。

## 3. 建议二：为服务层补充 Effect 版签名（契约层）

在现有 API 集成与服务层指南的基础上，增加 Effect 视角的接口示例：

- 参考现有文档：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/03-api-integration-guide.md`
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/docs/03-development-guides/11-adapter-pattern-guide.md`
- 补充内容：
  - 在服务层章节中，增加一节“Effect 版本接口示例”：
    - 例如：
      ```ts
      // 逻辑层行为
      type CreateOrderEffect = Effect<OrderEnv, CreateOrderError, OrderId>

      interface OrderWorkflowService {
        createOrder: (input: CreateOrderInput) => CreateOrderEffect
      }
      ```
  - 指明：
    - 这种 Effect 形式主要用于平台 pipeline、Flow 解释器和测试；
    - 业务组件可以通过简单 Hook 封装使用，不需要直接接触 Effect 类型。

这样可以在不破坏现有调用方式的前提下，为 Intent/Flow 层提供稳定的行为契约。

## 4. 建议三：在 rules-registry 中引入“行为层”标签

当前规则注册表位于：

- `/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/01-rules-registry.yaml`

可以在 `catalog.tagDescription` 中新增一类标签，例如：

- `behavior-flow`：行为编排与 Flow/Effect 层规则；

并逐步为以下类型的规则补充或新增条目：

- 规则示例（构想）：
  - “复杂导出逻辑必须通过统一 Flow/Effect 层表达（禁止在多个组件中散落导出请求）”；
  - “跨多 Store 的状态变更（例如提交后清理多个 Slice）应通过行为层完成，而不是在组件中逐个调用 setXXX”；
  - “审批类流程的状态流转（同意/拒绝/转交）应抽象为 Effect 工作流，以便统一审计和回放”。

这样 LLM 在加载 rules-registry 时，就能识别哪些规则专门约束“行为层”。

## 5. 建议四：为 Flow/Effect 补充 snippet 与模板

在 best-practice 的 snippet/template 体系中，为行为层预留一些基础模板：

- 参考现有模板索引：
  - `/Users/yoyo/projj/git.imile.com/ux/best-practice/llms/03-templates.yaml`
- 新增模板方向：
  - Flow/Effect 工作流骨架：
    - 如“导出 Flow”的 Effect 模板；
    - “审批 Flow”的 Effect 模板；
  - Flow DSL → Hook 代码生成模板：
    - 将 FlowAst 生成 `useExportXxx` / `useApprovalAction` 等 Hook 的字符串片段；
  - 测试模板：
    - 为 Effect 工作流提供标准测试片段（注入 fake Env、断言调用顺序）。

这些模板可用于：

- 平台内在出码时复用；
- LLM 在生成/重构 Flow 相关代码时引用，避免“凭空+自由发挥”。

## 6. 建议五：落一个小范围试点场景

在 best-practice 中选择一个有代表性的场景做行为层 PoC，例如：

- “订单导出” 或 “费用审批操作”：
  - 现状：散落在多个组件/Store 的导出/审批逻辑；
  - 目标：
    1. 用 Flow DSL（在 IMD 仓库定义）描述行为；
    2. 在 best-practice 中为该 Flow 写一个 Effect 实现（工作流服务）；
    3. 更新规则/模板/snippets，让 LLM 可以：
       - 从 Flow DSL 生成 Effect 工作流草稿；
       - 从现有代码反向提取 Flow/Effect 草稿。

通过这一小范围试点，可以验证：

- Effect/Flow 行为层是否真的让行为更容易重构与解释；
- LLM 是否因为有了 Flow/Effect 契约，能在行为层做更可信的修改；
- 把这类行为纳入 Intent.runtimeFlows 是否值得在更多场景推广。

## 7. 渐进迁移策略（避免一次性重写）

为了避免对现有 best-practice 和业务项目造成过大冲击，建议：

1. **先文档，后代码**
   - 先在 docs/ 和 llms/ 中增加行为层规范、规则和模板索引；
   - 不立刻改动现有服务层实现。
2. **先 Flow/Effect PoC，后规范升级**
   - 在一两个场景（导出/审批）中实现 Flow + Effect 示范；
   - 根据实践结果调整行为层规范和规则。
3. **最后再考虑将更多服务/动作提升为 Effect-first**
   - 当行为层的价值在多个场景得到验证时，再逐步将更多服务/动作的“推荐形态”升级为 Effect-first；
   - CRUD 与轻量逻辑仍可保留 async/Hook 形式，不必强行统一。

通过这种渐进方式，best-practice 可以在不打断现有开发体验的前提下，  
为未来的 Intent/Flow/Effect 平台打好行为层的基础。
</file>

<file path="specs/intent-driven-ai-coding/v1/services.md">
---
title: 标准服务接口约定（Services）
status: draft
version: v1
---

> 本文列出在 Pattern / Template / Intent (runtimeFlows) 中会出现的标准 Service ID，  
> 这些 ID 对应未来 TS 层的 Service 接口或 Effect Tag，用于统一依赖关系和行为编排。

## 1. 列表相关服务

- **FilterService**
  - 来源：
    - 由 `filter-bar` 模式中的 `FilterStore` 角色提供。
    - `table-with-server-filter` 的 `ListQueryHook` 依赖。
  - 职责：
    - 维护当前筛选条件（status/date 等）；
    - 提供读取当前筛选状态的能力（`getCurrentFilters`）。

- **TableUiStateService**
  - 来源：
    - 由 `table-with-server-filter` 模式中的 `TableStore` 角色提供。
  - 职责：
    - 维护表格 UI 状态（页码、每页条数、排序、列显隐等）；
    - 提供读取当前表格 UI 状态的能力（`getCurrentState`）。

- **ListQueryService**
  - 来源：
    - 由 `table-with-server-filter` 模式中的 `ListQueryHook` 角色提供。
  - 职责：
    - 基于 FilterService 与 TableUiStateService 提供的状态，发起列表请求；
    - 为表格渲染提供数据源（items/total/loading/error 等）。

- **PageShellService**
  - 来源：
    - 由 `list-page` 模式中的 `PageComponent` 角色提供。
  - 职责：
    - 提供统一的列表页壳（filters/toolbar/table 布局与样式容器）。

## 2. 导出与快速编辑相关服务

- **ExportService**
  - 来源：
    - 由 `table-with-server-filter` 模式中的 `ExportService` 角色提供（可选）。
  - 职责：
    - 将当前筛选条件和表格状态转换为导出请求载荷；
    - 提交导出任务。

- **QuickEditService**
  - 来源：
    - 由 `toolbar-with-quick-edit` 模式中的 `QuickEditComponent` 角色提供（可选）。
  - 职责：
    - 提供打开/关闭快速编辑界面、提交快速编辑变更的能力；
    - 通常依赖实体的更新接口（如 updateOrder）。

## 3. 通用服务（示意）

- **NotificationService**
  - 未来用于在 Flow DSL 中展示成功/失败通知：
    - `NotificationService.show({ type, message })`。

这些 Service ID 在 Pattern 的 `provides/requires`、Template Meta 的实现标签，以及 Intent 的 `runtimeFlows.pipeline.call` 中会多次出现。  
统一命名和职责划分，可以为 Effect/DI 框架提供清晰的接口契约。 

示例参考：

- 运行时 Service 接口与简单内存实现示例（含极简 Flow 执行器）：
  - `/Users/yoyo/projj/git.imile.com/ux/imd/docs/specs/intent-driven-ai-coding/v1/poc/model/runtime-services.example.ts`

## 4. Service 与 Effect 程序的关系（示例）

在出码前平台内核中，我们推荐将行为逻辑建模为 Effect 程序（可采用 effect-ts 或 v1/poc/effect.ts 中的简化类型），
并让 Service 方法以 Effect 形式暴露。示意接口（省略具体 Env/E 类型）：

```ts
// 示例：FilterService 在 Effect 语境下的形态
interface FilterService<Filters> {
  getCurrentFilters: Effect<Env, never, Filters>
  setFilters: (patch: Partial<Filters>) => Effect<Env, never, void>
  resetFilters: Effect<Env, never, void>
}

interface TableUiStateService {
  getCurrentState: Effect<Env, never, TableUiState>
}

interface ExportService<Filters> {
  submitExportTask(args: { filters: Filters; columns: string[] }): Effect<
    Env,
    ExportError,
    void
  >
}
```

在 Flow DSL 中写下的：

```yaml
- call: FilterService.getCurrentFilters
  as: filters
```

在解释执行时会被转换为类似：

```ts
const flowEffect: Effect<Env, never, void> = pipe(
  FilterService.getCurrentFilters,
  Effect.bindTo('filters'),
  // ...
)
```

注意：

- 对普通 CRUD 场景，业务代码可以继续使用简单的 async/await + Hook；  
- 一旦某个行为被提升到 Intent.runtimeFlows，并希望由平台和 LLM 长期维护与重构，推荐在平台内核中为其生成/维护 Effect 版本。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/behavior-and-flow.md">
---
title: 行为/流程意图（Behavior & Flow Intent）
status: draft
version: 2
---

> 本文聚焦 Behavior & Flow 意图及其与 Flow DSL、Effect 运行时的关系。

## 1. 定义

行为/流程意图回答：

> “在某个触发条件下，系统需要执行哪些业务步骤、调用哪些服务、如何处理结果？”

典型例子：

- 导出订单：
  1. 从 FilterStore 读取当前筛选条件；
  2. 从 TableUiState 读取当前可见列；
  3. 调用 ExportService.submitExportTask；
  4. 成功后提示并写入导出记录。

## 2. FlowIntent Schema 草图

```ts
interface FlowStepIntent {
  kind: 'callService' | 'branch' | 'delay' | 'parallel'
  serviceId?: string
  method?: string
  input?: Record<string, unknown>
  outputAlias?: string
  when?: string // 条件表达式，可引用 outputAlias
}

interface FlowIntent {
  id: string
  trigger: { source: string; event: string } // 与 InteractionIntent 对齐
  pipeline: FlowStepIntent[]
}

interface BehaviorIntent {
  flows: FlowIntent[]
}
```

在 IntentSpec v2 中：

```ts
interface IntentSpecV2 {
  // ...
  behavior?: BehaviorIntent
}
```

## 3. Effect-ts 在 v2 中的定位

Effect-ts 不再被视作“一个单独的技术选型”，而是：

> **Behavior & Flow 意图的标准运行时实现** —— 将 FlowIntent AST 映射为可组合、可测试、可观测的程序。

具体职责：

- 作为 Flow DSL 的“执行引擎”：
  - FlowIntent → FlowAst → Effect 程序（例如 `exportOrdersFlow: Effect<Env, Error, void>`）；
  - 提供组合、错误处理、重试、并行等高阶能力。
- 作为「约束/质量意图」的落地点之一：
  - 在 Effect 层实现 timeout/retry/circuit breaker 等性能与可靠性约束；
  - 通过中间件统一接入日志/追踪/审计。
- 在 Code Structure Intent 中：
  - 将 `.flow.ts` 模块作为一种“行为模块”纳入目录结构规范；
  - 与 best-practice 中的 Effect runtime 模块对齐（例如 `src/shared/effects/*`）。

简而言之：

- **Behavior & Flow Intent = 业务流程线稿**；
- **Flow DSL = 结构化表达**；
- **Effect-ts = 运行时程式化润色与执行层**。

## 4. 与其它意图层的边界

- 与 InteractionIntent：
  - Interaction 决定“什么时候触发 Flow”；
  - Behavior & Flow 决定“Flow 内部做什么”。
- 与 Data & State：
  - Flow 步骤可以读取/写入 state（例如 FilterStore/TableUiState）；
  - 但实体结构/状态来源在 Data & State Intent 中定义。
- 与 Code Structure：
  - `.flow.ts` 文件由 Plan/Template 在 Code Structure 意图下生成/更新；
  - v2 要求 `.flow.ts` 的组织遵循 best-practice 仓库的行为模块规范。

## 5. 设计边界：避免 Behavior & Flow 变成业务代码 DSL

Behavior & Flow Intent 的目标是表达“业务步骤链”与“服务调用关系”，而不是把所有控制流与错误处理细节都塞进 Intent。

### 5.1 本层允许/不允许的内容

- 允许（What）：
  - 哪个 Use Case / 事件触发哪个 Flow（引用 Interaction 事件）；
  - Flow 步骤级的业务语义：调用哪个领域服务、按什么顺序、基于什么条件分支；
  - 引用 Data & State 中的实体/API（例如某步骤输入/输出实体）。
- 不允许（How）：
  - 低层次控制流细节（复杂表达式、多重嵌套条件、循环等）；
  - 具体 Effect 组合方式（flatMap/gen/all 等）；
  - 日志/重试/超时/熔断等运行时细节（应由 Constraint + Layer 落地）。

示意对比：

```ts
// ✅ Good：Intent 层 Flow 步骤
pipeline: [
  { kind: 'callService', serviceId: 'FilterService', method: 'getCurrentFilters', outputAlias: 'filters' },
  { kind: 'callService', serviceId: 'ExportService', method: 'submitExportTask', input: { filters: '{{filters}}' } },
]

// ❌ Bad：把 Effect 细节写进 Intent
pipeline: [
  {
    kind: 'callService',
    serviceId: 'ExportService',
    method: 'submitExportTask',
    retryPolicy: { maxRetries: 3, backoffMs: 1000 }, // ← 应由 Constraint/Layer 配置
    effectImpl: 'Effect.gen(function*() { ... })', // ← 具体 Effect 代码不应出现在 Intent
  },
]
```

### 5.2 Minimal FlowIntent 建议

一个可用的 FlowIntent 通常至少包含：

- `id` + 触发事件（eventId 或 source/event）；
- 1–N 个步骤，每个步骤聚焦一个领域操作（调用服务、条件分支等）；
- 对关键输入/输出起别名（便于后续步骤引用）。

复杂的错误处理/重试策略可以在后续迭代中，通过 Constraint 意图 + Flow→Effect 编译器予以增强，而不必从第一天就写进 Intent。

## 6. LLM 与 Flow 的协作

在 v2 中，LLM 与 FlowIntent 的交互主要有三类：

1. 从自然语言/线稿生成初版 FlowIntent（线稿级行为意图）；
2. 从 FlowIntent 生成 Flow DSL + `.flow.ts` Effect 程序骨架；
3. 基于约束/质量意图，对现有 Flow 提出优化建议（重试/幂等/超时策略等）。

平台 UI 应为 Behavior & Flow 提供：

- 一种适合表达“步骤链”的视图（简化画布或步骤列表）；
- 一个 Effect 视图（`.flow.ts` 只读预览 + 可编辑模式）；
- 与运行时日志/监控的联动，用于调试 Flow 行为。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/code-structure.md">
---
title: 工程结构意图（Code Structure Intent）
status: draft
version: 2
---

> 本文定义 Code Structure 意图：如何将前端意图映射到模块/目录/文件，并与 Template/Plan/best-practice 协同。

## 1. 定义

工程结构意图回答：

- “这个功能模块分成哪些文件/模块？”
- “这些模块的职责边界如何？”
- “目录结构如何映射到团队通用规范？”

这层意图决定了：

- Plan 会生成哪些文件；
- Template 中包含哪些骨架代码；
- best-practice 仓库中有哪些可复用基线。

## 2. CodeStructureIntent Schema 草图

```ts
interface ModuleFileIntent {
  kind: 'page' | 'component' | 'store' | 'service' | 'query' | 'hook' | 'flow'
  path: string
  templateId?: string
  patternId?: string
}

interface CodeStructureIntent {
  featureId: string
  files: ModuleFileIntent[]
}
```

在 PlanSpec v2 中：

```ts
interface PlanActionV2 {
  id: string
  type: 'create-file' | 'modify-file' | 'append-snippet'
  path: string
  templateId: string
  patternId?: string
  intentLayers?: IntentLayer[] // 通常包含 'code-structure'，也可能附带 'view'/'behavior'
  params: Record<string, unknown>
}

interface PlanSpecV2 {
  id: string
  intentId: string
  version: string
  actions: PlanActionV2[]
}
```

CodeStructureIntent 通常通过 Plan + Template 的组合来落地，不一定直接出现在 IntentSpec 中，但 IntentSpec 应保留对 Plan 的引用。

## 3. 与 best-practice 的协同

best-practice 仓库定义了：

- 目录结构（apps/packages/features/shared 等）；
- 状态管理拆分规则（store/slices/selectors）；
- service/adapter 模式与命名约定；
- 测试/Story/Doc 文件的放置方式。

v2 要求：

- CodeStructureIntent 必须以 best-practice 为基线；
- TemplateSpec 的 path/role 设计要与 best-practice 的结构保持一一对应。

## 4. 线稿级工程结构表达

为了让开发者以“线稿方式”表达工程结构意图，平台可以提供：

- 模块骨架编辑器：
  - 以树/表格形式列出模块和文件（page/components/store/service/query/flow 等）；
  - 支持从模板片段（feature 模板）快速添加；
  - 生成 CodeStructureIntent 与 Plan 草稿。
- LLM 辅助：
  - 开发者用自然语言描述模块划分，LLM 生成 CodeStructureIntent 初稿；
  - 可根据 best-practice 建议拆分或合并某些文件。

## 5. 与其它意图层的关系

- Layout/View/Interaction/Behavior/Data 决定“这块功能需要什么”；
- Code Structure 决定“要用哪些模块/文件来实现这些需求”；
- Plan/Template/Flow/Store/Service 等具体文件是 Code Structure Intent 的实现细节。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/constraints-and-quality.md">
---
title: 约束与质量意图（Constraint & Quality Intent）
status: draft
version: 2
---

> 本文定义横切的约束/质量意图。它不会单独生成代码，而是约束其它意图层（Layout/View/Interaction/Behavior/Data/CodeStructure）的实现与运行时行为。

## 1. 定义

约束/质量意图回答：

- 性能：
  - 列表最多展示多少条数据？
  - 是否需要分页/虚拟滚动？
- 安全：
  - 是否涉及敏感数据？
  - 是否必须鉴权、脱敏？
- 兼容性：
  - 是否必须遵守“Never break userspace”？
  - 是否存在历史接口或老版本客户端？
- 可观测性：
  - 是否必须记录审计日志？
  - 是否需要 tracing/metrics？

## 2. ConstraintIntent Schema 草图

```ts
interface ConstraintIntent {
  performance?: {
    maxItemsPerPage?: number
    latencyBudgetMs?: number
    requireVirtualScroll?: boolean
  }
  safety?: {
    requireAuth?: boolean
    sensitiveFields?: string[]
  }
  compatibility?: {
    neverBreakUserspace?: boolean
    legacyApis?: string[]
  }
  observability?: {
    requireAuditLog?: boolean
    tracing?: boolean
    metrics?: boolean
  }
}
```

可以作为 metadata 附着在：

- IntentSpecV2.constraints；
- PatternSpecV2.constraints；
- PlanSpecV2.constraints；
- FlowIntent/Effect runtime 的配置中。

## 3. Effect-ts 与约束意图

Effect-ts 是实现约束意图的重要位置：

- 在行为/流程层：
  - 使用 Effect 组合来实现重试/超时/circuit breaker；
  - 为敏感操作统一注入审计日志与 tracing。
- 在 Code Structure 层：
  - 将通用中间件（性能/安全/可观测性）封装为可复用的 Effect 模块；
  - 平台从 ConstraintIntent 中生成对应的 Effect 组合骨架。

## 4. LLM 的角色

LLM 可以：

- 根据 ConstraintIntent 审查现有 Intent/Pattern/Plan/Flow，指出潜在风险（如分页缺失、未鉴权接口）；
- 生成或调整 Effect/Plan 以满足这些约束（例如加上分页、增加审计调用）。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/data-and-state.md">
---
title: 数据/状态意图（Data & State Intent）
status: draft
version: 2
---

> 本文定义 Data & State 意图，并说明其与 Pattern.dataContract、状态管理规范的关系。

## 1. 定义

数据/状态意图回答：

- “系统中有哪些实体，它们的字段结构和含义是什么？”
- “界面上的表单/筛选字段如何映射到实体/接口？”
- “状态存在哪里，由谁负责维护生命周期？”

## 2. DataStateIntent Schema 草图

```ts
interface EntityFieldIntent {
  name: string
  type: 'string' | 'number' | 'enum' | 'date' | 'boolean' | string
  enumValues?: string[]
  required?: boolean
  desc?: string
}

interface EntityIntent {
  name: string
  fields: EntityFieldIntent[]
}

interface ApiIntent {
  name: string
  path: string
  method: 'GET' | 'POST' | 'PATCH' | 'DELETE' | string
  params?: Record<string, string>
  returns?: string
}

interface StateSourceIntent {
  id: string
  kind: 'react-query' | 'zustand' | 'local'
  entity: string
  desc?: string
}

interface DataStateIntent {
  entities: EntityIntent[]
  apis: ApiIntent[]
  stateSources?: StateSourceIntent[]
}
```

在 IntentSpec v2 中：

```ts
interface IntentSpecV2 {
  // ...
  data?: DataStateIntent
}
```

## 3. Pattern 与 Data & State

很多 Pattern 会对数据/状态提出要求：

- `table-with-server-filter`：
  - 需要一个支持分页/筛选的 API（listOrders）;
  - 至少需要某些字段（id/status/...）；
  - 列表数据可由 React Query 管理，筛选条件通过 Store 管理。

在 PatternSpec v2 中，这些要求可通过 `dataContract` 和 `paramsSchema` 表达：

```yaml
dataContract:
  entities:
    - Order
  requiredFields:
    - id
    - status
  apis:
    - listOrders
```

## 4. 状态管理与 best-practice

Data & State 意图与 best-practice 仓库中的内容强相关：

- 状态来源：
  - 服务器数据：React Query（查询 key 约定/缓存策略）；
  - 客户端 UI 状态：Zustand store + slices；
  - 局部状态：useState/useReducer。
- v2 要求：
  - 在 DataStateIntent 中显式声明 stateSources；
  - Pattern/Plan/Template 在生成代码时遵守状态管理约定（不随意引入新模式）。

## 5. 边界与反例：避免 Data & State 变成实现细节垃圾场

Data & State Intent 应聚焦“业务数据长什么样、放在哪一类状态源”，避免直接描述具体实现。

### 5.1 本层允许/不允许的内容

- 允许（What）：
  - 业务实体及字段结构（订单、任务、指标等），字段含义与校验规则；
  - 表单/筛选字段如何映射到实体/接口（哪些字段可筛选、是否必填等）；
  - 状态来源类型：服务器数据/客户端共享状态/局部 UI 状态（react-query/zustand/local 等）。
- 不允许（How）：
  - 具体 Hook 名称，例如 `useOrderListQuery`、`useOrderStore`；
  - 具体 state key 路径，例如 `orderStore.filters.status`；
  - React Query key 细节（`['orders', filters]` 等）；
  - adapter/selector 实现细节。

示意对比：

```ts
// ✅ Good：Intent 层 Data & State
entities: [
  {
    name: 'Order',
    fields: [
      { name: 'id', type: 'string', required: true },
      { name: 'status', type: 'enum', enumValues: ['PENDING', 'PAID', 'SHIPPED'] },
    ],
  },
]
apis: [{ name: 'listOrders', path: '/api/orders', method: 'GET' }]
stateSources: [
  { id: 'orderList', kind: 'react-query', entity: 'Order' },
  { id: 'orderFilters', kind: 'zustand', entity: 'Order' },
]

// ❌ Bad：实现细节泄漏到 Intent
stateSources: [
  {
    id: 'orderList',
    kind: 'react-query',
    entity: 'Order',
    hookName: 'useOrderListQuery', // ← 实现细节
    queryKey: "['orders', filters]", // ← 实现细节
    storePath: 'orderStore.list', // ← 实现细节
  },
]
```

这些实现信息应当由 best-practice 规范 + Template/Plan 生成或约束，而不是写死在 Intent 中。

### 5.2 Minimal Intent 建议

作为经验规则，一个 feature 的 DataStateIntent 至少应包含：

- 1 个以上实体（包含核心字段与描述）；
- 该 feature 涉及的主要 API（list/detail/update/export 等）；
- 至少列出主列表/主要表单使用的 stateSource 类型。

其它细节可以随着需求迭代逐步补充，保持核心结构稳定即可。

## 6. LLM 与 Data & State

LLM 可在此层做：

- 根据实体与 API 意图自动生成 paramsSchema（包括表单/筛选字段）；
- 建议合理的 stateSources（例如列表数据用 React Query，筛选条件用 Zustand）；
- 根据 Quality/Constraints 意图提出数据层优化建议（例如加上分页、限制返回字段等）。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/interaction.md">
---
title: 交互意图（Interaction Intent）
status: draft
version: 2
---

> 本文定义交互意图：用户操作与即时 UI 反馈，并说明其与行为/流程意图的边界。

## 1. 定义

交互意图只描述：

> “**用户做了什么动作，界面如何立即响应？**”

典型例子：

- 点击“新增”按钮 → 打开表单弹窗；
- 点击行右侧“编辑”图标 → 打开右侧详情抽屉并高亮该行；
- 悬停在状态标签上 → 显示 Tooltip；
- 切换 Tab → 切换内容区域。

不负责：

- 是否需要调用接口（Behavior & Flow）；
- 是否需要写入 store/刷新列表（Behavior & Data/State）。

## 2. InteractionIntent Schema 草图

```ts
interface UiEffectIntent {
  type:
    | 'openModal'
    | 'openDrawer'
    | 'closeModal'
    | 'toggle'
    | 'scrollIntoView'
    | 'selectRow'
    | 'none'
  target?: string // modalId/drawerId/elementId/rowId 路径等
}

interface InteractionEventIntent {
  id: string
  source: string // e.g. toolbar.addButton, table.row[0].editIcon
  event: 'click' | 'change' | 'hover' | 'keydown' | string
  uiEffect: UiEffectIntent
}

interface InteractionIntent {
  events: InteractionEventIntent[]
}
```

在 IntentSpec v2 中：

```ts
interface IntentSpecV2 {
  // ...
  interaction?: InteractionIntent
}
```

## 3. 与 Behavior & Flow 的关系

交互意图通常是 Behavior & Flow 的“触发源”：

- Interaction 描述 UI 层：点击按钮 → 打开弹框；
- Behavior & Flow 描述业务层：点击确认按钮 → 校验 → 调用 API → 成功后关闭弹框并刷新列表。

因此：

- `InteractionIntent.events[].source/event` 应与 FlowIntent.trigger.source/event 对齐；
- Flow DSL 不需要重复描述 UI 反馈（例如 openModal），只描述业务流程部分；
- UI 组件在实现时，可以直接根据 InteractionIntent 绑定事件与 UI Effect。

## 4. 交互形态示例（平台 UI）

在平台上，交互意图可通过以下视图表达：

- 事件列表：
  - 按组件/区域列出所有“可交互元素”；
  - 对每个元素声明事件类型与 UI 效果（openModal/close/scroll 等）。
- 小型“交互画布”：
  - 节点为 UI 元素（按钮/行/标签），连线表示交互关系；
  - 适合表达复杂页面上的显式交互链路。

LLM 可以：

- 根据 Layout/View 推断常见交互意图（例如列表上的行点击打开详情）；
- 根据已有 Flow 意图，提示“你是否需要在这里加一个 ‘loading’ 或 ‘禁用按钮’ 的交互”。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/layout.md">
---
title: 布局意图（Layout Intent）
status: draft
version: 2
---

> 本文定义布局意图的含义、边界与 Schema 草图，并给出示例。

## 1. 定义与边界

**布局意图（Layout Intent）只回答三个问题：**

1. 页面有多少个“语义区域”？
2. 这些区域如何排列、占比如何？（上/下/左/右、多列/单列）
3. 每个区域在业务上扮演什么角色？（filters/table/toolbar/metrics/detail 等）

不负责：

- 组件内部布局（表单项对齐方式、按钮间距）；
- 视觉风格（颜色、阴影、圆角）；
- 行为/数据/工程结构等其它意图层。

## 2. LayoutIntent v2 Schema 草图

```ts
interface LayoutRegionIntent {
  id: string
  label: string
  role:
    | 'filters'
    | 'toolbar'
    | 'table'
    | 'metrics'
    | 'detail'
    | 'sidebar'
    | 'footer'
    | string
}

interface LayoutIntent {
  layoutType: 'list-page' | 'workbench' | 'dashboard' | 'custom'
  regions: LayoutRegionIntent[]
  // 可选：用于 layout 引擎的结构树（由网格线稿或其它交互生成）
  tree?: LayoutNode
}
```

在 IntentSpec v2 中：

```ts
interface IntentSpecV2 {
  // ...
  layout: LayoutIntent
  // 其它意图层：view/interaction/behavior/data/codeStructure/constraints
}
```

## 3. 与 Pattern/Template 的关系

- layout Pattern（如 `workbench-layout`、`list-page-shell`）主要作用于 Layout + View 两层：
  - LayoutIntent 决定有哪些区域、如何排列；
  - Pattern 负责把这些区域映射为容器组件/Slot 结构；
  - Template 则生成实际的布局 Shell 代码（React 组件、Tailwind 类等）。
- 在 PatternSpec v2 中，layout 型模式应声明：

```yaml
intentLayers:
  - layout
  - view
```

## 4. 交互形态建议（不限定实现）

布局意图的表达形态可以有多种：

- 网格线稿（详见 v1 `design/layout.md`）：n×m 网格 + 区域上色 + 语义标签；
- 区域列表 + 预设布局模板：
  - 先选模板（如“列表页三段式”、“工作台三栏式”）；
  - 再为每个区域填 id/label/role；
- 直接在 Intent Studio 的 Layout 面板中编辑结构树（适合高级用户）。

平台应当：

- 为“线稿级”布局表达提供低门槛交互（画格子/选模板即可）；
- 为 LLM 提供结构化 LayoutIntent，避免模型从 Figma/截图中硬猜布局；
- 在 Plan/Template 层统一把 LayoutIntent 映射为布局组件骨架，而不是每次临时写布局代码。
</file>

<file path="specs/intent-driven-ai-coding/v2/design/view-and-component.md">
---
title: 视图/组件意图（View & Component Intent）
status: draft
version: 2
---

> 本文扩展“视图/组件意图”的含义与 Schema 草图，并说明与 Pattern、UI 设计系统的关系。

## 1. 定义

视图/组件意图回答：

1. 每个布局区域里用什么 UI 模式/组件？
2. 它们有哪些变体（密度、风格、是否带操作列等）？
3. 这些组件需要哪些“业务级”配置（例如列配置、筛选字段、是否支持导出）。

它不负责：

- 具体布局位置（交给 LayoutIntent）；
- 行为流程（调用哪个 service、业务步骤链）；
- 状态来源（react-query 还是 zustand）——这些属于 Data/State 与 Behavior 层。

## 2. ViewIntent Schema 草图

```ts
interface ViewComponentIntent {
  slot: string // 对应 LayoutIntent.regions[].id
  patternId: string // e.g. table-with-server-filter, filter-bar
  variant?: string // e.g. dense / card / compact
  propsIntent?: Record<string, unknown> // 视图层的参数化意图（列配置、按钮集合等）
}

interface ViewIntent {
  components: ViewComponentIntent[]
}
```

在 IntentSpec v2 中：

```ts
interface IntentSpecV2 {
  layout: LayoutIntent
  view?: ViewIntent
  // ... interaction/behavior/data/codeStructure/constraints
}
```

## 3. Pattern 在视图层的角色

UI/Pro Pattern（如 `table-with-server-filter`、`filter-bar`、`toolbar-with-quick-edit`）本质上是“视图意图 + 部分行为/数据意图”的模板：

- 在 PatternSpec v2 中，它们应声明：

```yaml
intentLayers:
  - view
  - behavior
  - data
```

- 并通过以下字段提供视图层配置：
  - `composition.roles`：视图组件和子组件的角色（TableComponent/ToolbarComponent/...）；
  - `paramsSchema`：视图层参数（列配置、是否显示重置按钮等）；
  - `uiSchema`：在“Pattern Studio / Intent Studio”中编辑这些参数时的表单控件配置。

## 4. 与 LayoutIntent 的配合

- LayoutIntent 定义了有哪些 slot，例如 `filters/toolbar/table/metrics`；
- ViewIntent 将 slot 绑定到具体 Pattern：

```yaml
layout:
  layoutType: list-page
  regions:
    - id: filters
      role: filters
    - id: toolbar
      role: toolbar
    - id: table
      role: table

view:
  components:
    - slot: filters
      patternId: filter-bar
      propsIntent:
        fields: [status, createdAt]
    - slot: toolbar
      patternId: toolbar-with-quick-edit
      propsIntent:
        supportExport: true
    - slot: table
      patternId: table-with-server-filter
      propsIntent:
        entity: Order
        columns: [...]
```

平台据此可：

- 渲染出对应的 UI 结构（在 Preview/Docs 中）；
- 为 Code Structure/Template 生成组件骨架文件；
- 为 LLM 提供完整上下文，生成合理的 JSX/TSX 代码。

## 5. 交互形态示例

在平台 UI 上，视图/组件意图可以通过以下方式表达：

- Pattern 选择器：
  - 按 Layout slot 展示候选 Pattern 卡片；
  - 用户选择某个 Pattern，右侧出现参数表单（由 uiSchema 驱动）。
- 组件树视图：
  - 展示 `Layout` + `View` 的组合成树状结构；
  - 支持为每个节点添加/删除子组件（如按钮、操作列）并更新 propsIntent。

## 6. 边界与示例：业务视图 vs 实现细节

View & Component Intent 关注“每个区域想要什么 UI 能力”，而不是具体实现方式。

### 6.1 本层允许/不允许的内容

- 允许（What）：
  - 每个 slot 使用哪种 Pattern（表格/筛选栏/工具栏/指标卡等）；
  - 业务级配置：显示哪些列、哪些字段可筛选、支持哪些操作按钮等；
  - 变体/密度/模式（dense/card/compact 等）。
- 不允许（How）：
  - 具体组件实现名（某个内部组件的 import 名称）；
  - props 微调细节（CSS 类、具体 gutter/spacing、像素级宽度）；
  - 复杂渲染逻辑（自定义 cell renderer 的代码）。

示意对比：

```yaml
# ✅ Good：Intent 层 View 配置
view:
  components:
    - slot: table
      patternId: table-with-server-filter
      propsIntent:
        entity: Order
        columns:
          - { key: id, title: 订单号, sortable: true }
          - { key: status, title: 状态 }
          - { key: createdAt, title: 下单时间, sortable: true }
        pagination: true

# ❌ Bad：把实现细节写进 View Intent
view:
  components:
    - slot: table
      patternId: table-with-server-filter
      component: OrderTableImpl        # ← 具体组件实现
      propsIntent:
        columns:
          - key: id
            title: 订单号
            width: 120                 # ← 像素级宽度
            cellRenderer: customRender # ← 自定义渲染函数名
```

这些实现细节应由 Pattern 实现、Template/Plan 或代码层负责。

### 6.2 Minimal ViewIntent 建议

一个可用的 ViewIntent 通常至少包含：

- 目标布局区域的 slot；
- 对应 Pattern 的 patternId；
- 该 Pattern 所需的最小业务配置（如主实体、核心字段/列、关键按钮）。

LLM 的角色：

- 读 Layout + 当前 ViewIntent，推荐合适的 Pattern / 变体；
- 根据数据意图（entities/apis）自动建议列配置、筛选字段等视图参数。
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/approval-flow/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export type ApprovalDecision = 'APPROVE' | 'REJECT'

export interface ApprovalContext {
  taskId: string
  comment?: string
}

export interface ApprovalService {
  decide: (input: ApprovalContext & { decision: ApprovalDecision }) => Promise<void>
}

export interface TaskService {
  refreshList: () => Promise<void>
}

export interface AuditService {
  record: (input: { taskId: string; decision: ApprovalDecision; comment?: string }) => Promise<void>
}

export interface ApprovalEnv extends BasePlatformEnv {
  ApprovalService: ApprovalService
  TaskService: TaskService
  AuditService: AuditService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/approval-flow/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { ApprovalDecision, ApprovalEnv, ApprovalContext } from './env'

export const approvalFlow =
  (ctx: ApprovalContext, decision: ApprovalDecision): Effect<ApprovalEnv, never, void> =>
  async env => {
    env.logger.info('approvalFlow.start', { taskId: ctx.taskId, decision })

    await env.ApprovalService.decide({ ...ctx, decision })
    await env.AuditService.record({ taskId: ctx.taskId, decision, comment: ctx.comment })
    await env.TaskService.refreshList()

    env.logger.info('approvalFlow.done', { taskId: ctx.taskId, decision })
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/bulk-operations/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface BulkOperationService {
  applyToMany: (input: { ids: string[]; operation: string }) => Promise<void>
}

export interface SelectionService {
  getSelectedIds: () => Promise<string[]>
}

export interface BulkEnv extends BasePlatformEnv {
  BulkOperationService: BulkOperationService
  SelectionService: SelectionService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/bulk-operations/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { BulkEnv } from './env'

export const bulkOperationFlow =
  (operation: string): Effect<BulkEnv, never, void> =>
  async env => {
    const ids = await env.SelectionService.getSelectedIds()
    env.logger.info('bulkOperation.start', { operation, count: ids.length })
    if (!ids.length) {
      env.NotificationService?.info?.('请先选择记录') // 可选扩展：在 BasePlatformEnv 中增加通知
      return
    }
    await env.BulkOperationService.applyToMany({ ids, operation })
    env.logger.info('bulkOperation.done', { operation })
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/crud-form/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface EntityForm {
  id?: string
  // 简化：真实项目中可泛型化
  values: Record<string, unknown>
}

export interface EntityService {
  load: (id: string) => Promise<EntityForm>
  create: (input: EntityForm) => Promise<{ id: string }>
  update: (input: EntityForm) => Promise<void>
}

export interface ValidationService {
  validate: (input: EntityForm) => Promise<{ valid: boolean; errors?: Record<string, string> }>
}

export interface NotificationService {
  success: (msg: string) => void
  error: (msg: string) => void
}

export interface CrudFormEnv extends BasePlatformEnv {
  EntityService: EntityService
  ValidationService: ValidationService
  NotificationService: NotificationService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/crud-form/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { CrudFormEnv, EntityForm } from './env'

export const loadFormFlow =
  (id: string): Effect<CrudFormEnv, never, EntityForm> =>
  async env => {
    env.logger.info('crudForm.load.start', { id })
    const form = await env.EntityService.load(id)
    env.logger.info('crudForm.load.done', { id })
    return form
  }

export const submitFormFlow: Effect<CrudFormEnv, never, void> = async env => {
  // 在真实实现中，表单值通常由 UI 通过参数传入或从外部 state 读取；
  // PoC 可简化为从某个固定来源读取。
  const form: EntityForm = { values: {} }

  env.logger.info('crudForm.submit.start', {})

  const result = await env.ValidationService.validate(form)
  if (!result.valid) {
    env.logger.info('crudForm.submit.invalid', { errors: result.errors })
    env.NotificationService.error('表单校验失败')
    return
  }

  if (form.id) {
    await env.EntityService.update(form)
    env.NotificationService.success('更新成功')
  } else {
    const created = await env.EntityService.create(form)
    env.NotificationService.success('创建成功')
    env.logger.info('crudForm.submit.created', { id: created.id })
  }

  env.logger.info('crudForm.submit.done', {})
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/dependent-selects/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface Province {
  code: string
  name: string
}

export interface City {
  code: string
  name: string
  provinceCode: string
}

export interface District {
  code: string
  name: string
  cityCode: string
}

export interface LocationService {
  listProvinces: () => Promise<Province[]>
  listCities: (provinceCode: string) => Promise<City[]>
  listDistricts: (cityCode: string) => Promise<District[]>
}

export interface DependentSelectEnv extends BasePlatformEnv {
  LocationService: LocationService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/dependent-selects/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type {
  City,
  DependentSelectEnv,
  District,
  Province,
} from './env'

// 加载省份列表
export const loadProvincesFlow: Effect<DependentSelectEnv, never, Province[]> = async env => {
  env.logger.info('location.loadProvinces.start')
  const provinces = await env.LocationService.listProvinces()
  env.logger.info('location.loadProvinces.done', { count: provinces.length })
  return provinces
}

// 省份变更时：根据省份加载城市，并清空区县
export const onProvinceChangeFlow =
  (provinceCode: string): Effect<DependentSelectEnv, never, { cities: City[]; districts: District[] }> =>
  async env => {
    env.logger.info('location.onProvinceChange', { provinceCode })
    const cities = await env.LocationService.listCities(provinceCode)
    // 省份变更时，区县选项应清空，由 UI 层重置 district 字段
    const districts: District[] = []
    return { cities, districts }
  }

// 城市变更时：根据城市加载区县
export const onCityChangeFlow =
  (cityCode: string): Effect<DependentSelectEnv, never, District[]> =>
  async env => {
    env.logger.info('location.onCityChange', { cityCode })
    const districts = await env.LocationService.listDistricts(cityCode)
    env.logger.info('location.loadDistricts.done', { count: districts.length })
    return districts
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/file-import/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface UploadResult {
  fileId: string
}

export interface ImportTask {
  taskId: string
  status: 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED'
}

export interface FileUploadService {
  upload: (file: File) => Promise<UploadResult>
}

export interface ImportService {
  startImport: (fileId: string) => Promise<{ taskId: string }>
  getImportStatus: (taskId: string) => Promise<ImportTask>
}

export interface FileImportEnv extends BasePlatformEnv {
  FileUploadService: FileUploadService
  ImportService: ImportService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/file-import/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { FileImportEnv, ImportTask } from './env'

// 上传文件并启动导入任务：不包含轮询逻辑，仅返回 taskId。
export const uploadAndStartImportFlow =
  (file: File): Effect<FileImportEnv, never, { taskId: string }> =>
  async env => {
    env.logger.info('fileImport.upload.start', { name: file.name, size: file.size })
    const { fileId } = await env.FileUploadService.upload(file)
    env.logger.info('fileImport.upload.done', { fileId })

    const { taskId } = await env.ImportService.startImport(fileId)
    env.logger.info('fileImport.import.start', { taskId })

    return { taskId }
  }

// 轮询导入任务状态：与 long-task-polling 场景类似，可重用策略。
export const pollImportStatusFlow =
  (taskId: string): Effect<FileImportEnv, never, ImportTask> =>
  async env => {
    env.logger.info('fileImport.poll.start', { taskId })
    let status = await env.ImportService.getImportStatus(taskId)
    while (status.status === 'PENDING' || status.status === 'RUNNING') {
      await new Promise(r => setTimeout(r, 1000))
      status = await env.ImportService.getImportStatus(taskId)
    }
    env.logger.info('fileImport.poll.done', { taskId, status: status.status })
    return status
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/long-task-polling/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface LongTaskService {
  startTask: (payload: Record<string, unknown>) => Promise<{ taskId: string }>
  getStatus: (taskId: string) => Promise<{ status: 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED' }>
}

export interface LongTaskEnv extends BasePlatformEnv {
  LongTaskService: LongTaskService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/long-task-polling/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { LongTaskEnv } from './env'

export const startAndPollLongTaskFlow: Effect<LongTaskEnv, never, void> = async env => {
  env.logger.info('longTask.start', {})
  const { taskId } = await env.LongTaskService.startTask({})

  // 极简轮询示意，真实实现应考虑超时/退避/取消等
  // 这些策略在正式实现中应来自 ConstraintIntent + Layer。
  let status = await env.LongTaskService.getStatus(taskId)
  while (status.status === 'PENDING' || status.status === 'RUNNING') {
    await new Promise(r => setTimeout(r, 1000))
    status = await env.LongTaskService.getStatus(taskId)
  }

  env.logger.info('longTask.done', { taskId, status: status.status })
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/optimistic-toggle/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface ToggleService {
  toggleFlag: (input: { id: string; nextValue: boolean }) => Promise<void>
}

export interface OptimisticToggleEnv extends BasePlatformEnv {
  ToggleService: ToggleService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/optimistic-toggle/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { OptimisticToggleEnv } from './env'

// 乐观切换开关：调用方在 UI 层先更新本地 state，再调用此 Flow；
// 若失败，可根据返回的错误信息在 UI 层恢复原值。
export const toggleFlagFlow =
  (id: string, nextValue: boolean): Effect<OptimisticToggleEnv, never, void> =>
  async env => {
    env.logger.info('toggleFlag.start', { id, nextValue })
    try {
      await env.ToggleService.toggleFlag({ id, nextValue })
      env.logger.info('toggleFlag.done', { id, nextValue })
    } catch (error) {
      env.logger.error('toggleFlag.failed', { id, nextValue, error })
      // 这里不直接恢复 UI，由调用方根据错误决定是否回滚。
      throw error
    }
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/order-export/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface FilterService {
  getCurrentFilters: () => Promise<Record<string, unknown>>
}

export interface TableUiStateService {
  getCurrentState: () => Promise<{ visibleColumns: string[] }>
}

export interface ExportService {
  submitExportTask: (input: {
    filters: Record<string, unknown>
    columns: string[]
  }) => Promise<void>
}

export interface OrderExportEnv extends BasePlatformEnv {
  FilterService: FilterService
  TableUiStateService: TableUiStateService
  ExportService: ExportService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/order-export/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { OrderExportEnv } from './env'

// 对应 v2 FlowIntent/FlowDslV2 中的 exportOrders 流程：
// - 读取当前筛选与可见列
// - 调用 ExportService 提交导出任务
// - 记录日志（通过 BasePlatformEnv.logger）

export const exportOrdersFlow: Effect<OrderExportEnv, never, void> = async env => {
  const filters = await env.FilterService.getCurrentFilters()
  const tableState = await env.TableUiStateService.getCurrentState()

  env.logger.info('exportOrdersFlow.start', {
    filters,
    columns: tableState.visibleColumns,
  })

  await env.ExportService.submitExportTask({
    filters,
    columns: tableState.visibleColumns,
  })

  env.logger.info('exportOrdersFlow.done', {})
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/search-with-debounce/env.ts">
import type { BasePlatformEnv } from '../../effect-poc/shared/effect-types'

export interface SearchResult {
  id: string
  label: string
}

export interface SearchService {
  search: (keyword: string) => Promise<SearchResult[]>
}

export interface SearchEnv extends BasePlatformEnv {
  SearchService: SearchService
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/scenarios/search-with-debounce/flow.ts">
import type { Effect } from '../../effect-poc/shared/effect-types'
import type { SearchEnv, SearchResult } from './env'

// 单次搜索调用：防抖/取消由 UI/调用方控制，本 Flow 只负责一次请求。
export const searchOnceFlow =
  (keyword: string): Effect<SearchEnv, never, SearchResult[]> =>
  async env => {
    env.logger.info('search.start', { keyword })
    if (!keyword.trim()) {
      return []
    }
    const results = await env.SearchService.search(keyword)
    env.logger.info('search.done', { keyword, count: results.length })
    return results
  }
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/shared/effect-types.ts">
// 简化版 Effect 类型与 Env/Layer 抽象，用于 PoC。
// 实际项目中可以替换为 effect-ts 的 Effect/Layer。

export type Effect<R, E, A> = (env: R) => Promise<A>

export type Layer<R> = () => Promise<R>

export interface Logger {
  info: (msg: string, meta?: Record<string, unknown>) => void
  error: (msg: string, meta?: Record<string, unknown>) => void
}

export interface Clock {
  now: () => Date
}

export interface BasePlatformEnv {
  logger: Logger
  clock: Clock
}
</file>

<file path="specs/intent-driven-ai-coding/v2/effect-poc/README.md">
---
title: Effect Runtime PoC · 场景目录
status: draft
version: 0
---

> 本目录用于基于 `effect-ts`（或等价简化版 Effect）进行**业务场景级 PoC**，在正式沉淀 best-practice 之前，先用若干独立文件尝试不同 Flow 写法与 Layer 组合方式，特别是 ToB 场景中的复杂异步与表单逻辑。

- `shared/`：公共类型、简化版 Effect/Env/Layer 抽象（如未直接引入 effect-ts 时使用）。  
- `scenarios/`：按业务场景拆分的 Flow/Env/Layer 示例（列表/导出、审批流、复杂表单、轮询任务等）。

约定：

- 每个场景独立在 `scenarios/*` 中建子目录，包含：
  - `env.ts`：该场景需要的服务接口定义；
  - `flow.ts`：Flow 实现（Effect 程序），对应 v2 模型中的某个 FlowIntent/FlowDslV2；
  - `index.ts`（可选）：简单的 run 示例或测试入口。  
- PoC 代码可以偏工程化，不要求完全贴合最终 API；但在语义上应贴近 `97-effect-runtime-and-flow-execution.md` 中描述的角色与边界。

目前建议覆盖的典型 ToB 场景包括（可逐步补充）：

- 列表 + 筛选 + 导出：`scenarios/order-export`（已有）；
- 通用 CRUD 表单（创建/编辑 + 服务端校验）：`scenarios/crud-form`（已有）；
- 审批/多步骤工作流（含分支）：`scenarios/approval-flow`（已有）；
- 批量操作（多选 + 后端批处理）：`scenarios/bulk-operations`（已有）；
- 长耗时任务与轮询（导入、大规模计算）：`scenarios/long-task-polling`（已有）；
- 异步联动（级联下拉、依赖字段）：`scenarios/dependent-selects`（省市区级联，已有）；
- 搜索与防抖（输入联动、结果更新）：`scenarios/search-with-debounce`；
- 乐观更新与回滚（切换状态开关）：`scenarios/optimistic-toggle`；
- 文件上传与导入（上传 + 校验 + 导入任务）：`scenarios/file-import`.
</file>

<file path="specs/intent-driven-ai-coding/v2/01-overview.md">
---
title: intent-driven · 意图分层与平台蓝图
status: draft
version: 2
---

## 0. 与上一版的区别（概要）

- 视角从“资产类型”（Intent/Pattern/Plan）转为“意图类型”（布局/视图/交互/行为/数据/工程结构）；
- 将原先混在一个 Intent/Pattern/Plan 里的多层意图拆开，分别建 Schema 和文档；
- 明确 Effect/Flow/Template/Runs 在各意图层的角色，使“从意图到出码”的链路可追踪、可调试；
- 平台交互不再是单页大表单，而是按意图层拆成多个视图（Intent Studio / Pattern Studio / Flow Studio / Code Studio）。

## 1. 设计目标

- 允许开发者**自由表达线稿级意图**：像画速写一样描述界面、交互和代码结构，而不是一上来就填写细碎表单。
- 把前端开发拆成一组**互斥又互补的意图类型**，每类意图都有专门的 schema、文档与 UI 视图。
- 平台与 LLM 的职责清晰：
  - 用户画“线稿”（Intent Sketch）；
  - 平台+LLM 负责“润色”（生成 Pattern 绑定、Flow、Plan、代码骨架）。
- 所有资产（Intent/Pattern/Template/Plan/Flow）只是不同意图类型的**载体**，而不是一堆混合概念。

## 2. 前端六大意图类型

我们将前端开发里的意图拆成六类（约束/质量单独附着在其上）：

1. **布局意图 Layout Intent**  
   - 回答“页面如何分区、各区域相对位置和占比”。
   - 示例：工作台三栏布局、列表页上中下结构等。

2. **视图 / 组件意图 View & Component Intent**  
   - 回答“每个区域里放什么 UI 模式/组件，它们的变体是什么”。
   - 示例：列表+筛选、wizard 表单、审批时间轴等。

3. **交互意图 Interaction Intent**  
   - 回答“用户操作 → 立即的 UI 反馈”。  
   - 示例：点击按钮打开弹框、切 Tab、高亮选中行、滚动定位。

4. **行为 / 流程意图 Behavior & Flow Intent**  
   - 回答“跨组件/跨步骤的业务流程是什么，要调用哪些服务”。  
   - 示例：导出订单 = 取当前筛选 + 可见列 → 调 ExportService → 成功后提示并记录任务。

5. **数据 / 状态意图 Data & State Intent**  
   - 回答“数据长什么样、校验规则是什么、状态存在哪里”。  
   - 示例：订单实体字段与枚举、表单字段 schema、筛选条件放在本地 store 还是 URL。

6. **工程结构意图 Code Structure Intent**  
   - 回答“代码如何组织、模块和文件怎么拆”。  
   - 示例：订单模块拆成 page/components/store/service/queries，使用哪套模板/目录规范。

> 此外还有一类横切的 **约束 / 质量意图 Constraint & Quality Intent**（性能、安全、兼容性、可观测性等），会附着在上面六类意图的不同载体之上。

## 3. 资产与意图类型的映射（v2 总表）

| 意图类型 | 主要承载资产 | 说明 |
| --- | --- | --- |
| Layout | Intent.scene.layout / layout Pattern | 描述区域分区与布局树，不含具体组件与行为细节 |
| View & Component | UI/Pro Pattern（composition/uiSchema）、Intent.view 段 | 描述区域内的 UI 模式与组件结构 |
| Interaction | Intent.interaction 段 / Flow DSL trigger / 组件实现 | 事件 → UI 反馈（打开/关闭/切换等） |
| Behavior & Flow | Intent.behavior.flows / Flow DSL / `.flow.ts` | 业务步骤链、服务调用、分支与错误处理 |
| Data & State | Intent.domain / pattern.dataContract / store & query 规范 | 实体、表单/校验、状态来源与生命周期 |
| Code Structure | Plan / Template / best-practice 目录约定 | 模块、文件、切片与模板映射 |
| Constraint & Quality | Pattern/Intent/Plan 的 metadata | 性能 budget、a11y、安全与“Never break userspace”约束 |

这个体系要做的不是发明新的资产，而是：

- 明确每种资产**承载哪些意图类型**，哪些不该放；
- 为每种意图提供独立的 schema 与交互视图；
- 让 LLM 在“意图层”工作，而不是直接在混合 YAML 上硬猜。

## 4. 后续章节

- `02-intent-layers.md`：逐一定义六类意图（含 Schema 草稿与示例）。
- `03-assets-and-schemas.md`：映射 Intent/Pattern/Template/Plan/Flow 到各意图层，给出 Schema 草图。
- `04-intent-to-code-example.md`：用订单管理示例串起“从意图到出码”的完整链路。
- `05-platform-ux.md`：平台 UI/UX 蓝图，描述不同角色如何在各意图层工作。
- `design/*`：分别深入布局/视图/交互/行为/数据/工程结构/约束等维度。
- `SCHEMA_EVOLUTION.md`：记录 schema 演进合同与兼容性规则。

后续所有实现都应以本分层模型为参照：先问“用户正在表达哪一类意图”，再决定“它要落在哪个资产和视图里”，最后才考虑用什么技术实现（表单/画布/树/代码）。

## 5. 落地策略：先造“引擎”，后造“座舱”

> v2 的野心是合理的，但真正影响可用性的，是 Intent→Plan→代码的稳定链路。本版起，所有落地工作沿“引擎优先”推进：先定事实源与合同，再实现幂等出码，最后才进入 Studio/画布阶段。

### 5.1 核心约束（立即纳入 Schema 与实现）

- **事实源分级**：
  - Data & State：若已有 OpenAPI/TS Schema，Intent 只能引用 `ref`；暂时允许 `source: "local"` 的临时定义，后续用迁移工具统一；
  - Interaction：事件 `source/event` 只能在 InteractionIntent 中定义，Flow 只允许引用 `eventId`；
  - Code Structure：Plan/Template 必须落在现有 best-practice 目录之内，由路径校验器给出 warning/错误。
- **ID 生命周期**：六类意图及 Use Case 均采用统一 ID 规范；禁止裸字符串引用，引用由 `id-utils` 生成与迁移。
- **Schema 合同**：Intent/Pattern/Template/Plan/Flow 的 schema 变更遵守 `SCHEMA_EVOLUTION.md`，新增字段必须可选，破坏性修改必须附带迁移器。
- **Plan 幂等语义**：`create-file` 不得覆盖用户代码、`modify-file`/`append-snippet` 必须基于锚点/AST；CLI 执行前写入 dry-run diff，执行后可重复运行且结果一致。

### 5.2 MVP 里程碑（引擎 → 试点 → UX）

1. **M0 · 文档收敛**：更新所有 v2 文档以反映上述约束，并新增 `SCHEMA_EVOLUTION.md` 记录演进规则。
2. **M1 · 类型与校验**：实现 IntentSpecV2/PlanSpecV2 的 TS 类型、校验器与 ID 工具；CLI 支持 `imd intent check/apply`，但暂不生成复杂 UI。
3. **M2 · 幂等出码引擎**：完成 React 组件与 `.flow.ts` 的 AST merge，Plan 执行具备幂等与冲突提示；代码结构校验器默认 warn，可配置为 hard fail。
4. **M3 · 仓库端到端试点**：在 IMD 主仓库挑选真实 feature，编写完整 Intent/Plan/Flow，跑通“首次出码 → 人工补全 → 调整 Intent → 增量出码”闭环，形成问题清单反哺 schema 与工具。
5. **M4+ · Studio 与预览**：在引擎稳定后，再循序上线 Intent Viewer、Pattern/Flow Studio、画布联动等 UX，避免第二系统效应。

所有子团队在提出新需求前，应先审视其对上述里程碑的影响：能否先以文件/CLI/LSP 形态验证，再投入 Studio 实现。

### 5.3 LLM 演进协作原则

> 预设 LLM 能力持续提升：平台需把“人类输入”逐渐转成“约束与审核”，让模型负责更多润色，但严守输出合同。

- **轻输入，硬输出**：Intent/Plan/Flow 支持更粗粒度的自然语言或半结构描述，由 LLM 生成/重排草稿；输出仍需通过 schema 校验、幂等 Plan、AST merge，模型换代也不会破坏代码。
- **模型接口可插拔**：定义稳定的任务 API（如 `generate_view_intent`、`refine_flow_steps`），Prompt/模型版本独立管理，可灰度升级或回滚，而不影响 CLI/Studio 工作流。
- **自动提炼事实源**：允许上传现有 OpenAPI/TS 文件/代码片段，由 LLM 提炼出 Data & State 投影或 Interaction 事件；减少人力维护重复信息。
- **强校验与对比**：每次 LLM 输出都要自动进行 schema 校验、约束消费检查、Plan dry-run diff，并与上版结果对比，把差异和潜在破坏点展示给人类审核。
- **反馈循环**：记录生成命中率、回退率与冲突率，形成模型评估指标；失败样本进入训练池，为下一代模型或 Prompt 微调提供素材。
</file>

<file path="specs/intent-driven-ai-coding/v2/02-intent-layers.md">
---
title: 前端意图六层模型
status: draft
version: 2
---

> 本文将“前端开发时脑子里想的东西”拆成六类原子意图，作为 Intent/Pattern/Plan/Flow 的统一语义基座。画布、表单、CLI 都只是这些意图的表达形式。

## 1. Layout Intent · 布局意图

**问题域**：页面如何分区、各区域相对位置/优先级是什么。

- 示例：
  - “顶部一条工具栏，下方左右分栏：左侧列表，右侧详情。”
  - “工作台：上方指标区，下方左列表右详情。”
- Schema 草稿：

```ts
interface LayoutRegionIntent {
  id: string
  label: string
  role: 'filters' | 'toolbar' | 'table' | 'metrics' | 'detail' | string
}

interface LayoutIntent {
  layoutType: 'list-page' | 'workbench' | 'custom'
  regions: LayoutRegionIntent[]
  // 可选：网格线稿 / layout 树
  tree?: LayoutNode
}
```

**承载资产**：`Intent.layout`、layout 型 Pattern（如 workbench-layout）、设计文档 `design/layout.md`。

## 2. View & Component Intent · 视图与组件意图

**问题域**：每个区域里用什么组件/模式，它们的变体是什么。

- 示例：
  - “列表区使用可排序表格，带选择列和操作列。”
  - “弹框内是两列表单，底部固定操作条。”
- Schema 草稿：

```ts
interface ViewComponentIntent {
  slot: string // 对应 LayoutIntent.regions[].id
  patternId: string // e.g. table-with-server-filter
  variant?: string // e.g. dense / card / compact
  propsIntent?: Record<string, unknown> // 视图层的参数化意图
}

interface ViewIntent {
  components: ViewComponentIntent[]
}
```

**承载资产**：UI/Pro Pattern（composition/uiSchema）、Intent.view 段、模板中的组件骨架。

## 3. Interaction Intent · 交互意图

**问题域**：用户操作与即时 UI 反馈。

- 示例：
  - “点击‘新增’按钮，打开表单弹窗。”
  - “点击行右侧‘编辑’图标，打开右侧详情抽屉。”
- Schema 草稿：

```ts
interface InteractionIntent {
  events: Array<{
    id: string
    source: string // e.g. toolbar.addButton
    event: 'click' | 'change' | 'hover' | string
    uiEffect:
      | { type: 'openModal'; modalId: string }
      | { type: 'openDrawer'; drawerId: string }
      | { type: 'toggle'; target: string }
      | { type: 'scrollIntoView'; target: string }
      | { type: 'none' }
  }>
}
```

Interaction Intent 只描述“UI 层的可见反馈”，不负责业务流程（服务调用、状态写入）。

**承载资产**：`Intent.interaction` 段、组件 story/demo、Flow DSL 的 trigger 部分。

## 4. Behavior & Flow Intent · 行为与流程意图

**问题域**：跨组件/跨步骤的业务过程，服务调用顺序与分支。

- 示例：
  - “导出订单 = 读取当前筛选 + 当前可见列 → 调用 ExportService → 成功后提示 + 记录任务。”
  - “审批通过 = 校验表单 → 提交审批 API → 刷新任务列表 → 写入审计日志。”
- Schema 草稿：

```ts
interface FlowStepIntent {
  kind: 'callService' | 'branch' | 'delay' | 'parallel'
  serviceId?: string
  method?: string
  input?: Record<string, unknown>
  outputAlias?: string
  when?: string // 条件表达式（引用前面输出）
}

interface FlowIntent {
  id: string
  trigger: { source: string; event: string }
  pipeline: FlowStepIntent[]
}

interface BehaviorIntent {
  flows: FlowIntent[]
}
```

**承载资产**：Intent.behavior 段、Flow DSL AST、`.flow.ts` 文件、Effect 流水线。

## 5. Data & State Intent · 数据与状态意图

**问题域**：实体/表单/筛选字段长什么样，在哪儿存，怎么校验与同步。

- 示例：
  - “订单实体包含 id/status/amount 等字段，status 为枚举，可扩展。”
  - “列表数据由 React Query 管理，筛选条件由 Zustand 切片管理。”
- Schema 草稿：

```ts
interface EntityFieldIntent {
  name: string
  type: 'string' | 'number' | 'enum' | 'date' | 'boolean' | string
  enumValues?: string[]
  required?: boolean
}

interface EntityIntent {
  name: string
  fields: EntityFieldIntent[]
}

interface ApiIntent {
  name: string
  path: string
  method: 'GET' | 'POST' | 'PATCH' | 'DELETE' | string
  params?: Record<string, string> // 简化表示
  returns?: string
}

interface StateSourceIntent {
  id: string // e.g. orderList
  kind: 'react-query' | 'zustand' | 'local-state'
  entity: string
}

interface DataStateIntent {
  entities: EntityIntent[]
  apis: ApiIntent[]
  stateSources?: StateSourceIntent[]
}
```

**承载资产**：Intent.domain、Pattern.dataContract、best-practice 中的状态管理规范（zustand slices、react-query keys 等）。

## 6. Code Structure Intent · 工程结构意图

**问题域**：代码如何组织，模块与文件如何拆分，如何映射到模板/Plan。

- 示例：
  - “订单模块 = page + filters/table/toolbar/quick-edit 四个组件 + order.store + order.service + useOrderList hook。”
  - “每个 feature 下有 `components/ stores/ services/ queries/ flows` 五个子目录。”
- Schema 草稿：

```ts
interface ModuleFileIntent {
  kind: 'page' | 'component' | 'store' | 'service' | 'hook' | 'flow'
  path: string // e.g. src/features/order/components/order-table.tsx
  templateId?: string // 对应 TemplateSpec
  patternId?: string // 对应 PatternSpec
}

interface CodeStructureIntent {
  featureId: string
  files: ModuleFileIntent[]
}
```

**承载资产**：Plan（create-file 列表）、Template（path+role 绑定）、best-practice 目录/切片指南。

## 7. Constraint & Quality Intent · 约束与质量意图

**问题域**：性能、安全、兼容性、可观测性等非功能性要求。

- 示例：
  - “该列表需要支持 1w+ 条数据滚动不卡顿；分页请求必须带上 cursor。”
  - “所有操作必须有 undo/rollback 通道；接口变更不得破坏现有调用（Never break userspace）。”

可以作为 metadata 附着在 Intent/Pattern/Plan/Flow 上：

```ts
interface ConstraintIntent {
  performance?: { maxItems?: number; latencyBudgetMs?: number }
  safety?: { requireAuth?: boolean; sensitiveFields?: string[] }
  compatibility?: { neverBreakUserspace?: boolean; dependsOnApis?: string[] }
  observability?: { requireAuditLog?: boolean; tracing?: boolean }
}
```

**承载资产**：

- Pattern.metadata（安全/性能/i18n/a11y 指南）；
- Intent.constraints（特定场景的额外要求）；
- Plan/Flow 的 run 配置（例如是否必须带埋点/审计日志）。

## 8. 组合与互斥

- 每句“原子描述”只能属于一个主意图类型：
  - “点击按钮打开弹框” → Interaction；
  - “点击确认后校验并调用接口” → Interaction + Behavior（需拆成两句意图）；
  - “导出任务成功后刷新列表数据” → Behavior & Flow；
  - “筛选条件由 Zustand 管理” → Data & State；
  - “订单模块拆成这些目录与文件” → Code Structure。
- 一个完整的 feature 通常包含：Layout + View + Interaction + Behavior + Data & State + Code Structure（再叠加 Constraints）。
- 平台与 LLM 的职责：
  - 引导用户在不同面板中表达对应类型的线稿；
  - 在每一层线稿之上进行“润色”（生成 Pattern/Template/Plan/Flow），而不是在一坨混合 YAML 上硬猜。

## 9. 设计原则：Intent ≠ 代码 DSL

为了防止 Intent 退化成“换一种格式写代码”，各意图层在设计与编辑时需遵守以下原则：

- **只说 What，不写 How**：  
  - Layout/View/Interaction/Behavior/Data/Code Structure 关注的是“想要什么布局/组件/行为/数据/拆分方式”；  
  - 具体组件实现、Hook 名、函数签名、错误处理细节等工程实现由 Pattern/Template/Plan/代码承担。
- **字段偏向业务决策而非实现细节**：  
  - Data & State 记录业务实体/字段含义/校验规则/状态来源类型，不记录具体 React Query key 或 hook 名；  
  - Behavior 描述“调用哪个领域服务/步骤链”，不在 Intent 里展开复杂控制流与错误重试策略（这些落在 Flow DSL + Constraint + Layer）。
- **Intent 可以不完备，但要稳定**：  
  - 允许只写 Layout + View + 核心 Behavior/Data，后续再增量补充其它层；  
  - 实现层的重构应尽量通过 Pattern/Template/Plan 吸收，不要求频繁修改 Intent，避免 Intent 跟着代码细节一起抖动。
- **编辑体验优先线稿与用例视角**：  
  - 默认入口是用例列表、线稿画布、列表/表格式编辑，而不是直接暴露 JSON/TS 源文件；  
  - Schema/TS 视图保留给高级用户，用于精细调整与审查，而不是日常「写 DSL」入口。

判断一个字段/交互是否适合放在 Intent 层，可以自问：它是否主要承载“脑子里的业务意图”？如果更多是在描述技术实现细节，就应考虑下沉到 Pattern/Template/Plan/代码。
</file>

<file path="specs/intent-driven-ai-coding/v2/03-assets-and-schemas.md">
---
title: 资产与意图层的映射与 Schema 草图
status: draft
version: 2
---

> 本文从“资产视角”回看意图分层模型：Intent / Pattern / Template / Plan / Flow / best-practice 各自承载哪些意图层，以及期望的 Schema 草图。

## 1. IntentSpec v2 草图

在 IntentSpec 中，scene/domain/runtimeFlows/patterns 不再混在一起，而是按意图层拆分结构：

```ts
interface IntentSpecV2 {
  id: string
  title: string
  description: string

  layout: LayoutIntent
  view?: ViewIntent
  interaction?: InteractionIntent
  behavior?: BehaviorIntent
  data?: DataStateIntent

  // 代码结构意图通常由 Plan/Template 承载，这里只保留引用/意向
  codeStructureRef?: {
    planId?: string
    templateIds?: string[]
  }

  constraints?: ConstraintIntent

  // 事实源引用（Data & State）
  dataSource?: {
    // 推荐：绑定外部 schema（OpenAPI/TS 类型等）作为唯一事实源
    externalSchemaId?: string
    // 临时：允许 local 定义，但需标注来源，后续迁移到 external
    source?: 'external' | 'local'
  }
}
```

### 与 v1 Intent 的映射

- `scene.layout` → `layout`；
- `patterns` 中与 UI 相关的配置 → `view.components`；
- `runtimeFlows` 的 trigger/UI 部分 → `interaction.events`；
- `runtimeFlows` 的 pipeline 服务调用部分 → `behavior.flows`；
- `domain.entities/apis` → `data.entities/apis`；
- `openQuestions/autoFill` → 辅助信息，可放入 data 或 constraints 的补充字段。

## 2. PatternSpec v2 草图

Pattern 在 v2 中被视为“意图层级的模板”，需显式声明自己覆盖哪些层：

```ts
type IntentLayer = 'layout' | 'view' | 'interaction' | 'behavior' | 'data' | 'code-structure'

interface PatternSpecV2 {
  id: string
  name: string
  summary: string
  version: string
  status: 'draft' | 'review' | 'published'

  intentLayers: IntentLayer[] // 该模式主要作用于哪些意图层

  composition?: {
    roles: PatternRole[] // 多数属于 view / behavior / data 层
  }

  dataContract?: {
    entities?: string[]
    requiredFields?: string[]
    apis?: string[]
  }

  paramsSchema?: Record<string, unknown> // 跨层参数化入口
  uiSchema?: Record<string, unknown> // View 层表单配置

  runtimeBindings?: Record<string, { component?: string; service?: string }>

  constraints?: ConstraintIntent
}
```

### 典型模式的 intentLayers

- `workbench-layout`：`['layout', 'view']`
- `table-with-server-filter`：`['view', 'behavior', 'data']`
- `service-adapter-query`：`['data', 'code-structure']`
- `zustand-store-with-slices`：`['data', 'code-structure']`

## 3. TemplateSpec v2 草图

模板是“代码结构意图 + 实现细节”的桥梁：

```ts
interface TemplatePatternImplV2 {
  patternId: string
  role: string
  path: string
}

interface TemplateSpecV2 {
  id: string
  name: string
  description: string
  version: string
  status: 'draft' | 'published'

  // Code Structure 意图的骨架
  files: {
    kind: 'page' | 'component' | 'store' | 'service' | 'hook' | 'flow'
    path: string
    patternBindings?: TemplatePatternImplV2[]
  }[]

  runtimeBindings?: {
    uiCapabilities?: Record<string, unknown>
  }
}
```

Template 主要落在 Code Structure 层，但通过 patternBindings 与 View/Behavior/Data 等层联动。

## 4. PlanSpec v2 草图

Plan 是“Code Structure Intent 的实例化 + 部分 Flow 编排”，v2 下保留形态，但增加可追踪的意图信息：

```ts
interface PlanActionV2 {
  id: string
  type: 'create-file' | 'modify-file' | 'append-snippet'
  path: string
  templateId: string
  patternId?: string
  intentLayers?: IntentLayer[] // 该 action 主要服务哪些意图层
  params: Record<string, unknown>
}

interface PlanSpecV2 {
  id: string
  intentId: string
  version: string
  actions: PlanActionV2[]
  constraints?: ConstraintIntent
}
```

这样平台可以回答：

- “这个 Plan action 是在落实哪个意图层？”
- “改动某个 Pattern 时，会影响哪些 Plan（以及它们实现的意图层）？”

## 5. Flow DSL / `.flow.ts` v2 草图

Flow DSL 本身就是 Behavior & Flow Intent 的主要载体，v2 强调：

- 触发条件：源自 Interaction Intent；
- 流水线：纯 Behavior & Flow；
- 绑定 services：与 Pattern/Template 中的 runtimeBindings 一致。

```ts
interface FlowDslV2 {
  id: string
  trigger: {
    eventId: string // InteractionIntent.events[].id
    // 下列信息来自 InteractionIntent，保持冗余方便展示
    source?: string
    event?: string
  }
  steps: FlowStepIntent[]
  constraints?: ConstraintIntent
}

// `.flow.ts` 中为 FlowDslV2 提供 Effect 实现
```

## 6. best-practice 仓库与 Code Structure Intent

best-practice 仓库中已有：

- 目录约定、状态管理规范、service/adapter 模式等；
- 这些内容天然属于 Code Structure + Data & State 意图层。

v2 的要求：

- 在 best-practice 中为每种“工程结构意图”提供：
  - 结构描述（目录树 + 模块关系图）；
  - 模板/脚手架（TemplateSpec）的映射关系；
  - 与 Pattern 层的关联（比如 service-adapter-query 模式对应哪个模板文件）。
- 平台的 Plan/Template 必须与 best-practice 的这些定义对齐，而不是额外发明一套规则。

## 7. 小结

- 意图层模型定义了“我们想表达什么”；
- 本文中的 v2 Schema 草图定义了“这些意图落在哪些资产上”；
- 后续平台 UI/CLI/LLM 都围绕这套映射工作：
  - UI：为不同意图层提供专门视图；
  - CLI：根据 Code Structure Intent + Template/Pattern 生成代码；
  - LLM：在特定意图层（Layout/View/Flow/Data/CodeStructure）上进行润色与补全。

## 8. 事实源与引用规则（v2 MVP 要求）

1. **Data & State**：
   - 若存在外部 schema（OpenAPI、TS 类型、GraphQL SDL 等），Intent 里的实体/接口需引用 externalSchemaId，并通过 `fieldsUsed`、`paramsUsed` 记录投影；
   - 如暂未有正式 schema，可使用 `source: 'local'` 的临时描述，但必须在 CLI 校验时提示，后续统一迁移到外部事实源。
2. **Interaction → Behavior**：
   - InteractionIntent.events 是唯一的事件注册表，负责生成 `eventId`；
   - FlowIntent/FlowDsl 只接受 `eventId`，禁止手写 `source/event` 字符串；UI 展示层可冗余存一份 `source` 方便人类理解。
3. **Code Structure**：
   - PlanActionV2.path、TemplateSpec.files.path 必须通过 best-practice 目录校验器；
   - 所有文件均需 `fileId`（例如 `feature:order-management/components/order-table`）以便 renaming 与追踪。
4. **ID 规范**：
   - Intent/Pattern/Template/Plan/UseCase/Flow/ModuleFile 等 ID 由 `id-utils` 生成，包含类型前缀和语义 slug；
   - 重命名需借助迁移工具，禁止手动 search/replace。
5. **约束承载**：
   - ConstraintIntent 只有在 Flow/Plan/Template 等层声明“消费方式”后才可合并入主干，否则按警告处理；
   - CLI 应检查存在但未消费的约束，防止 metadata 失真。

6. **LLM 协作注意事项**：
   - 输入可更自由（自然语言/半结构），但输出必须通过 schema 校验 + 幂等 Plan + AST merge；
   - LLM 生成的 Data/State 投影需标注来源（external/local），并与事实源校验差异；
   - 禁止 LLM 直接修改路径/ID：路径需通过目录校验器，ID 由 id-utils 分配；
   - CLI/LSP 应在生成后展示 diff 与潜在破坏点，默认需人工审核才能落盘。

以上规则决定了“引擎”能否保持稳定，Studio/画布等后续工程均需在这些合同建立后再继续扩展。
</file>

<file path="specs/intent-driven-ai-coding/v2/04-intent-to-code-example.md">
---
title: 示例：从意图到出码的完整链路
status: draft
version: 2
---

> 本文用一个具体例子串起六类意图 —— 以“订单管理列表（含导出与快速编辑）”为例，从需求文字 → 意图线稿 → IntentSpecV2 → Pattern/Plan/Flow → 最终代码骨架。

## 1. 需求文字（用户视角）

> 我需要一个订单管理页面：左边是筛选，右边是列表，上面一条工具栏。运营可以按状态、时间筛选订单，查看列表，点击行上的编辑按钮弹出备注编辑弹窗。工具栏要有“导出”按钮，导出时带上当前筛选条件和可见列。提交表单要做校验，成功后关闭弹窗并刷新列表。

## 2. 意图分解（线稿级）

根据 v2 的六类意图，我们将这段话拆成：

- Layout：左筛选右列表，上方工具栏；
- View：列表用可排序表格、顶部有筛选/工具栏、弹框中是表单；
- Interaction：
  - 点击行上“编辑” → 打开备注弹框；
  - 点击工具栏“导出” → 打开导出确认弹框或直接触发导出。
- Behavior & Flow：
  - 导出流程：读取筛选+列 → 调 ExportService → 成功提示；
  - 快速编辑流程：校验备注 → 调 updateOrder → 成功关闭弹框+刷新列表。
- Data & State：
  - Order 实体字段、listOrders/exportOrders 接口；
  - 列表数据走 React Query，筛选状态走 store。
- Code Structure：
  - `features/order-management/` 下的 page/components/store/service/queries/flows 结构。

## 3. IntentSpecV2 片段

### 3.1 LayoutIntent

```yaml
id: order-management
title: 订单管理列表
description: 管理订单的列表 / 搜索 / 快速编辑 / 导出功能

layout:
  layoutType: list-page
  regions:
    - id: filters
      label: 筛选区
      role: filters
    - id: toolbar
      label: 工具栏
      role: toolbar
    - id: table
      label: 列表
      role: table
```

### 3.2 ViewIntent

```yaml
view:
  components:
    - slot: filters
      patternId: filter-bar
      propsIntent:
        entity: Order
        fields: [status, createdAt]
        inlineSearch: true
    - slot: toolbar
      patternId: toolbar-with-quick-edit
      propsIntent:
        supportQuickEdit: true
        supportExport: true
        entity: Order
        editableFields: [remark]
    - slot: table
      patternId: table-with-server-filter
      propsIntent:
        entity: Order
        columns:
          - { key: id, title: 订单号, sortable: true }
          - { key: status, title: 状态 }
          - { key: createdAt, title: 下单时间, sortable: true }
          - { key: totalAmount, title: 金额 }
        pagination: true
        batchActions: [export]
        pageSize: 20
```

### 3.3 InteractionIntent

```yaml
interaction:
  events:
    - id: openQuickEdit
      source: table.row.action.edit
      event: click
      uiEffect:
        type: openModal
        target: quickEditModal
    - id: submitQuickEdit
      source: quickEditModal.confirmButton
      event: click
      uiEffect:
        type: none
    - id: triggerExport
      source: toolbar.exportButton
      event: click
      uiEffect:
        type: none
```

### 3.4 BehaviorIntent（FlowIntent）

```yaml
behavior:
  flows:
    - id: exportOrders
      trigger:
        source: toolbar.exportButton
        event: click
      pipeline:
        - kind: callService
          serviceId: FilterService
          method: getCurrentFilters
          outputAlias: filters
        - kind: callService
          serviceId: TableUiStateService
          method: getCurrentState
          outputAlias: tableState
        - kind: callService
          serviceId: ExportService
          method: submitExportTask
          input:
            filters: "{{filters}}"
            columns: "{{tableState.visibleColumns}}"

    - id: updateRemark
      trigger:
        source: quickEditModal.confirmButton
        event: click
      pipeline:
        - kind: callService
          serviceId: FormValidationService
          method: validateRemarkForm
          outputAlias: form
        - kind: branch
          when: "!form.valid"
          // 交给 InteractionIntent 的 uiEffect: 显示错误
        - kind: callService
          serviceId: OrderService
          method: updateOrder
          input:
            id: "{{form.values.id}}"
            remark: "{{form.values.remark}}"
        - kind: callService
          serviceId: UiService
          method: closeModal
          input:
            modalId: quickEditModal
        - kind: callService
          serviceId: ListQueryService
          method: refetch
```

### 3.5 DataStateIntent（简化版）

```yaml
data:
  entities:
    - name: Order
      fields:
        - { name: id, type: string, required: true }
        - { name: status, type: enum, enumValues: [PENDING, PAID, SHIPPED, COMPLETED, CANCELED] }
        - { name: createdAt, type: date }
        - { name: totalAmount, type: number }
        - { name: remark, type: string }
  apis:
    - name: listOrders
      path: /api/orders
      method: GET
      params:
        status: string?
        createdAtFrom: string?
        createdAtTo: string?
        page: number
        pageSize: number
    - name: updateOrder
      path: /api/orders/{id}
      method: PATCH
      params:
        remark: string?
    - name: exportOrders
      path: /api/orders/export
      method: POST
      params:
        filters: object
```

### 3.6 CodeStructureIntent（概念）

```yaml
codeStructureRef:
  planId: order-management.plan.v1
```

在 PlanSpecV2 中会给出具体文件：

```yaml
id: order-management.plan.v1
intentId: order-management
version: v1
actions:
  - id: page
    type: create-file
    path: src/features/order-management/order-management.page.tsx
    templateId: list-page-shell
    patternId: list-page
    intentLayers: [layout, view, code-structure]

  - id: filters
    type: create-file
    path: src/features/order-management/components/order-filters.tsx
    templateId: filters-basic
    patternId: filter-bar
    intentLayers: [view, data]

  - id: table
    type: create-file
    path: src/features/order-management/components/order-table.tsx
    templateId: react-table-shell
    patternId: table-with-server-filter

  - id: toolbar
    type: create-file
    path: src/features/order-management/components/order-toolbar.tsx
    templateId: toolbar-basic
    patternId: toolbar-with-quick-edit

  - id: quickEditFlow
    type: create-file
    path: src/features/order-management/flows/update-remark.flow.ts
    templateId: flow-effect-ts
    patternId: approval-flow
    intentLayers: [behavior, code-structure]
```

## 4. Flow DSL 与 Effect-ts（行为层出码）

以 `exportOrders` 为例，从 FlowIntent 到 Effect 程序：

```ts
// FlowAst 由 FlowIntent 解析而来
export interface ExportOrdersEnv {
  FilterService: {
    getCurrentFilters: () => Promise<Record<string, unknown>>
  }
  TableUiStateService: {
    getCurrentState: () => Promise<{ visibleColumns: string[]; [k: string]: unknown }>
  }
  ExportService: {
    submitExportTask: (input: { filters: Record<string, unknown>; columns: string[] }) => Promise<void>
  }
}

export async function exportOrdersFlow(env: ExportOrdersEnv) {
  const filters = await env.FilterService.getCurrentFilters()
  const tableState = await env.TableUiStateService.getCurrentState()
  await env.ExportService.submitExportTask({
    filters,
    columns: tableState.visibleColumns,
  })
}
```

在 v2 中，Effect-ts（或等价 Effect runtime）就是 Behavior & Flow Intent 的“运行时润色层”：

- FlowIntent → FlowAst → Effect 程序骨架；
- Constraints（重试/超时/审计）通过 Effect 组合实现；
- Plan 在 Code Structure 层负责将 `.flow.ts` 文件放到合适目录。

## 5. 最终代码骨架（示意）

根据 Intent + Pattern + Template + Plan，平台可以生成：

- 布局壳组件：`order-management.page.tsx`；
- 视图组件：`order-filters.tsx`、`order-table.tsx`、`order-toolbar.tsx`；
- 状态模块：`filter.slice.ts`、`table.slice.ts`、`useOrdersList.hook.ts`；
- 行为 Flow：`export-orders.flow.ts`、`update-remark.flow.ts`；
- 模式/模板与 best-practice 的映射（目录和命名）。

在这个过程中：

- 用户的“线稿意图”只需要覆盖布局/视图/交互/行为/数据/工程结构的骨架；
- 平台与 LLM 根据 v2 的意图分层模型，将这些线稿映射到具体资产和代码结构；
- Effect-ts 等运行时技术只在 Behavior & Flow + Constraints 层出现，对用户透明但对平台可控。
</file>

<file path="specs/intent-driven-ai-coding/v2/05-platform-ux.md">
---
title: 平台界面与交互蓝图
status: draft
version: 2
---

> 本文从 UX 角度描述平台长什么样：
> - 不再是“一个大表单 + 几个 YAML 预览”；
> - 而是围绕六类意图，为不同角色提供多视图的 IDE：Intent Studio / Pattern Studio / Code Studio / Flow Studio。

> 说明：本文件聚焦 v2/MVP 及其直接演进形态，更远期的画布高级交互、用例透视、自动重构等能力，统一收敛在 `99-long-term-blueprint.md`，避免与当前实现目标混淆。

## 0. 角色与职责（产品 / 架构 / 前端）

为了简化，平台主要服务三类角色：

- **产品（或前端兼任）**：
  - 站在业务视角表达 Layout / View / Interaction / Data 这四层意图；
  - 在 Intent Studio 中进行“线稿级”表达，或提供自然语言/线框素材交给 LLM 生成草稿；
  - 负责审核 LLM 生成的 Layout/View/Data 草图与约束提示，而不是逐字段填表。
- **架构**：
  - 在 Pattern/Flow/Code Studio 中塑造 View/Behavior/Data/Code Structure 的模板与规范；
  - 负责模式库、模板库、Flow DSL 与运行时（Effect）设计，并维护 LLM Prompt/任务 API；
  - 保障意图层与工程层之间的映射稳定可演进。
- **前端开发**：
  - 拉取由 Intent+Pattern+Plan 生成的代码骨架，在本地 IDE 中补充实现细节；
  - 当需求变化时回到 Intent Studio/Pattern Studio/Flow Studio 更新意图，再增量出码；
  - 逐渐转为审核/确认角色：在 CLI/LSP 中查看 LLM 生成的 diff、约束告警，再决定是否应用，而不是在 Intent 层直接“写 DSL”。

## 1. 顶层导航（路由层）

- `/` Dashboard：最近 Intent/Plan Runs/Flow 状态概览；
- `/intents`：Intent 资产库；
- `/intents/new`：Intent Studio · 线稿模式；
- `/intents/:id`：Intent Studio · 维度视图（Layout/View/Interaction/Behavior/Data/Code Structure）；
- `/patterns`：模式库列表；
- `/patterns/new`、`/patterns/:id/edit`：Pattern Studio；
- `/patterns/:id/registry`：模式发布与引用视图；
- `/flows`：行为 Flow 列表与 Flow Studio；
- `/assets`：模板、服务、Prompt 等资产中心。

### 1.1 预览为主体的工作台布局

无论处于哪个路由，核心工作台布局保持一致：

- 顶部：全局导航（Dashboard / Intents / Patterns / Flows / Assets）。
- 左侧：当前锚点的 Outline（Intent 列表或 Use Case 列表）。
- 中间：**实时预览区域**（Preview Pane），渲染当前 Intent 的页面/组件，以真实运行时栈运行（React + Query + Store + Flow）。
- 右侧：意图面板（Intent Pane），根据当前 Tab 切换不同意图层的编辑视图（Layout/View/Interaction/Behavior/Data/Code）。

所有配置与编排都围绕预览展开：

- 用户通过选中预览中的元素（Button、Drawer、Select 等），在右侧面板编辑其 Layout/View/Interaction/Data 意图；
- 修改意图后，预览即时反映结构变化（重新挂载组件骨架和行为 Flow），让产品/前端用“搭界面”的方式表达意图，而不是先去找某个表单。

## 2. Intent Studio · 按意图层分屏与线稿模式

在 `/intents/:id` 下，主工作区拆成六个视图（Tab 或左侧导航）：

1. **Layout 视图（界面分区线稿）**  
   - 线稿模式：
     - 中间是一块有限尺寸的网格（例如 4×4 或 6×4）；
     - 产品/前端拖动划出逻辑区域（filters/toolbar/table/metrics 等），输入简短 label；
     - 右侧实时显示 `LayoutIntent` JSON 预览与区域树（vertical/horizontal 树结构）。
   - 细节模式：
     - 使用列表/树编辑 Region 的 id/label/role，微调布局类型（list-page/workbench/...）；
     - LLM 可基于需求文本或粗略网格“一键生成布局草图”，用户再微调。

2. **View 视图（组件与模式）**  
   - 左侧：
     - 按 Layout slot 展示列表（filters/toolbar/table/metrics/...）；
     - 每条显示当前已绑定的模式（如 filter-bar、table-with-server-filter）。
   - 中间：Pattern 卡片墙：
     - 每张卡片说明模式用途、支撑的意图层（layout/view/behavior/data）；
     - 支持搜索、筛选（如“支持导出”“支持分页”）。
   - 右侧：属性面板：
     - 使用 Pattern.uiSchema 渲染紧凑表单（列配置、按钮集合等）；
     - 视图层参数变更会同步到 `view.components[].propsIntent`。

3. **Interaction 视图（事件与 UI 效果）**  
   - 主视图是事件表格：
     - 列：元素（source）、事件类型（event）、UI 效果（uiEffect.type/target）、补充说明；
     - 支持从页面预览中“录制”交互（点击元素后自动填 source）。
   - 可选小画布：
     - 节点为 UI 元素/状态，连线表示“点击 A → 打开 B”；
     - 用于复杂交互关系的总览，而不是精细配置。

4. **Behavior & Flow 视图（业务流程线稿 + Effect）**  
   - Flow 列表：显示每个 Flow 的 id、触发源、服务覆盖范围；
   - Flow 详情：
     - 左侧为“步骤列表”，支持用自然语言编辑每一步（例如“调用 ExportService 提交任务”）；
     - 中间为 Flow DSL/AST 视图（结构化 JSON 或 DSL 文本）；
     - 右侧为 `.flow.ts` 预览（Effect 程序骨架），只读或受控编辑。
   - 交互：
     - 产品/前端可以只维护自然语言步骤，架构/LLM 负责生成/润色 Flow DSL + Effect；
     - 支持在此视图内运行沙箱执行，查看日志与错误。

5. **Data & State 视图（实体 / 接口 / 状态来源）**  
   - 实体表：
     - 行：字段名/类型/是否必填/枚举值/描述；
   - API 表：
     - 列出 list/update/export 等接口的 path/method/参数；
   - 状态来源：
     - 指定某个实体对应的 stateSource（react-query/zustand/local）。
   - 交互：
     - 支持从 OpenAPI/JSON schema 导入结构；
     - LLM 根据已有视图/Flow 意图补全缺失字段与接口。

6. **Code Structure 视图（模块骨架）**  
   - 模块/文件树视图：
     - 以 feature 为根展示目录树（page/components/store/service/query/flows 等）；
     - 每个节点标记 kind（page/component/...）、对应 Template/Pattern；
   - Plan 草稿区：
     - 右侧显示 create-file 列表，允许 FE/架构调整某些路径/模板绑定；
   - 交互：
     - FE 可以用“线稿”方式新增/删减模块（例如加一个分离的 FilterStore）；
     - LLM 根据 CodeStructureIntent + best-practice 规范，生成/调整 Plan。

所有视图共享右侧的：

- Copilot 条：显示当前意图层的“线稿完成度”与下一步建议；
- Diff/历史：可以对比本次编辑与上一次生成的 Intent/Plan/Flow。

## 3. Pattern Studio v2 · 避免表单爆炸

在 `/patterns/:id/edit` 中：

- 顶部 Tabs：
  - 基础信息（id/name/summary/status/intentLayers）；
  - Roles/Params（composition.roles + paramsSchema）；
  - UI & Runtime（uiSchema + runtimeBindings）；
  - 引用与约束（哪些意图/Plan 使用了它、质量约束）。
- 每一块使用紧凑表格/折叠面板：
  - 角色列表用 DataGrid（每行是一个角色，点击展开详情）；
  - 参数 schema 是 key/type/required/desc 表；
  - UI Schema 是字段→widget→label→options 的列表；
  - Runtime bindings 是 slot→component import→service 的列表。
- LLM 辅助：
  - 从自然语言描述/现有代码生成初版 Pattern；
  - 根据引用情况建议拆分/合并模式。

## 4. Flow Studio v2 · 行为层的“白板”

在 `/flows` 和 `/flows/:id`：

- 列表视图：所有 Flow（BehaviorIntent.flows）的索引：
  - 显示所属 Intent/Pattern/Service，状态（草稿/发布）、最近运行情况。
- 详情视图：
  - 左侧：Flow 步骤列表；
  - 中间：简化画布（节点：Service/条件节点；连线：数据流与控制流）；
  - 右侧：Flow DSL 编辑区 + `.flow.ts` 预览。
- 运行时联动：
  - 可在沙箱中执行 Flow 查看日志；
  - 结合 Effect-ts 中间件，展示重试/超时/审计的行为。

## 5. Code Studio v2 · 出码骨架

在 `/code-structure` 或 Intent Studio 的 Code Structure 视图：

- 模块骨架编辑器：
  - 以树/表格形式编辑 CodeStructureIntent.files；
  - 提供 feature 模板快速创建一组文件（page+components+store+service+flows）。
- Plan 视图：
  - 将 CodeStructureIntent + TemplateSpec 映射到 PlanSpec；
  - 提供 “DRY run” 控制台预览即将生成的文件树。
- 与 best-practice：
  - 显示每个文件关联的 best-practice guideline；
  - LLM 可根据 guideline 提醒不符合规范的设计。

## 6. Intent Sketch Canvas 何时出现？

画布不是 v2 的前提，而是一种可能的“线稿交互形态”：

- 在 Layout 层，可选用网格线稿表达区域；
- 在 Interaction & Flow 层，可用小画布表达事件与流程；
- 在 Code Structure 层，仅用简单 dependency graph 表示模块关系。

关键是：

- 每个画布节点都必须对应某一类意图（Layout/View/Interaction/Flow/Data/Code Structure），
- 画布只用在“流程/关系”表达更自然的地方，而不是把所有信息挤在一张图上。

## 7. 意图表达阶段：自由度与上限

为了保证“自由度和上限”，Intent Studio 在各层意图上都提供三种输入方式：

- 自然语言线稿：
  - 用户可以直接写段落描述布局/交互/流程/模块拆分；
  - LLM 将其解析为 Layout/View/Interaction/Behavior/Data/CodeStructure 各自的草稿。
- 结构化控件：
  - 网格线稿、Pattern 选择器、事件列表、字段表、模块树等低门槛 UI；
  - 用户可以用这些控件“修剪”LLM 的草稿或从零构建线稿。
- 直接编辑 Schema：
  - 高级用户可以切换到 JSON/TS Schema 编辑视图，精准修改 IntentSpec/PatternSpec 等；
  - 平台保证结构完整性，并可视化 diff 与影响范围。

线稿阶段的设计原则：

- **不强制一次性填满所有层**：用户可以先只表达 Layout + View，之后再补 Interaction/Behavior/Data/CodeStructure；
- **所有层都可以增量编辑**：每次修改都形成一个 IntentSpec 版本，并可回滚；
- **LLM 只在用户明确触发时润色**：避免“黑盒重写”，所有变更都可见、可 diff。

## 8. 简化版角色流水线（产品 / 架构 / 前端）

以“订单管理列表”为例：

- **产品（或前端兼任）**：
  1. 在 Intent Studio 的 Layout/View/Data 视图中，通过自然语言+控件画出线稿（区域、组件、字段）。
  2. 在 Interaction/Behavior 视图中，用简单句子描述关键事件和期望行为（导出、快速编辑）。
  3. 提交/共享 Intent 草稿给架构。

- **架构**：
  1. 在 Pattern Studio 中挑选/完善适用模式（list-page/layout/table/filter 等），补 Roles/Params/UI/Runtime 绑定；
  2. 在 Flow Studio 中用 Flow DSL 或可视化步骤完善 Behavior & Flow，并生成/审阅 `.flow.ts`；
  3. 在 Code Studio 中根据团队规范调整模块骨架（特定目录与模板使用），生成或修订 Plan。

- **前端**：
  1. 使用 Code Studio/CLI 拉取 Plan 生成的代码骨架；
  2. 在本地实现视觉/交互细节、边界处理，并对平台上不完整的意图进行反向补充；
  3. 在后续迭代中，通过 Intent Studio/Pattern Studio/Flow Studio 修改意图，再增量出码。

整个过程中，意图表达阶段既支持自由线稿（自然语言 + 画布 + 控件），又提供精细 Schema 编辑（满足上限），而下面的 Pattern/Plan/Flow/Effect 只是在不同层次上把这些意图“落地”为可执行的代码与运行时行为。
</file>

<file path="specs/intent-driven-ai-coding/v2/06-intent-linking-and-replay.md">
---
title: 意图关联与交互回放（Linking & Replay）
status: draft
version: 2
---

> 本文回答两个问题：
> 1. 按意图层分屏之后，如何在平台中方便地把 Layout/View/Interaction/Behavior/Data/Code Structure 关联起来，围绕同一个业务需求协作？
> 2. Interaction 层的录制与回放如何与 Flow/Effect 运行时结合，成为真实的集成测试与压测手段？

## 1. 业务锚点：Intent + Use Case

平台中的一切视图，都应围绕“业务锚点”展开：

- **Intent（场景级）**：例如 `order-management`、`ops-workbench`；
- **Use Case（用例级）**：Intent 下的具体业务意图，如 `exportOrders`、`updateRemark`、`completeTask`。

在 UI 上，这表现为：

- Intent Studio 左侧有一个用例 Outline：
  - 每一行代表一个 Use Case；
  - 每行旁边有 6 个点/进度条，对应六类意图层（Layout/View/Interaction/Behavior/Data/Code）。
- 选中某个 Use Case，所有中间视图（Layout/View/Interaction/Behavior/Data/Code Structure）都跳到该 Use Case 的投影。

## 2. 统一标识：跨层关联的 ID 体系

为了在不同意图层之间自由跳转，需要一套统一的 ID 体系，让平台知道“这是同一个东西在不同层的映射”：

- `regionId`：布局区域（filters/toolbar/table/metrics 等）；
- `componentId`：视图组件/模式实例（FilterBar/Table/Toolbar/...）；
- `source`：交互源（toolbar.exportButton、table.row[orderId].edit 等）；
- `flowId`：Flow/行为流水线（exportOrders、updateRemark）；
- `entityId` / `apiId` / `stateSourceId`：数据与状态源；
- `fileId` / `path`：代码结构层的文件（page/components/store/service/flow）。

这些 ID 在各层 Schema 中都会出现，例如：

- InteractionIntent.events[].source 与 FlowIntent.trigger.source 对齐；
- FlowStepIntent.serviceId 与 DataStateIntent.apis[].name / Pattern.dataContract.apis[] 对齐；
- PlanAction.path 与 CodeStructureIntent.files[].path 对齐，并附带 patternId/templateId/flowId。

这样，平台可以实现：

- 从 Interaction 事件跳转到对应 Flow、Service 和代码文件；
- 从 Flow 跳回它的 Trigger 组件与相关数据源；
- 从任意文件跳回它实现的 Intent/UseCase/Pattern/Flow。

## 3. 跨层关联在 UI 上的体现

以“导出订单”用例为例，在不同视图中应该看到：

- **Layout 视图**：
  - 选中 `toolbar` 区域时，右侧上下文卡片显示：
    - 绑定的 View 组件（ToolbarComponent）；
    - 来自该区域的 Interaction 事件（如 triggerExport）；
    - 以此为 trigger 的 Flow（exportOrders）；
    - 相关文件（`order-toolbar.tsx`、`export-orders.flow.ts`）。

- **View 视图**：
  - 选中 `toolbar-with-quick-edit` 模式实例时：
    - 显示该模式提供的交互源（exportButton/quickEditButton）；
    - 显示当前 Intent 中哪些 Interaction 事件/Flow 使用了这些源；
    - 显示其依赖的数据契约（涉及 Order 实体、哪些字段）。

- **Interaction 视图**：
  - 选中 `triggerExport` 事件时：
    - 显示其 source（toolbar.exportButton）、target Flow（exportOrders）；
    - 显示会受影响的组件（Table/Filters）和数据源（FilterStore/TableUiState）；
    - 提供跳转到 Flow Studio、Data & State 视图的入口。

- **Behavior & Flow 视图**：
  - 选中 `exportOrders` Flow 时：
    - 显示其 trigger（toolbar.exportButton）；
    - 列出它调用的 services/apis（FilterService/TableUiStateService/ExportService）；
    - 显示对应的 `.flow.ts` 文件与 Plan 中的文件生成记录。

- **Data & State 视图**：
  - 打开 `Order` 实体时：
    - 显示哪些视图组件使用了哪些字段（Table 的列、Filter 的字段）；
    - 显示哪些 Flow 会读取/写入这些字段；
    - 显示这些字段的质量约束（例如精度、枚举、敏感性）。

- **Code Structure 视图**：
  - 选中 `export-orders.flow.ts` 文件时：
    - 显示其 FlowIntent（exportOrders）；
    - 显示对应的 Interaction 事件、数据源、Pattern/Template；
    - 支持一键跳转回 Intent Studio 的 Behavior 视图。

## 4. Interaction 录制：采集语义事件 + 状态快照

录制的目标不是“记住 DOM 点击”，而是：

> 在某个 Intent/UseCase 下，记录一条业务路径上发生的所有语义事件、相关状态快照和 Flow 执行轨迹。

### 4.1 RecordedEvent 与 StateSnapshot

```ts
interface RecordedEvent {
  id: string
  intentId: string
  useCaseId: string
  flowId?: string
  source: string   // toolbar.exportButton
  event: string    // 'click'
  at: number       // timestamp
  payload?: any    // 当时的表单值/选中行 id 等
  stateSnapshotId?: string
}

interface StateSnapshot {
  id: string
  intentId: string
  dataSources: {
    type: 'query' | 'store' | 'local'
    key: string
    value: unknown
  }[]
}
```

录制时，Interaction Runtime 会：

- 拦截所有经过 `useInteractionSource(sourceId)` 声明的事件；
- 对重要节点（例如点击导出前、提交表单前后）调用 `captureSnapshot()`；
- 如果有 FlowExecutionLog，也一并记录行为层的步骤执行情况。

### 4.2 代码组织

- 所有交互源通过一个统一 hook 声明：

```ts
const { fire } = useInteractionSource('toolbar.exportButton')

return <Button onClick={() => fire('click')}>导出</Button>
```

- 数据/状态通过适配器提供快照功能：
  - React Query：封装 QueryClient 的 get/set，用于导出/导入某些 queryKey；
  - Zustand：在 root store 上提供 `getSnapshot(id)` / `restoreSnapshot(id)`。

录制逻辑只依赖这些统一 API，而不直接耦合业务组件。

## 5. 回放：用同一套组件 + 数据 + Flow 重跑路径

回放的目标有两个：

1. 帮开发/产品“看”某条业务路径在新代码下是否还正常；
2. 对 Flow/Effect 运行时进行真实的集成测试与压力测试。

### 5.1 回放环境

平台会为每个 Intent/UseCase 提供一个专用的 Replay Shell：

- 挂载同一套布局与组件树（LayoutShell + 组件）；
- 使用专用的 QueryClient、Zustand store 实例；
- 使用 `<InteractionProvider mode="replay">` 包裹整个应用。

回放前：

- 使用对应的 StateSnapshot 初始化 state/data；
- 如果需要“离线回放”，可以使用 snapshot 数据 stub 掉真实 HTTP 请求。

### 5.2 驱动脚本

`InteractionReplayer` 读取某个 `UseCaseScenario`：

```ts
interface UseCaseScenario {
  intentId: string
  useCaseId: string
  events: RecordedEvent[]
  snapshots: StateSnapshot[]
}
```

然后按时间顺序：

- 将 event dispatch 回对应的 `useInteractionSource` 源；
- 在每个事件后对比当前 state 与记录中的 snapshot（可选）；
- 如有 FlowExecutionLog，可同时对比 Flow 步骤执行情况。

### 5.3 与 Effect 运行时的关系

在行为层，Flow DSL + `.flow.ts` 的 Effect 程序不需要为回放做特殊改动：

- Effect 只依赖 Env（services/state adapters）；
- 回放环境提供相同的 Env（或 stub）；
- FlowExecutionLog 作为“黄金记录”，可以在回放时比较新老 Effect 行为差异。

这样，一次回放本质上就是对 Behavior & Flow 意图 + Effect runtime 的完整集成测试。

## 6. 为什么这是意图驱动的核心能力之一？

当 Layout/View/Interaction/Behavior/Data/Code Structure 都被意图层结构化之后：

- Interaction 录制不只是“前端事件重放”，而是对整个 Intent/UseCase 的一次运行快照；
- 回放不只是“看 UI 动画”，而是测试：
  - 视图/组件是否按预期组合和更新；
  - 服务调用和状态更新是否符合 FlowIntent；
  - 代码结构是否仍然满足 Code Structure Intent 和 Constraint 意图（例如 never break userspace）。

做到这一点，平台就不仅仅是“帮你出码”的工具，而是：

> 一个能把“意图 → 模式 → Flow → 代码 → 运行行为”串成闭环，并用真实路径不断自证的系统。
</file>

<file path="specs/intent-driven-ai-coding/v2/06-intent-linking-and-traceability.md">
---
title: 意图关联与可追踪性（Linking & Traceability）
status: draft
version: 2
---

> 本文回答一个问题：当 Intent Studio 按意图层（Layout/View/Interaction/Behavior/Data/Code）分屏时，如何在界面上把同一个业务意图（Use Case）串起来，让产品/架构/前端都能围绕同一条线稿协作，而不是在多个孤立表单里迷路。

## 1. 业务锚点：Use Case 作为一切的中心

平台中的所有意图层视图都围绕“业务用例（Use Case）”展开，而不是围绕某个单独字段。

- 每个 Intent 下可以有一个或多个 Use Case：
  - 例如 `order-management` Intent 下：
    - `view-orders`：浏览列表；
    - `export-orders`：按条件导出；
    - `quick-edit-remark`：快速编辑备注；
    - `approve-order`：审批通过。
- Use Case 是一个轻量实体，包含：

```ts
interface UseCase {
  id: string
  intentId: string
  title: string
  description: string
  // 指向各意图层中的锚点
  layoutRegionIds?: string[]
  viewComponentIds?: string[]
  interactionEventIds?: string[]
  flowIds?: string[]
  entityIds?: string[]
  apiIds?: string[]
  moduleFileIds?: string[]
}
```

### 1.1 侧边栏：Use Case 列表 + 层级进度指示

在 Intent Studio 中，左侧固定一个 Use Case 列表：

- 每条 Use Case 一行，显示：
  - 标题（如“导出订单”）；
  - 六个小圆点：Layout/View/Interaction/Flow/Data/Code 的完成度（灰色=无定义，半填=草稿，实心=已确认）。
- 点击某个 Use Case 后，中间主视图切换到当前选中的意图层（例如 View Tab），并过滤出与该 Use Case 相关的内容。

这样，无论当前正看哪个视图，用户始终知道“自己在处理哪条业务线稿”。

## 2. 统一的交叉引用模型（ID）

为了让“点任何东西都能找到其它层的信息”，需要在 Schema 层约定一套统一标识符：

- Layout：`regionId`（filters/table/toolbar/metrics/...）；
- View：`componentId`（FilterBar/Table/Toolbar/...）；
- Interaction：`eventId` + `source`（toolbar.exportButton 等）；
- Behavior & Flow：`flowId`（exportOrders、updateRemark 等）；
- Data & State：`entityId`、`apiId`、`stateSourceId`；
- Code Structure：`fileId` 或 `path`（features/order-management/components/order-table.tsx 等）。

每一层的 Schema 都应包含对其它层的引用，例如：

- InteractionIntent.events[].source = `toolbar.exportButton`（指向 View/Layout）；
- FlowIntent.trigger.source = `toolbar.exportButton`，flowId 与 UseCase.flowIds 关联；
- FlowStepIntent.serviceId = `ExportService`，Data & State 里有 `apiId = exportOrders`；
- PlanActionV2 里携带 flowId/patternId/fileId 等元信息。

平台 UI 不展示这些 ID 本身，而是用它们来驱动“关联卡片”和跳转逻辑。

## 3. 关联在界面上的呈现方式

### 3.1 上下文卡片（Context Card）

在每个意图层视图右侧的 Detail 面板顶部，统一使用一个上下文卡片展示关联：

示例：在 Interaction 视图中选中 `triggerExport` 事件。

- 上下文卡片内容：
  - Use Case：chip `导出订单`（点击可折叠显示其描述）；
  - Trigger Source：chip `toolbar.exportButton`（点击跳到 View 视图并高亮对应按钮）；
  - Flow：chip `exportOrders`（点击跳到 Behavior & Flow 视图，并选中该 Flow）；
  - Entities/APIs：chips `Order`、`exportOrders`（点击到 Data 视图的对应行）；
  - Files：chips `flows/export-orders.flow.ts`、`services/order-export.service.ts`（点击到 Code Structure 视图）。

视觉上，这些是可点击的标签/徽章，而不是裸露 ID。它们背后使用统一模型查询其它意图层的相关实体。

### 3.2 高亮与联动

当用户在某一视图选中一个实体时：

- 当前 Tab 内：
  - 高亮列表或表格中的相关行；
  - Detail 面板展示更多字段与关联。
- 其它 Tab：
  - 在 Tab 标签上显示小红点或高亮，提示“有与当前 Use Case 相关的内容”；
  - 切换过去时自动选中最相关的实体（例如该 Flow 对应的文件）。

例如：

- 在 Flow 视图中高亮 `exportOrders`；
- 切换到 Interaction Tab 时自动高亮 `triggerExport`；
- 切换到 Code Structure Tab 时自动选中 `export-orders.flow.ts` 文件。

### 3.3 关联摘要视图

在 Use Case 层提供一个“关联摘要”视图：

- 用简约的表/树显示：

```text
Use Case: 导出订单

- Layout: toolbar (role=toolbar)
- View: toolbar-with-quick-edit (slot=toolbar)
- Interaction:
  - triggerExport (source=toolbar.exportButton)
- Behavior & Flow:
  - exportOrders (trigger=triggerExport)
- Data & State:
  - Entity: Order
  - API: exportOrders
- Code Structure:
  - flows/export-orders.flow.ts
  - services/order-export.service.ts
```

这样在做需求评审或设计回顾时，团队可以快速浏览某个 Use Case 的完整意图和实现覆盖面。

## 4. 表单 vs 画布：分工明确

界面上的主视图应以“列表/表格 + Detail 面板”为主，画布仅在关系表达更直观的地方出现：

- 表格/树：
  - 适合表达事件列表、字段/接口列表、文件/模块树等；
  - 便于筛选、排序、批量编辑。
- Detail 面板：
  - 容纳少量表单控件，对单个实体做精细编辑；
  - 避免整个页面被表单撑满。
- 局部画布：
  - Layout：网格线稿，只处理区域关系；
  - Flow：简化 DAG，表达服务调用/条件分支的流程关系；
  - 不承载全部配置，只用于帮助理解关系。

所有这些视图通过上下文卡片和关联 chips 串起来，让人感觉是在“透视同一个业务意图”，而不是在不同功能页面之间跳来跳去。

## 5. 角色视角下的关联导航

### 5.1 产品（或前端兼任）

- 从 Use Case 列表进入某个用例：
  - 先在 Layout/View/Data 视图里表达线稿；
  - 在 Interaction 视图中声明关键事件;
  - 通过上下文卡片看到有哪些 Flow/文件/模式会受到影响。
- 不必进入 Pattern/Flow/Code Studio 的编辑态，只需要能从当前视图跳到预览/摘要。

### 5.2 架构

- 在 Pattern/Flow/Code Studio 中打开相同 Use Case 的关联视图：
  - 看到来自 Intent Studio 的 Layout/View/Interaction/Data 线稿；
  - 对应地在 Pattern Studio 补模式、在 Flow Studio 补 Flow DSL/Effect、在 Code Studio 调整结构；
  - 通过关联摘要确认“这个用例的所有层面都已经覆盖”。

### 5.3 前端

- 在 Code Studio 或本地 IDE 中：
  - 从某个文件的“来源卡片”跳回对应的 Use Case 和意图层视图；
  - 例如：在 `export-orders.flow.ts` 的头部看到注释或链接：属于 Use Case=导出订单，FlowId=exportOrders；
  - 点击可在平台上打开 Behavior & Flow 视图，理解原始业务意图。

前端不需要手写 Intent/Pattern/Plan 的全部内容，但可以通过这些关联轻松找到“这段代码是为了满足哪个业务意图”。

---

通过以上机制，按意图层分屏并不会把东西拆散，反而让每一层都有自己的“编辑焦点”，同时可以在任何一层随时看到同一业务用例在其它层的映射和实现，真正做到“从意图到出码”的可追踪与可协作。
</file>

<file path="specs/intent-driven-ai-coding/v2/97-effect-runtime-and-flow-execution.md">
---
title: 97 · Effect 运行时与 Flow 执行
status: draft
version: 0
---

> 本文聚焦一件事：在 v2 模型下，如何基于 `effect-ts` 为 Behavior & Flow Intent 提供**确定性、可组合、可观测**的运行时，以及这层在平台中的职责边界。后续 PoC 可直接以本文件为蓝本。

## 1. 角色与目标

在整体架构中，Effect 运行时承担的角色是：

- **Behavior & Flow Intent 的唯一执行内核**：  
  - FlowIntent / FlowDslV2 表达“业务步骤链”；  
  - `.flow.ts` 中的 Effect 程序是其唯一合法运行时实现。
- **横切能力的集中落点**：  
  - 性能/重试/超时/熔断/审计/Tracing 等约束不散落在业务代码中，而统一通过 Layer/中间件实现；  
  - 这些策略来自 ConstraintIntent 和平台配置。
- **开发者 Escape Hatch 的保障者**：  
  - 开发者可以随时手写复杂 Effect 与自定义 Layer；  
  - 平台不要求理解其内部，只要签名清晰就能在 Flow 中调用。

目标边界：

- 能做：让「事件 → 流程步骤 → 服务调用 → 横切约束 → 可观测性」这一整条链条稳定且可追踪；  
- 不做：试图用 Flow/Effect 替代复杂领域算法本身（计费、推荐、风控内核等），这些保留为领域代码中的黑盒 Effect。

## 2. 从 FlowIntent / FlowDslV2 到 Effect 程序

核心链路：

```text
BehaviorIntent.flows[]        // 高层业务流程意图
    ↓ 规范化、补全约束
FlowDslV2                     // 声明式 AST（v2/03 中的类型）
    ↓ 编译（deterministic）
Effect 程序 (.flow.ts)        // TS 源码，供构建/运行时使用
```

### 2.1 FlowDslV2 回顾

`v2/03-assets-and-schemas.md` 中定义了：

- `FlowDslV2.id`：Flow 标识；  
- `trigger.eventId`：引用 InteractionIntent.events[].id，统一事件事实源；  
- `steps: FlowStepIntent[]`：业务步骤链；  
- `constraints?: ConstraintIntent`：该 Flow 的运行时约束（重试/超时/审计等）。

PoC 编译器需要实现：

- 对 `kind: 'callService' | 'branch' | 'delay' | 'parallel'` 等 step 做有限集转换；  
- 保证相同的 FlowDslV2 每次编译出的 Effect 结构相同（不依赖 LLM、无随机性）。

### 2.2 Effect 程序形态示例

以导出流程为例（简化）：

```ts
// 环境依赖：由 Layer 提供实现
export interface ExportOrdersEnv {
  FilterService: { getCurrentFilters: () => Promise<Record<string, unknown>> }
  TableUiStateService: { getCurrentState: () => Promise<{ visibleColumns: string[] }> }
  ExportService: { submitExportTask: (input: { filters: any; columns: string[] }) => Promise<void> }
}

export const exportOrdersFlow = (env: ExportOrdersEnv) =>
  Effect.gen(function* () {
    const filters = yield* Effect.promise(() => env.FilterService.getCurrentFilters())
    const tableState = yield* Effect.promise(() => env.TableUiStateService.getCurrentState())
    yield* Effect.promise(() =>
      env.ExportService.submitExportTask({ filters, columns: tableState.visibleColumns }),
    )
  })
```

原则：

- 编译器生成的是「结构化组合」（gen/flatMap/all 等），而不是内联业务逻辑；  
- 复杂业务逻辑（例如导出参数组装、权限判断）可以下沉到具体服务实现中。

## 3. 环境与 Layer 设计

### 3.1 Env：按服务分桶，而不是按 API 调用分桶

约定：

- 每个服务（领域服务或技术服务）在 Env 中有一个命名接口，例如 `OrderService`、`ExportService`、`AuditService`；  
- FlowStepIntent 中的 `serviceId/method` 只引用这些接口，不直接写 Http 细节。

好处：

- Flow 只依赖领域语义（服务+方法），具体调用 HTTP/消息队列/本地逻辑由服务实现决定；  
- 以后迁移基础设施（例如从 REST 改成 gRPC）时，不需要改 FlowIntent。

### 3.2 Layer：横切能力与平台默认实现

平台提供一个组合 Layer（示意）：

```ts
export interface PlatformDeps {
  Logger: Logger
  Tracer: Tracer
  Clock: Clock
  HttpClient: HttpClient
  Config: Config
  // ...
}

// 每个领域服务的 Layer，可以依赖 PlatformDeps
export const ExportServiceLive = Layer.effect(ExportServiceTag, makeExportService)

export const PlatformLayer = Layer.mergeAll(
  LoggerLive,
  TracerLive,
  HttpClientLive,
  ConfigLive,
  ExportServiceLive,
  // ...
)
```

ConstraintIntent 的信息（重试/超时/审计等）通过：

- 全局中间件 Layer：对所有服务调用通用注入；  
- 或按 Flow/Step 粒度配置的 Layer：从 FlowDslV2.constraints 中读取配置，再包一层。

开发者可以：

- 在测试中替换为 Mock Layer；  
- 在特定环境用自定义 Layer 覆盖平台默认实现（例如自定义日志、特殊 HttpClient）。

## 4. 与平台其它层的集成方式

### 4.1 代码生成与构建

CLI 流程建议：

- `imd intent apply`：  
  - 解析 Intent/FlowIntent，生成/更新 FlowDslV2 文件；  
  - 基于 FlowDslV2 编译 `.flow.ts` 文件（Effect 程序）；  
  - 放入遵循 Code Structure Intent 的目录（例如 `src/features/order/flows/*.flow.ts`）。

构建时：

- bundler 只看到普通的 `.ts` 源码和 Effect 程序；  
- FlowDslV2 可以选择是否参与运行时（只作为调试/文档存在）。

### 4.2 Flow Studio / Intent Studio 中的运行时体验

- Flow Studio：  
  - 使用同一套 Effect 程序，在沙箱 env 下执行 Flow，展示每一步的输入/输出/耗时；  
  - 结合 Layer 中的 Tracer/Logger，展示重试/超时/审计行为。
- Intent Studio：  
  - 在 Behavior & Flow Tab 中，左侧「步骤列表」对应 FlowIntent；  
  - 右侧 `.flow.ts` 预览仅供阅读/审查，不鼓励直接手改；  
  - 日后可以提供“从手写 Effect 反推 FlowIntent 草稿”的辅助工具，但不是主路径。

### 4.3 与 Interaction 录制/回放、可观测性的关系

- Interaction 录制：记录 eventId + 相关状态快照；  
- 回放：  
  - 使用同一 Flow 程序与 Layer，在沙箱中重放事件链；  
  - 与真实运行时的 trace 对比，发现行为偏差。  
- 监控：  
  - 每个 Flow 执行在 Tracer 中形成一个 span 树，携带 UseCase/Intent/FlowId 等上下文；  
  - 可以从告警直接跳回 Flow Studio/Intent Studio。

## 5. PoC 建议范围

为避免一口吃太胖，建议首轮 effect-ts PoC 聚焦以下能力：

1. **支持最小 Flow 步骤集**：  
   - `callService`（顺序调用）、`branch`（基于简单条件分支）、`parallel`（简单并行）；  
   - 先不实现 delay/复杂控制流。
2. **实现一个简单 Env + 1–2 个领域服务**：  
   - 如 `OrderService`、`ExportService`，用内存或简单 HTTP Mock 实现即可。  
3. **提供一个基础 PlatformLayer**：  
   - 内置 Logger（console）、简单重试策略、超时；  
   - 从 FlowDslV2.constraints 中读取重试/超时配置（即使暂时只支持少数字段）。  
4. **打通一条端到端演示线**：  
   - 选一个真实页面（例如订单导出），写 FlowIntent/FlowDslV2；  
   - 生成 `.flow.ts` 并在简单 React 页面中调用；  
   - 在 Flow Studio/简单控制台中展示执行日志。

PoC 目标不是功能覆盖 100%，而是验证：

- FlowIntent → FlowDslV2 → Effect 程序的编译路径是否清晰可维护；  
- Layer 能否方便地注入横切能力，而不侵入业务逻辑；  
- 这套运行时是否足以承载未来约束/可观测性/回放等蓝图。
</file>

<file path="specs/intent-driven-ai-coding/v2/98-intent-boundaries-and-open-questions.md">
---
title: 98 · Intent 边界与长期关注点
status: draft
version: 0
---

> 本文记录「Intent 边界」相关的约束、灰区与长期需要反复审视的问题。它不直接定义 Schema，而是作为设计/评审/演进时的参考清单。

## 1. 总体目标与风险提示

- 目标：让 Intent 尽可能承载“开发者脑子里的业务/交互意图”，而不是变成「换一种格式写代码」；
- 风险：一旦 Intent 层不断吸收组件/Hook/文件级细节，就会退化成 DSL 垃圾场，既难写也难演进，最后所有人绕回去直接写代码。

## 2. 横向原则回顾（适用于所有意图层）

- 只说 What，不写 How：  
  - Intent 描述“想要达成什么”：布局分区、用例、字段含义、流程步骤；  
  - 实现细节（组件实现、Hook 名、路径、Effect 组合）应由 Pattern/Template/Plan/代码层承担。
- 字段应尽量是业务/产品可读：  
  - 如果一个字段业务侧完全看不懂，多半属于实现细节，需谨慎放入 Intent。
- Intent 可以不完备，但核心要稳定：  
  - 允许只写 Layout + View + 核心 Behavior/Data，后续增量补充；  
  - 代码重构优先通过 Pattern/Template/Plan 吸收，不频繁修改 Intent。
- 默认编辑体验是线稿/用例视角：  
  - Schema/TS 视图是高级入口，不鼓励常规开发者在里头「写 DSL」。

## 3. 各意图层的典型灰区（需持续观察）

### 3.1 View & Component Intent

- 灰区例子：
  - `filters.layout: inline`：  
    - 若显著影响操作效率（例如运营工作台对横排/竖排有强诉求），可以视为业务决策（What）；  
    - 若只是视觉风格差异，则更接近实现细节（How），应交给 UI 层。
  - 列宽、对齐方式、Icon 选择等：  
    - 可能有业务含义（例如对齐金额、突出某字段），也可能只是视觉微调。  
- 长期关注点：  
  - 随着更多真实页被建模，需要统计哪些 View 配置经常被写进 Intent，但又频繁变更，提示这些配置可能不适合在 Intent 层承载。

### 3.2 Data & State Intent

- 灰区例子：
  - 状态是否缓存、过期策略等：  
    - 某些业务场景可能对缓存行为有强需求（例如「列表必须实时」）；  
    - 多数情况下这些属于实现层策略，适合放在 best-practice/配置而非 Intent。
- 长期关注点：  
  - 如何在「业务上希望的数据新鲜度/一致性诉求」与「具体缓存实现策略」之间保持清晰边界；  
  - 是否需要在 Data & State 层引入更抽象的“新鲜度策略”字段，而非直接配置缓存参数。

### 3.3 Behavior & Flow Intent

- 灰区例子：
  - 某些错误处理是否属于业务语义（例如审批拒绝的分支）还是纯技术重试/降级；  
  - 在 Intent 中表达「必须幂等」还是在 Effect/Layer 中通过策略约束。  
- 长期关注点：  
  - 行为层的粒度是否合适：如果同一 FlowIntent 频繁变动且很长，可能需要拆分成多个小 Flow 或提升抽象层级；  
  - 哪些“业务规则”应上升为 Behavior Intent 的一部分，哪些应留在领域服务代码中。

### 3.4 Interaction / Layout / Code Structure

- Interaction：  
  - Loading 状态、按钮禁用等即时反馈，有时既有业务含义又有实现意味，需要持续收集模式以决定放在哪一层最合适。  
- Layout：  
  - 列数/区域比例和具体栅格实现的边界；不同产品线可能有不同敏感度。  
- Code Structure：  
  - 模块拆分的粒度（一个 Intent 对应一个 feature 目录？多个 Intent 共享？）在不同团队实践中可能出现分歧。

## 4. 工具与指标：未来演进方向

> 本节内容不要求当前迭代立即实现，用于指引后续 CLI/遥测功能。

### 4.1 Intent Lint 规则候选

- `no-implementation-details`：  
  - 检查 Intent 中是否出现明显的实现细节字段（component/hookName/stateKey/import/path 等）；  
  - 初版可基于关键字匹配，后续结合 AST/Schema 做更精细判断。
- `business-readable`：  
  - 对描述性字段做简单检测，避免塞入大量内部变量名而缺乏业务语义。

### 4.2 稳定性与演进健康度指标

- 修改频率：  
  - 每个 Intent 在一定时间窗口内的变更次数，过高可能意味着抽象不当或边界不清。
- 修改深度：  
  - Layout/View/Data/Behavior 各层的变更分布，帮助判断是哪一层建模有问题。
- Plan diff 稳定性：  
  - 同一 Intent 在多次 apply 之间生成的 Plan 差异大小，过大说明 Intent→Plan 映射不稳定。

这些指标未来可用于：

- 为 Intent/Pattern/Flow 设计做健康度评估；  
- 辅助决定某些 schema 或边界是否需要调整。

## 5. 实践回流：用真实 feature 校正边界

- 建议：每当有一批真实 feature 完成 Intent 建模（特别是 Data/View/Behavior），就抽样做一次「Intent 边界回顾」：
  - 检查常见字段是否在 Intent 层承担了过多实现细节；
  - 梳理哪些信息在 Intent 和 Pattern/代码中重复出现；
  - 将新发现的 Anti-pattern 或灰区写回各层的 design 文档，并酌情补充 lint 规则。
- 目标：通过持续实践反哺，让 Intent 边界规范像 best-practice 一样，逐步从“经验”变成“约定俗成”。
</file>

<file path="specs/intent-driven-ai-coding/v2/99-long-term-blueprint.md">
---
title: 99 · 长期蓝图：画布 · LLM · 运行时
status: draft
version: 0
---

> 本文**只描述长期愿景与方向性设计**，不构成 v2/MVP 的交付范围。当前 M0–M3 仍以「Intent→Plan→代码」核心引擎为主，详见 `01-overview.md` 与相关设计文档。

## 0. 范围说明

- 本文汇总自：深度蓝图（画布/LLM/运行时）、实施建议报告以及 v2 设计文档中尚未纳入 MVP 的构想；
- 目标：给团队一个中长期「北极星」，在设计当前引擎时避免做出与这些方向冲突的决策；
- 原则：**不在当前迭代内承诺实现**，仅作为后续规划与优先级排序的输入。

---

## 1. 画布：从「画板」到「意图乐高底板」

### 1.1 Pattern-First 画布

- 工具箱以 **UI Pattern 为最小颗粒度**：
  - 如 `filter-bar`、`table-with-server-filter`、`workbench-layout` 等，而非 `<div>`/Row/Col 等原始元素；
  - 每个画布节点都绑定 `patternId` 与 `propsIntent`。
- 价值：
  - 把布局/视图编辑直接约束在团队认可的模式集合内；
  - 降低 LLM/用户在「组件选型」上的自由度，换来更高的一致性与可维护性。

### 1.2 Grid-Snapping 布局

- 画布基于响应式网格系统：
  - 用户只能调整「列数/区域占比」，而不是像素级坐标；
  - 所有区域映射到 `LayoutIntent.layoutType + regions + tree`。
- 价值：
  - 与设计系统一一对应，保证布局天然响应式；
  - LayoutIntent 可以长期稳定演进，不依赖具体 UI 实现。

### 1.3 Context-Aware 操作与可视化意图

- 上下文感知菜单：
  - 选中某个 Node/Container，出现有限的高价值操作（添加列、切换变体、绑定 Flow 等）；
  - 禁止全局「万能属性面板」，减少心智负担。
- 意图具象化：
  - 使用标记/图标将不可见意图可视化：
    - Interaction：节点之间的闪电/箭头线；
    - Data & State：字段/实体徽章；
    - Constraint：性能/安全标记；
    - Code Structure：面包屑路径。
  - 画布不仅是 UI 草图，也是 Intent 关系图。

### 1.4 Canvas 元素与六层意图映射

长期目标是 Canvas 与 Intent 模型一一对应：

| Canvas 元素 | 主映射意图 | 说明 |
| --- | --- | --- |
| Node | ViewIntent | 可见 UI 区块，对应一个 Pattern 及其 propsIntent |
| Container/Frame | LayoutIntent | 区域容器，对应 regions/tree 中的节点 |
| Connection/Wire | InteractionIntent | 事件连线：从 source 触发到 target 反馈 |
| Data Badge | DataStateIntent | 展示数据绑定（实体/字段/状态来源） |
| Behavior Node | BehaviorIntent / Flow | 在 Flow 视图中，每个节点是一个 Effect/步骤 |
| Breadcrumb | CodeStructureIntent | 显示当前画布内容映射到的模块/文件路径 |

实现 Canvas 时，应尽量遵守上述映射，以便：

- 从 Intent 生成画布视图；
- 从画布操作反向更新 Intent；
- 让 LLM 可以在「可视化 + Schema」双通道下工作。

---

## 2. 高阶交互：指令、连线与用例透视

本节描述的交互模式均为 **M4+ 之后的扩展能力**，需要在 Intent/UseCase/Flow schema 稳定后再逐步尝试。

### 2.1 指令行起局（0→1 魔法输入）

- 交互：在 Studio 顶部提供自然语言指令输入：
  - 例如：「创建一个用户管理列表，需要搜索和分页」；
  - LLM 生成 Layout/View/Data/Behavior 的草稿 Intent，以及初始 Canvas 布局。
- 效果：
  - 预览区渲染基础页面；
  - 左侧自动生成 UseCase 列表（查看/搜索/翻页等）；
  - 右侧以「AI 执行摘要」展示 LLM 做了什么。

### 2.2 Select & Command（框选 + 指令）

- 交互：
  - 在预览或 Canvas 区，对列/组件进行框选；
  - 弹出上下文命令栏，列出高频操作（如：合并列、开启排序、调整宽度等）；
  - 支持输入自然语言指令，如「给邮箱列加复制按钮」；
  - 平台/LLM 将操作映射为 ViewIntent/InteractionIntent 的修改。
- 价值：
  - 让常见视图变更变成「所见即所得」的直接操作；
  - 避免在复杂表单里寻找某个 props。

### 2.3 Intent Connector（意图连接线）

- 交互：
  - 激活连接模式（例如按住 Ctrl），从「搜索按钮」拖线到「用户列表」；
  - 弹出对话框询问「按钮被点击时要对列表做什么」；
  - 用户选择「刷新数据」/「滚动到顶部」/「自定义流程」；
  - 系统自动关联 InteractionIntent 与 BehaviorIntent/Flow。
- 前置条件：
  - InteractionIntent.events 作为事件事实源；
  - FlowIntent.trigger 使用 eventId 引用事件；
  - View/Layout 为元素提供稳定的 source 标识。

### 2.4 用例透视与渐进披露

- 默认视图：UseCase 透视
  - 左侧列表是业务用例（如「管理员搜索用户」「导出订单」）；
  - 中间/右侧聚合展示该 UseCase 相关的 Layout/View/Interaction/Flow/Data 片段。
- 高级视图：意图层级视图
  - 切换后按 Layout/View/Interaction/Behavior/Data/Code 维度展示全局；
  - 面向架构师和高级前端，方便做全局优化。
- 目标：
  - 日常开发以 UseCase 为中心，减少一次性面对 6+1 层意图的压力；
  - 向下兼容现有 `06-intent-linking-and-traceability.md` 的关联模型。

### 2.5 Escape Hatch：一键穿透 VS Code

- 交互：
  - 在任何 UI 元素/UseCase/Intent 详情旁提供 `<>` 图标；
  - 点击后打开本地 IDE，并定位到 Plan/Template 生成的核心代码文件与行号；
  - 长期目标是在 IDE 变更后，平台可感知 diff，甚至尝试反向更新 Intent。
- 依赖：
  - 稳定的 CodeStructureIntent/fileId/path；
  - PlanActionV2 中携带意图/UseCase/Flow 的来源信息。

---

## 3. LLM 与运行时：从草稿生成到动态守护

### 3.1 LLM 任务矩阵（长期）

在现有「LLM 协作原则」基础上，长期希望收敛出一套稳定的任务 API：

- `generate_intent_from_brief`：从自然语言/文档生成 Intent 草稿；
- `suggest_view_change_for_selection`：基于选中组件/区域生成视图修改建议；
- `draft_flow_from_story`：从用户故事生成 FlowIntent/FlowDsl 草稿；
- `reverse_engineer_intent_from_code`：从现有代码推导 IntentSpec 草稿；
- `explain_code_and_flow`：在 Escape Hatch 时，对代码与 Flow 执行路径给出解释；
- `propose_refactor_from_pattern_change`：当 Pattern/best-practice 进化时，给出自动重构建议。

这些任务都应：

- 产出结构化结果（Intent/Flow AST/diff 等），而非直接改文件；
- 通过 schema 校验、Plan 幂等与 AST merge 落盘；
- 记录命中率/回退率/冲突率，用于模型评估与 Prompt 调整。

### 3.2 Constraint Runtime：从静态约束到运行时守护

长期目标是让 Constraint Intent 不止影响出码，还能驱动运行时行为：

- 性能/重试/超时/熔断/审计等配置被编译为 effect-ts Layer 配置；
- Flow 执行时从 Layer 动态读取这些约束，并应用相应中间件；
- 可与 OpenTelemetry 等可观测性方案集成，让告警直接指向 UseCase/Flow/Intent。

这要求：

- ConstraintIntent schema 与 Flow/Layer 之间有清晰映射；
- 运行时配置与代码解耦，可热更新或干预，而无需重生成/部署代码。

### 3.3 意图驱动的自动重构与存量接入

- 当 Pattern/best-practice 进化时：
  - 平台扫描代码库，识别「旧模式」使用点；
  - 根据新 Pattern/Template 生成重构建议或直接发起 MR；
  - 重构操作走 Plan/AST merge，保证安全可回滚。
- 对存量项目：
  - 使用 LLM 分析已有页面/模块，生成 IntentSpec 草稿；
  - 支持「先只做视图/布局/数据投影」的部分接入路径，逐步引入 Behavior/CodeStructure 层。

---

## 4. 团队知识图谱与测试生成

### 4.1 意图依赖图与影响分析

- 构建跨层的「意图依赖图」：
  - 节点：Intent/UseCase/Pattern/Template/Plan/Flow/实体/API 等；
  - 边：引用关系、依赖关系、实现关系。
- 能力：
  - 当某个实体/API/Pattern 变更时，自动评估影响到哪些 UseCase/UI；
  - 在评审阶段可视化展示影响面，帮助决策是否接受变更。

### 4.2 基于 Behavior Flow 的测试生成

- 利用 BehaviorIntent/FlowDsl 生成端到端/集成测试骨架（Playwright/Cypress 等）：
  - Flow 中的步骤和断言转化为测试动作与期望；
  - 与 Interaction 录制/回放打通，复用场景数据。
- 目标：
  - 让测试用例对齐业务意图，而不是只针对控件级行为；
  - 提升测试覆盖率与可维护性。

---

## 5. 与当前 v2/MVP 的关系

- 本文所有内容**不进入**当前 M0–M3 的交付 checklist，只作为后续路线规划与设计约束参考；
- 现阶段进行的任何 schema/引擎设计，若与本蓝图冲突，应在评审时显式指出并权衡；
- 当 M0–M3 与首个端到端试点完成后，可从本蓝图中挑选少量高价值能力（例如 Escape Hatch、UseCase 透视）作为下一阶段目标。
</file>

<file path="specs/intent-driven-ai-coding/v2/SCHEMA_EVOLUTION.md">
---
title: Schema 演进与兼容性合同
status: draft
version: 1
---

> v2 的所有 Spec（Intent/Pattern/Template/Plan/Flow/UseCase 等）在演进时必须遵守本合同，确保“Never break userspace”。

## 1. 变更级别

- **新增字段**：必须可选且有合理默认，不得改变既有语义。
- **修改字段语义/结构**：先标记为 `deprecated`，提供迁移说明与脚本，至少经历两个小版本后才可移除。
- **删除字段**：仅在 deprecated 期满后执行，并提供自动迁移。
- **破坏性变更**（必然导致旧资产失效）：必须提供双向迁移器或长期开启读时兼容层，且需在版本发布说明中明确标注。

## 2. ID 与引用

- 六类意图、Use Case、Flow、PlanAction、TemplateBinding 等均使用统一 ID 规范（前缀+语义）。
- 禁止裸字符串引用外部实体：Flow.trigger 必须引用 Interaction.eventId，PlanAction 必须引用 patternId/templateId/fileId 等注册 ID。
- 重命名原则：提供批量迁移工具保证引用同步；无法自动迁移时需阻断发布并给出人工修复指引。

## 3. 事实源与投影

- Data & State：优先将实体/API 绑定到外部 schema（OpenAPI/TS 类型）；Intent 中的结构视为投影而非事实源。
- Interaction：事件 `source/event` 只在 Interaction 中定义，Flow/Behavior 必须引用事件 ID。
- Code Structure：Plan/Template 路径受 best-practice 目录规范约束；路径变更需提供兼容映射或迁移。

## 4. Plan/Template 的幂等与冲突

- `create-file`：文件存在时不得覆盖用户代码，需 no-op 或显式报冲突。
- `modify-file`/`append-snippet`：应基于锚点/AST 的精确 patch；多次执行结果应一致。
- 执行前必须支持 dry-run diff，执行后可重复运行，不得出现重复片段。

## 5. 兼容性验证与发布流程

- 每次 schema 变更需更新本文件对应条目，并在 changelog 标注兼容性级别。
- 破坏性变更发布前，需在真实仓库跑通一次“旧资产 → 迁移 → 新资产”的端到端验证。
- CLI/LSP 应内置版本检查：检测到不兼容资产时给出明确错误与迁移建议。

## 6. 迁移工具原则

- 优先提供自动迁移脚本；无法自动化的部分需给出最小可执行的手动步骤。
- 保持迁移幂等：重复运行不得损坏已迁移资产。
- 迁移脚本自身版本化，并在发布中记录适用范围与回退策略。
</file>

<file path="specs/intent-driven-ai-coding/README.md">
---
title: intent-driven-ai-coding · 总览
status: draft
version: 2
---

> 本目录记录“面向意图的 AI Coding 平台”的规划与演化：
> - 目标是在 IMD 组件库与 best-practice 仓库之上，构建一套以“意图”为中心的前端出码与运行时系统；
> - 让开发者/产品可以用线稿级的方式表达界面/交互/行为/数据/工程结构意图，由平台与 LLM 一起完成模式选择、Plan 生成、Flow/Effect 实现与代码落地。

## 原始诉求（梳理）

在本次讨论中，平台的核心诉求可以概括为：

1. **从“需求文本/口头沟通”到“可执行意图”**  
   - 面向未知需求，开发者/产品只需将需求转化为结构化的“意图线稿”，而不是立刻手写代码或调 UI 构建器。  
   - 这些意图线稿应覆盖前端开发的关键维度：布局、视图/组件、交互、行为流程、数据/状态、工程结构，以及横切的约束/质量。

2. **意图优先，模式/模板/代码退居其后**  
   - Intent/Pattern/Template/Plan/Flow 都只是承载意图的“载体”，而不是概念堆砌的目的本身；  
   - 平台先把意图层表达清楚，再用模式/模板/Plan 来实现这些意图；  
   - LLM 扮演“润色和补全线稿”的角色，而不是黑盒生成整页代码。

3. **避免历史低代码/无代码的陷阱**  
   - 不追求在平台里配置所有细节，而是：
     - 用少量高价值的交互/数据/行为“配方”（Pattern/Recipe）覆盖 80% 高频场景；
     - 对于复杂或边缘需求，允许随时“逃逸到代码”，并支持从代码反向提取意图；
   - 不再用一堆表单配置 event/data/state，而是优先用线稿 + 模式 + LLM 组合表达；
   - 平台要有“上限”：当开发者有清晰的工程结构意图时，仍能把这种复杂意图表达清楚并落地。

4. **以预览为中心的双视角原型工作台**  
   - 平台工作区以真实预览为中心：
     - 中间跑的是 React + Query + Store + Flow 的真实页面；
     - 左侧是 Intent/Use Case Outline；
     - 右侧是按意图层划分的编辑面板。  
   - 产品视角：通过拖区域、选模式、写自然语言、录交互等方式表达线稿意图；  
   - 技术视角：架构与前端可以从同一预览切换到 Pattern/Flow/Code Structure 视图，看到每个 UI/行为在代码/模式中的落点。

5. **Effect 驱动的行为层 + 录制/回放作为自证手段**  
   - 行为/流程意图通过 Flow DSL 与 `.flow.ts`（Effect 程序）落地：
     - FlowIntent 描述步骤链；
     - Flow DSL/AST 结构化表达；
     - Effect 负责运行时执行与质量约束（重试/超时/审计/日志/追踪）。  
   - Interaction 层的录制/回放不仅用于“看交互”，更是对整条 Flow/Effect 运行时的真实集成测试与压力测试：
     - 录制语义事件 + 状态快照 + Flow 执行轨迹；
     - 在受控沙箱中，用相同组件树 + 状态适配器 + Effect Env 重放；
     - 把这些脚本固化为 scenario，用于 CI 回归和运行时调试。

6. **与 IMD / best-practice 仓库深度结合**  
   - IMD 仓库提供 UI/Pro Pattern 与生成器能力；
   - best-practice 仓库提供 Code Structure、状态管理、service/adapter 等规范；
   - intent-driven 平台在这两者之上：
     - 将 Intent/Pattern/Template/Plan 与实际代码规范绑定；
     - 保证出码结构与团队既有规范一致；
     - 允许随着实践反馈迭代 Pattern/Template/Flow，而不推翻意图层资产。

7. **LLM 的定位：局部线稿润色器**  
   - 不期待 LLM 一次性生成完整应用，而是：
     - 读取 Intent/Use Case 的线稿；
     - 在特定意图层（Layout/View/Interaction/Behavior/Data/CodeStructure）提供“补全/建议/优化”；
     - 所有变更都要可视、可 diff、可回滚；
   - 这让平台可以“向 AI 借力”，但不丢失对意图和代码的掌控。

8. **Intent 的边界：表达“脑子里的意图”，不是换种格式写代码**  
   - Intent 要回答的是“我想达成什么业务/交互/信息结构”，而不是“具体调用哪个组件/API/放在哪个文件里写什么函数”；  
   - 每个字段都应偏向业务/产品决策（布局区域、用例、字段含义、流程步骤），工程实现细节（组件实现、Hook 名、文件路径）交给 Pattern/Template/Plan/代码层；  
   - Intent 更像需求/线稿的结构化载体，可以不完备，只要足以驱动模式选择和出码；实现细节随代码重构而变化时，Intent 不应频繁抖动。

## 目录结构与说明

目前规划按版本分为两个子目录：

- `v1/`：最初版本的规划与示例，偏资产视角（Intent/Pattern/Plan）与 PoC 探索；
- `v2/`：基于“六层意图模型”的重构版本，建议以后以 v2 为主阅读与演进。

`v2/` 主要文件：

- `01-overview.md`：意图分层与平台蓝图总览；
- `02-intent-layers.md`：六类意图（布局/视图/交互/行为/数据/工程结构 + 约束）的定义与 Schema 草图；
- `03-assets-and-schemas.md`：Intent/Pattern/Template/Plan/Flow/best-practice 与意图层的映射；
- `04-intent-to-code-example.md`：以订单管理列表为例的“从需求文本→意图线稿→IntentSpec→Pattern/Plan/Flow/Effect→代码骨架”的完整链路；
- `05-platform-ux.md`：平台界面与交互蓝图（Intent/Pattern/Flow/Code Studio，预览为中心，多角色多视图）；
- `06-intent-linking-and-replay.md`：意图层之间的关联模型与 Interaction 录制/回放机制。

`v2/design/` 下为各意图层的细化设计：

- `layout.md`：布局意图与网格线稿；
- `view-and-component.md`：视图/组件意图，与 UI Pattern 的关系；
- `interaction.md`：交互意图（事件与即时 UI 反馈）；
- `behavior-and-flow.md`：行为/流程意图，Flow DSL 与 Effect 运行时；
- `data-and-state.md`：数据/状态意图，与数据契约和状态管理规范的关系；
- `code-structure.md`：工程结构意图，模块/目录/文件出码规则；
- `constraints-and-quality.md`：约束与质量意图（性能/安全/兼容性/可观测性）。

这些文档共同构成了一个“意图优先、预览为中心、LLM 辅助、Effect 驱动行为层”的新一代前端出码平台蓝图。
</file>

</files>
