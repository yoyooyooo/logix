This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
checklists/
  requirements.md
references/
  01-domain-placement.md
  README.md
data-model.md
quickstart.md
spec.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="checklists/requirements.md">
# Specification Quality Checklist: Trait 生命周期桥接 × Form（以 StateTrait 为支点：数组/校验/异步，RHF≥）

**Purpose**: Validate specification completeness and quality before proceeding to planning  
**Created**: 2025-12-11  
**Feature**: specs/004-trait-bridge-form/spec.md

## 内容质量（SSoT 取向）

- [X] 允许出现 API/IR/示例代码（不锁死实现细节）
- [X] 叙事聚焦：Trait 生命周期桥接 × Form
- [X] 面向贡献者/Agent/架构师可读（非面向非技术干系人）
- [X] 必要章节齐全（定位/User Stories/FR/验收/quickstart/data-model）

## 需求完整性

- [X] 不再残留 [NEEDS CLARIFICATION] 标记
- [X] 需求可测试且无歧义
- [X] 成功标准可度量
- [X] 成功标准不锁死具体实现（技术栈无关）
- [X] 验收场景齐全
- [X] 边界/异常场景已覆盖
- [X] 范围边界明确
- [X] 依赖与假设已写明

## 交付就绪（面向 /speckit.plan）

- [X] 所有功能需求都有清晰的验收条件
- [X] User Stories 覆盖主干流程
- [X] 成功标准可在实现阶段验证（可观测/可回放/可对比）
- [X] API 表面积与所有权分层明确（TraitLifecycle vs StateTrait vs @logix/form）

## Notes

- 本仓库 `specs/*` 允许包含 TypeScript 作为“契约+示例”；用户文档（`apps/docs/*`）才要求避免内部术语与实现细节。
</file>

<file path="references/01-domain-placement.md">
# References: 领域放置决策（Form vs 独立领域包 vs Module+Logic 最佳实践）

> 目标：把“可编辑表格 / 规则配置器 / 动态表单引擎 / 任务编排面板 / 实时搜索联动”等真实 ToB 场景映射到我们的链路：  
> **Trait（内核）→（可选）StateTrait（支点）→ 领域包（Form/Query/…）→ UI 适配层**，用于压力测试 004 的假设，避免“为了 Form 假设一个不存在的世界”。

---

## 1. 三种产物形态（先定边界）

### 1.1 `@logix/core`（Trait kernel）

如果一个能力满足以下任意一条，就应该下沉到 kernel：

- **可回放链路的必要基础设施**：Ref（可序列化定位）、scoped validate/execute、cleanup 语义、Graph/Plan 推导；
- **跨领域复用概率极高**：不仅 Form，Query、Grid、Builder、Workflow 都会用到；
- **不携带领域话术**：不出现“字段/表单/提交”等语义也说得通。

在 004 的语境里：`StateTrait.*` 与 `TraitLifecycle.*` 是 kernel 归属。

### 1.2 `@logix/form`（领域包：Form）

如果一个能力满足以下全部/大部分特征，它属于 Form：

- **核心对象是“可提交的草稿（draft）”**：有“提交/保存/回填/重置”这一类生命周期；
- **错误主要以“字段错误/行错误/列表错误”呈现**：用户需要把错误稳定映射到输入控件；
- **交互态心智明确**：touched/dirty/submitCount 等（并且这些状态进入 `state.ui` 作为事实源）；
- **迁移对标对象存在**：RHF / antd form / 内部表单体系；需要写法映射规则。

`@logix/form` 的定位应是“**领域糖 + helper + 最佳实践协议**”，不是第二套运行时。

### 1.3 独立领域包（非 Form）

当领域的主心智不是“提交草稿”，而是另一类主模型时，应该抽成独立领域包（仍复用 kernel）：

- Query / Search：主语是“查询、缓存、竞态、分页、聚合、facet”
- Workflow / Task：主语是“任务状态机、重试/取消、进度、队列”
- Builder：主语是“结构化表达式（AST）、约束、解释、可视化”
- Grid：主语是“二维交互、批量编辑、粘贴、排序/筛选/分页”

这些包可以采用“像 Form 一样”的形状（Ref + scoped execute + cleanup + UI 双工状态），但**不应把语义硬塞进 Form**。

### 1.4 只给最佳实践（暂不出包）

以下情况更适合先写“Module + Logic 的最佳实践/模板”，而不是发新包：

- 能力很薄、复用边界不清晰；
- 还在探索真实需求，DSL 很可能推翻；
- 只是在某个行业/业务线出现一次，短期不值得固化成公共 API。

---

## 2. 放置判别框架（Occam 版）

把一个“看起来像 Form 的领域”过一遍下面这组问题即可定位：

### 2.1 这是不是“可提交草稿”？

- **是** → 倾向 `@logix/form`（或 `@logix/form-*` 上层扩展）
- **否** → 倾向独立领域包（Query/Workflow/Builder/Grid…）

### 2.2 错误模型是否以“字段级定位”作为主要交互？

- **是** → 复用 004 的 ErrorTree / FieldRef 能力（但未必属于 Form）
- **否** → 可能需要另一套“诊断/解释”模型（例如任务失败原因、查询失败原因、表达式不可满足）

### 2.3 交互态（ui）是否需要进入全双工可回放链路？

如果 UI 状态满足下面任一条，就应该进入 `state.ui`（仍由对应领域包维护）：

- 需要 time travel 重放（复现操作轨迹、定位 bug）；
- 需要 Devtools 解释“为什么现在被禁用/隐藏/不可点击”；
- 需要生成/回放脚本（录制回放、端到端自动化）。

### 2.4 Ref 的“身份锚点”是什么？

004 目前以 **path + listIndexPath/index** 为核心锚点（与 RHF 对齐）。但压力测试时需要辨别：

- **index 身份足够**：Form / 可编辑表格（多数场景） / facet 列表（多数场景）
- **需要稳定 identity**：表达式 AST 节点、工作流节点、队列任务（重排/过滤不应改变身份）

如果必须稳定 identity，说明：
- 仍然可以复用 `TraitLifecycle` 的“桥接模式”，但 Ref 的形状可能需要扩展（例如允许 `id` 锚点）；
- 这通常意味着“独立领域包”，而不是塞进 Form。

---

## 3. 典型领域的推荐归属（压力测试矩阵）

> 结论先行：**Form 不是“超级类库”**。我们要把“通用桥接能力”下沉到 TraitLifecycle，把“领域语义”留在各自领域包里。

| 领域 | 主心智 | 是否属于 Form？ | 推荐落点 | 对 004 的压力点 |
|------|--------|------------------|----------|------------------|
| 可编辑表格（Editable Grid） | 二维交互 + 批量编辑 | 不直接属于；更像 Form 的 UI 超集 | `@logix/form` 作为内核 + 上层 `@logix/grid`（或先最佳实践） | list.list 校验、批量粘贴触发 source 风暴、竞态策略、局部校验性能 |
| 规则配置器 / 条件构建器（Builder） | AST 编辑 + 约束 + 解释 | 否 | 独立 `@logix/builder`（或 `@logix/rules`） | 嵌套 list（多层）、Ref 是否需要稳定 id、错误定位与可解释性（不是“字段错误”） |
| 动态表单引擎（Schema-driven Form Engine） | 远端 schema → 渲染器 | 属于 Form 生态，但不是 Form 本体 | `@logix/form-engine`（构建在 `@logix/form` 之上） | 蓝图（schema）与实例（state）的边界；Schema transform 双向映射；运行时资源装配 |
| 任务编排/队列面板（Task Runner / Queue） | 状态机 + 进度 + 重试/取消 | 否 | 独立 `@logix/task` / `@logix/workflow` | source 的并发/取消语义、时间线可解释性、Ref 是否稳定（按任务 id） |
| 实时搜索 + 结果联动（Search/Facet + Detail） | 查询/缓存/竞态 | 否 | 独立 `@logix/query`（基于 Resource/EffectOp） | keyHash、switch/exhaust、去抖/节流、全双工 UI 状态（loading/error/selected facets） |

---

## 4. 与 004 主线的对齐方式（“同源形状”而非“都叫 Form”）

我们追求的是：未来 `xxxTrait` 也能“像 Form 一样好用”，但不是让所有领域都落进 Form。

建议的统一点（跨领域可复用）：

1) **TraitLifecycle（桥接模式）**  
   - install：把领域事件（actions）桥到 `state.ui` + scoped execute/validate + cleanup  
   - Ref：可序列化定位（用于 Devtools/TimeTravel/scroll-to-error/聚焦）  
   - scoped execute：按 Graph/Plan 推导最小执行集（避免全量）

2) **StateTrait（支点能力）**  
   - computed/source/link/check（以及 node/list/$root 组合子）是“领域 DSL 编译后的共同落点”

3) **领域包只做两件事**  
   - 提供更甜的语法糖（可读性/可生成/可迁移）  
   - 提供领域特定的错误/诊断映射（Form 的 ErrorTree、Query 的 QueryResult、Task 的 FailureReason…）

---

## 5. 对 004 的直接结论（你现在的问题怎么落地）

> “这些领域到底应归属 Form 体系下，还是直接 Module+Logic 最佳实践？”

- **Form 体系（`@logix/form`）只收口“可提交草稿 + 字段错误 + touched/dirty”这一类强语义能力**  
  其余领域应该复用 TraitLifecycle/StateTrait 的“同源形状”，但用自己的领域包话术。

- **可编辑表格**：先把它当作 **Form 的 UI 超集**，不要塞进 `@logix/form` 本体；更适合作为上层包或最佳实践，用它压力测试 list.list 校验/批量操作/竞态。

- **规则配置器**：更适合独立领域包（Builder），它会强迫我们思考“Ref 的身份锚点（path vs id）”这类 kernel 课题，但不该让 Form 背锅。

- **动态表单引擎**：属于 Form 生态的“应用层”，是验证“蓝图→Module”链路的最佳压测背景，但仍不应膨胀 `@logix/form` 的核心表面积。

- **任务面板 / 实时搜索**：属于 Query/Workflow，应该逼我们把 resource/竞态/时间线解释做得更硬，但它们的语义不应该进 Form。
</file>

<file path="references/README.md">
# 004 · References

本目录用于沉淀 `specs/004-trait-bridge-form` 的辅助材料（非主规范正文），包括：

- 背景对齐与“放置决策”（哪些领域应归属 Form、哪些应抽成独立领域包、哪些仅需 Module+Logic 最佳实践）
</file>

<file path="data-model.md">
# Data Model: Trait 生命周期桥接 × StateTrait（支点）× Form（Rules/ErrorTree/安装）

**Branch**: `004-trait-bridge-form`  
**Source Spec**: `specs/004-trait-bridge-form/spec.md`  
**Source Quickstart**: `specs/004-trait-bridge-form/quickstart.md`

> 作用：从「概念实体 + 关系」角度，把本特性在 trait 内核链路上要固化的通用形状梳理清楚：  
> - 以 **StateTrait** 作为支点跑通数组/错误树/资源/事务；  
> - 在其上构建 **Form 领域系统**（`@logix/form`：Rules/Error helpers/迁移映射）；  
> - 同时把“trait 生命周期桥接”下沉成可复用能力，便于未来更多 `xxxTrait` 复用同一条链路（install / refs / validate / cleanup）。  
> 优先面向：Trait/Runtime 实现者、Devtools / Studio 维护者。
>
> 相关 reference：  
> - StateTrait kernel 主模型与 Program/Graph/Plan：`specs/001a-module-traits-runtime/data-model.md`  
> - StateTrait kernel API 形状（computed/source/link/check/list）：`specs/001a-module-traits-runtime/references/state-trait-core.md`  
> - Resource / Query 约束：`specs/001a-module-traits-runtime/references/resource-and-query.md`  
> - Txn / Runtime 主线（表单最终落点）：`specs/003-trait-txn-lifecycle/spec.md`

---

## 1. 总览：Form 领域能力如何回落到 trait kernel

本特性不引入第二套表单运行时。**唯一运行时主线仍是 StateTrait → Program/Graph/Plan → Runtime/Txn/EffectOp。**

概念链路：

```text
（可选）Form 领域包（基于 trait 生命周期桥接）
  - Form.traits(...)
  - Form.Rule.make(...)
  - （未来可扩展）RHF 映射/迁移 helper
        │  编译为
        ▼
StateTraitSpec<S>（含 node/list/$root 组合子）
        │
        ▼
StateTrait.build
        │
        ▼
StateTraitProgram<S> + Graph + Plan
        │
        ▼
ModuleRuntime / StateTransaction / EffectOp
```

要求（对齐“Trait 生态”大目标）：

- `Form.traits / Form.Rule / Form.Error` 只负责生成/组合 kernel 友好的 `StateTraitSpec` 片段与 ErrorTree helper；  
- StateTrait.build/install 继续作为唯一的编译/安装入口；  
- Runtime / Devtools 只感知 kernel（computed/source/link/check/list）与 EffectOp，不感知 Form 领域糖的存在。
- `Form.*` 的落点为独立包 `@logix/form`（见 spec Clarifications 2025-12-12），以便把“表单领域能力”与 core kernel 解耦；`@logix/form` 只依赖 `@logix/core` 与 `effect`，不依赖 React 适配层。

---

## 2. 数组 Trait：StateTrait.list IR

### 2.1 StateTraitListSpec<S, TItem>

**角色**：描述某个数组字段在 `item` / `list` 两个输入域上的 Trait 能力集合（单行 / 整列）。

本特性把「resourceId」升级为可携带蓝图元信息的入参形态，但运行时事实源仍然是 string id：

```ts
type ResourceMetaHint = {
  readonly label?: string
  readonly description?: string
  readonly tags?: ReadonlyArray<string>
  readonly owner?: string
  readonly docUrl?: string
}

type ResourceRef = {
  readonly id: string
  readonly meta?: ResourceMetaHint
}

// DSL 层允许 string 或 ResourceRef；build 阶段必须归一化成 string resourceId。
type ResourceIdLike = string | ResourceRef

// 运行时约束（与 @logix/core/ResourceRegistry 对齐）：
// - 在同一 Runtime 作用域内，resourceId MUST 唯一（重复注册且实现不一致应在 dev 下报错）；
// - 跨 Runtime 作用域允许复用同一 resourceId（不同子树可注入不同实现），不视为冲突。
//
// 注入方式（组织最佳实践）：
// - 推荐：在 Runtime.make 的 Layer 中通过 Resource.layer([...specs]) 注入；
// - 局部场景也可在 ModuleImpl.imports 中注入 Layer（更贴近模块实现），语义等价。

// meta 冲突处理（只影响 Devtools/生成/诊断，不影响执行语义）：
// - 若同一 resourceId 在同一 Program 内出现多个不同 meta，dev 环境应 warning；
// - 采用确定性的 first-wins：按 ownerFields（引用该 id 的 fieldPath）字典序最小的那一处作为 canonical meta；
// - 不做 deep-merge，避免扩大心智与引入隐式规则。
//
// Devtools 展示优先级（只影响展示/诊断，不影响执行语义）：
// - ResourceRef.meta 优先；
// - 缺失字段再 fallback 到 ResourceSpec.meta 的同名字段（例如 description）；
// - 不做深合并、不引入语义字段。
// - 若同名展示字段同时存在且值不一致，dev 环境应 warning（按 resourceId+字段去重），提示“展示元信息分叉”。
// - tags 语义为分类标签（用于过滤/分组/检索）；Devtools 展示与索引时应对 tags 去重并按字典序排序，保证稳定可对比。
```

概念定义（IR 草图）：

```ts
/**
 * StateTrait.node：统一 DSL 形状（纯编译期组合子）。
 *
 * - 对标量字段：挂在字段路径上，input 是该字段值；
 * - 对 list.item：input 是单行（数组元素）；
 * - 对 list.list：input 是整列（ReadonlyArray<TItem>）；
 * - 对 $root：input 是整份 state。
 */
type StateTraitNodeSpec<Input, Ctx> = {
  /**
   * computed：按“目标字段”产值（不得返回任意 patch）。
   *
   * - key 为相对路径（相对当前 node scope）；
   * - value 是产出该目标字段值的纯函数。
   */
  readonly computed?: Record<
    // target：相对路径（相对当前 node scope）
    string,
    | ((input: Input, ctx: Ctx) => unknown)
    | Record<string, (input: Input, ctx: Ctx) => unknown>
  >

  /**
   * check：命名规则集合（ruleName -> 纯校验函数），返回错误树 patch。
   *
   * - 返回值 MUST 是“相对当前 scope 的错误 patch”（见 spec Clarifications 2025-12-12）；build/install 负责把它写回到 `state.errors` 的同构子树；
   * - 返回 `undefined` 表示该 scope “无错误”，运行时 MUST 清理该 scope 对应的错误子树（避免错误残留）；
   * - 规则可以读取更大 scope 的只读 state 以完成跨字段/跨行判断，但写入位置仍必须遵守 scope（例如 list.list 只能写该列表节点下的 `$list` 或各行错误）。
   */
  readonly check?:
    | ((input: Input, ctx: Ctx) => unknown)
    | Record<string, (input: Input, ctx: Ctx) => unknown>

  /**
   * source：按“写回目标字段”声明资源依赖。
   *
   * - key 为相对路径（写回目标字段）；
   * - value 是资源依赖声明（不包含 IO 实现）。
   */
  readonly source?: Record<
    string,
    {
      readonly resource: ResourceIdLike
      // 允许返回 undefined 表示“当前无有效 key”：不触发 IO，snapshot 回到 idle。
      readonly key: (input: Input, ctx: Ctx) => unknown | undefined
      // 触发集合：Form.traits 默认 ["onMount", "onValueChange"]；kernel 默认 ["manual"]。
      // 约束：若包含 "manual"，则必须严格等于 ["manual"]（与其它 trigger 互斥）。
      // 说明：kernel 统一用“状态语义”命名，避免与 UI 层事件混淆；UI 适配层可把 onChange/onBlur 映射为 onValueChange/onBlur。
      readonly triggers?: ReadonlyArray<"manual" | "onMount" | "onValueChange" | "onBlur">
      readonly debounceMs?: number
      readonly concurrency?: "switch" | "exhaust"
    }
  >

  /**
   * link：按“目标字段”声明联动来源（from 可为绝对路径或相对路径，编译期归一化）。
   */
  readonly link?: Record<
    string,
    {
      readonly from: string
    }
  >
}

/**
 * StateTrait.list：数组字段一等公民。
 *
 * - item：单行 scope（数组元素）；
 * - list：整列 scope（跨行/列表级）。
 */
type StateTraitListSpec<S, TItem> = {
  readonly kind: "list"
  readonly path: StateFieldPath<S> // 指向数组本身，如 "items"、"sections.items"

  // item/list 两个 scope 都是可选的：只写 item 即可覆盖绝大多数“行内表单”场景；
  // 当需要“跨行/列表级”规则/摘要时再声明 list（避免不必要的 API 表面积）。
  readonly item?: StateTraitNodeSpec<TItem, ItemCtx<S, TItem>>
  readonly list?: StateTraitNodeSpec<ReadonlyArray<TItem>, ListCtx<S, TItem>>
}
```

说明：

- `node/list` 都是 DSL 组合子：不引入新的运行时 kind；  
- build 阶段会把 node/list 展开为一组等价的 kernel Entry（computed/source/link，以及写 errors 的 check）：  
  - 主要落在 `items[]` 与 `items[].field` 级路径上的 computed/source/link/check；  
  - Graph 中可以看见「列表节点」以及 item/list scope 的依赖边；  
- `check` 仍是 computed 的语义糖：输出的错误 patch 会被写入 `errors` 子树（见第 4 节）。

### 2.2 source 写回：ResourceSnapshot

Form 场景中，source 目标字段写回的不是 raw data，而是可直接被 UI/Devtools 消费的快照。

概念定义（最小形态）：

```ts
type ResourceSnapshot<Key, Out, Err = unknown> =
  | { readonly status: "idle" }
  | { readonly status: "loading"; readonly key: Key }
  | { readonly status: "success"; readonly key: Key; readonly data: Out }
  | { readonly status: "error"; readonly key: Key; readonly error: Err }
```

约定：

- `StateTrait.source` 与 `node.source`（字段级 / list.item / list.list）写回的目标字段类型 SHOULD 是 `ResourceSnapshot<Key, Out, Err>`；  
- `resource` 入参允许 `ResourceIdLike`，但 build/plan/runtime 必须仅保留 string resourceId（`typeof resource === "string" ? resource : resource.id`）；`ResourceRef.meta` 只用于 Devtools/文档/生成，不得参与执行语义；  
- `computed/check` 通过读取 snapshot 来派生 options/disabled/错误提示等表单友好字段；  
- snapshot 的 status 变迁应可被 Devtools Timeline 观测（至少：进入 loading，成功/失败落盘）。
- `key` 允许返回 `undefined` 表示“当前无有效 key / 禁用”：此时不得触发 IO，目标字段写回 `{ status: "idle" }`（该禁用语义为 kernel 通用能力）；  
- 必须处理 key 竞态：当 refresh 返回时若当前 keySelector 推导的 key 已变化，则该返回结果视为 stale，必须丢弃（不得覆盖当前 snapshot）。  
  注意：所有比较/去重/竞态判断都必须基于 keySchema 规范化后的稳定 `keyHash`（见 2.3）。

### 2.3 keySchema 规范化与 keyHash（相等性 / 去重 / 竞态判断的唯一依据）

**目标**：让 Resource 的 key 在全双工链路中可对比、可回放、可诊断，避免对象引用或不稳定序列化导致的“误判相等/误判不等”。

约束：

- 运行时在执行 `source` 刷新前，必须先用 `ResourceSpec.keySchema` 对 key 做规范化（decode/normalize），得到规范形态的 `keyNormalized`；
- 运行时必须对 `keyNormalized` 计算稳定的 `keyHash: string`，并以 `keyHash` 作为：
  - 去重依据（相同 keyHash 可跳过重复 refresh）；
  - 竞态判断依据（stale 丢弃）；
  - Devtools Timeline/诊断事件的关联 id（建议展示 keyHash）。
- 禁止用对象引用相等或不稳定的 `JSON.stringify` 直接作为相等性依据。

实现层可以选择任何稳定方案（例如 canonical JSON + hash），但必须满足：

- 对同一个 `keyNormalized`，不同运行环境/不同进程/不同执行时刻得到的 keyHash 必须一致；
- 对不同的 `keyNormalized`，keyHash 冲突概率在工程上可忽略（允许记录在实现约束中）。

### 2.4 source 并发策略（concurrency）

`source` 的并发策略用于描述“同一 source 规则在 in-flight 时收到新的 refresh 触发该怎么办”，它不改变最终的竞态正确性（stale 丢弃仍然必须做）。

```ts
type SourceConcurrency = "switch" | "exhaust"
```

- `switch`（默认）：以最新 key 为准；in-flight 时触发新的 refresh，运行时 SHOULD 尽量取消旧 in-flight；无论能否取消都必须通过 keyHash 门控写回，丢弃 stale 结果。
- `exhaust`：in-flight 期间抑制新的 refresh 触发，但必须记录一次 trailing refresh（只保留最后一次）。当前请求结束后自动补发一次“最新 key”的 refresh（同样通过 keyHash 门控写回）。

### 2.5 list 相关路径语义

路径推导与合法性约束以 kernel SSoT 为准（`StateFieldPath<S>` / `StateAtPath<S, P>`）。本 spec 只强调数组的两类路径：

- **到数组本身**：`"items"`、`"sections.items"`，用于挂载 list；  
- **到任意元素及子字段**：`"items[].amount"`、`"sections[].items[].name"`，用于 item scope 内部依赖与 Devtools 展示。  
  `[]` 仅表示“任意 index 的元素”，元素身份语义默认按 index 理解（与 RHF 对齐）。

### 2.6 node/list/$root 的“展开”（编译映射，概念）

`StateTrait.node` / `StateTrait.list` / `$root` 都是 **DSL 组合子**：build 阶段必须把它们展开成 kernel 可执行的规则集合（computed/source/link + check 写 errors），以保证 Runtime/Devtools 只有一条主线。

本 spec 在 data-model 侧只固化以下几条“展开规则”（不锁死 TypeScript 具体 API）：

1. **相对路径解析**  
   - `node.computed` / `node.source` / `node.link` 的 key 是相对路径（相对当前 scope），build 阶段必须解析成绝对 target path；  
   - 对 list.item scope：相对路径只允许落在“单行元素子树”内（例如 `"ui.hideLevelAndScore"`）；  
   - 对 list.list scope：相对路径 SHOULD 优先落在“列表级目标字段”（如写回某个 `itemsMeta.*` / `meta.xxx` 字段），避免隐式地“批量 patch 多行字段”造成心智漂移；如确有“跨行计算后写回多处字段”的需求，优先通过显式的字段级 computed/link 规则表达，或退回 `$root` 统一编排。

2. **check 的写回位置（errors）**  
   - `field/node.check`：返回 FieldError（或命名错误 Record），写入 `errors.<fieldPath>`；  
   - `list.item.check`：返回 ItemErrorTree patch，写入 `errors.<listPath>[index]`（可包含 `$item`）；  
   - `list.list.check`：返回 ListErrorNode（数组节点 + `$list`），写入 `errors.<listPath>`；并允许同时写多行/多字段错误；  
   - `$root.check`：返回 GlobalErrorTree，从 `errors` 根写入（允许跨域写入多个位置）。  
   - 任意 scope 的 check 返回 `undefined` 表示“该 scope 无错误”，Runtime MUST 清理该 scope 对应的 errors 子树（避免残留）。
   - 当 `check` 使用命名规则集合（Record 形态）时，执行顺序与合并语义必须确定性（参见 spec FR-014）：按 `ruleName` 字典序执行并合并；同一路径 leaf 可合并为 `Record<ruleName, message>` 以保留多条错误。

3. **source 的写回位置（快照字段）**  
   - `source` 的 target 字段必须写回 ResourceSnapshot（见 2.2），并遵守 keyHash 去重/竞态门控（见 2.3）与并发策略（见 2.4）。

---

## 3. 上下文：ItemCtx / ListCtx / FormCtx

上下文类型用于在 list 的 computed/check/source/link 中向开发者暴露必要的只读信息。

### 3.1 ItemCtx<S, TItem>

```ts
interface ItemCtx<S, TItem> {
  readonly state: Readonly<S>              // 当前完整 State 快照（含 errors/meta）
  readonly path: StateFieldPath<S>         // 列表字段路径，如 "items"
  readonly listIndexPath: ReadonlyArray<number> // list 实例锚点（用于嵌套数组，如 [sectionIndex]）
  readonly index: number                        // 当前元素 index（0-based）；完整 indexPath = [...listIndexPath, index]

  // 实现层 MAY 提供便捷视图：
  // readonly items: ReadonlyArray<TItem>
  // readonly prevItem?: TItem
  // readonly nextItem?: TItem
}
```

### 3.2 ListCtx<S, TItem>

```ts
interface ListCtx<S, TItem> {
  readonly state: Readonly<S>
  readonly path: StateFieldPath<S>
  readonly listIndexPath: ReadonlyArray<number> // list 实例锚点（用于嵌套数组，如 [sectionIndex]）
  // 实现层 MAY 暴露 env/items 等扩展信息（不进入 SSoT 固定字段）
}
```

### 3.3 FormCtx<S>

```ts
interface FormCtx<S> {
  readonly state: Readonly<S>
  // 实现层 MAY 扩展 env / formId / locale 等
}
```

FormCtx 仅用于根级 check（跨字段/跨列表校验）。

### 3.4 FieldRef / ListRef（上层桥接的可序列化定位）

为了让 `@logix/form` / `@logix/react` 在不理解 kernel 内部实现细节的前提下，仍能做到 RHF 级别的局部校验、unregister、滚动到首错等能力，需要一套可序列化、可比较的“字段实例定位”。

概念草图：

```ts
type ListIndexPath = ReadonlyArray<number>

type ListRef<S> = {
  readonly path: StateFieldPath<S> // 指向数组字段本身，如 "items" / "sections.items"
  readonly listIndexPath: ListIndexPath // 嵌套数组锚点：外层 list 的 indexPath（如 [sectionIndex]）
}

type FieldRef<S> =
  | (ListRef<S> & {
      readonly kind: "list"
    })
  | (ListRef<S> & {
      readonly kind: "item"
      readonly index: number // 当前行 index
      readonly field?: string // 可选：行内相对字段路径（如 "amount" / "ui.hideLevelAndScore"）
    })
  | {
      readonly kind: "field"
      readonly path: StateFieldPath<S> // 标量/对象字段路径，如 "profile.email"
    }
  | {
      readonly kind: "root"
    }
```

说明：

- FieldRef 是“上层与 runtime 的桥接货币”，必须能稳定序列化（用于 Devtools、缓存、定位首错）。
- 不强求首版暴露 `field` 的完整类型推导；但必须能表达：field / list / item / root 这四种 target。

### 3.5 ValidateRequest（局部/全量校验触发）

为了支撑 “blur 才显示错误 / submit 全量 / change 局部复校验” 等策略，runtime 必须支持 scoped validate（见 spec FR-021）。

概念草图：

```ts
type ValidateMode = "submit" | "blur" | "valueChange" | "manual"

type ValidateRequest<S> = {
  readonly mode: ValidateMode
  readonly target: FieldRef<S>
  // 实现层 MAY 扩展：reason、traceId、sourceEvent 等
}
```

行为约束（概念）：

- validate 必须只执行“可能影响 target 的 check”（由 Graph/Plan 推导），避免无谓全量计算；
- validate 的写回仍然遵守本 spec 的 scope 规则：非 `$root` 不得跨域写 errors。

### 3.6 unregister / 行删除 / 重排（清理语义，概念）

为了避免“幽灵错误/幽灵请求回写”，runtime 必须在结构变更时做确定性清理（见 spec FR-021）：

- **unregister 字段**：必须清理对应 `errors` 子树与 `ui.touched/dirty` 标记；若该字段承载 source 快照，也必须把快照回收为 idle（或等价“未激活”状态），并确保 in-flight 结果不会再写回；
- **删除行**：必须按 index 身份语义移除该行对应的 `errors.items[index]` 与 `ui.*.items[index]`；并对受影响的 list.list 规则重新计算（至少在下一次 validate/submit 时保证一致）；
- **重排**：默认按 index 身份语义重新归属（与 RHF 一致）；errors 与 ui 标记必须随 index 移动保持同构。

---

## 4. 错误模型：ErrorTree for Arrays

本特性沿用 kernel 的「与值结构同构」错误树模型，并对数组做额外约定。

### 4.1 基本类型

```ts
type FieldError = string | Record<string, string> | undefined

// 单个元素的错误树（与元素值结构同构）
type ItemErrorTree<TItem> = {
  [K in keyof TItem]?: FieldError | ItemErrorTree<any>
} & {
  readonly $item?: FieldError // 行级聚合错误（可选）
}

// 列表字段错误节点：就是与值结构同构的数组（可附带 $list）
type ListErrorNode<TItem> = ReadonlyArray<ItemErrorTree<TItem> | undefined> & {
  readonly $list?: FieldError // 列表级聚合错误（至少一行/跨行唯一性等）
}

// 面向整份 State 的错误树
type GlobalErrorTree<S> = {
  [P in StateFieldPath<S>]?: unknown
} & {
  readonly $form?: FieldError // 表单级错误（可选）
}
```

约定：

- 数组字段错误节点直接是数组：`errors.items[i].field`；  
- 列表级错误统一挂在同一节点下的 `$list`：`errors.items.$list`；  
- `list.list.check` 允许返回“同时包含 `$list` 与多行错误”的 `ListErrorNode`：既能表达列表级摘要，也能准确落到具体行/字段（例如“orderNo 必须单调递增”需要标记若干行）；  
- 为了让 `ListErrorNode` 在 TypeScript 中可读、可写、可复用，`@logix/form` SHOULD 提供 `Form.Error.list(items, { list?: FieldError })` 一类的 helper 用于构造该形状，避免业务代码中出现类型强转或对数组对象的“魔法挂属性”；  
- 为了避免用户侧 API 入参出现 `$`，该 helper 的 opts SHOULD 使用更友好的字段名（例如 `{ list?: FieldError }`），并在 helper 内部写入 `$list`；错误树事实源仍然是 `errors.items.$list`；  
- 同理，行级聚合错误（`errors.items[i].$item`）也 SHOULD 提供对称 helper：`Form.Error.item(fields, { item?: FieldError })`，内部写入 `$item`，避免用户侧出现 `$item`；  
- 根级错误可使用 `$form` 表达“整张表单无效”；  
- 允许实现层用“路径字典”作为内部表示，但对外 SSoT 仅承认同构树模型。

---

## 5. Rules 语法糖（可选）

Rules 是面向日常表单开发的**可选领域糖**，用于把常用规则配置编译为 kernel 的 `check(input, ctx)`。

### 5.1 RuleConfig<V>

概念定义：

```ts
interface RuleConfig<V> {
  readonly required?: boolean | FieldError
  readonly min?: number | { value: number; message?: FieldError }
  readonly max?: number | { value: number; message?: FieldError }
  readonly minLength?: number | { value: number; message?: FieldError }
  readonly maxLength?: number | { value: number; message?: FieldError }
  readonly pattern?: RegExp | { value: RegExp; message?: FieldError }

  // 命名的自定义规则集合（同步）：异步/IO 一律通过 source + check/computed 表达
  readonly validate?: Record<
    string,
    (value: V, ctx: unknown) => FieldError | undefined
  >
}
```

说明：

- 规则能力对标 RHF rules；  
- `validate` 支持多条命名规则，便于 Devtools / Studio 展示与复用；  
- 异步校验不在 Rules 层直接做 IO：若需异步校验，应通过 source 声明资源依赖，再在 check/computed 中基于资源结果派生错误。

### 5.2 Form.Rule.make<V>(config)

**角色**：唯一规范入口。根据使用位置自动推断 input 域并产出等价的 `check` 函数。

概念签名：

```ts
namespace Form.Rule {
  function make<V>(config: RuleConfig<V>): (input: V, ctx: unknown) => unknown
}
```

产物的返回结构需符合第 4 节的 ErrorTree 约定。

---

## 6. Schema（effect/Schema）在 Form 领域的角色（边界校验 + transform）

Rules 与 Schema 不是“二选一”，而是分工协作：

- **Rules**：偏“输入体验/即时反馈”，运行在 field/item/list/root 的 `check` 槽位（最终写入 `state.errors`）。
- **Schema**：偏“提交/边界校验 + 字段名映射”，在 Form ↔ Domain 边界执行（decode/encode/transform）。

关键约束：

- Domain Schema decode 失败时，必须能把错误**映射回同一套 ErrorTree**，以便 UI 只消费 `state.errors` 一处事实源；
- 该映射由 `@logix/form` 的 helper/适配层负责（例如 `Form.Error.fromSchemaError(...)`），输出形态为：
  - root 位置：`GlobalErrorTree<S>`（允许落到 `errors.$form`）；或
  - 字段位置：写入与 FormView 同构的 `errors.<fieldPath>`（优先）。

实现层可选择任何 Schema 错误结构（例如 issue/path 列表），但对外承诺必须回落到本 spec 约定的 ErrorTree。

---

## 7. Form UI 交互态（touched/dirty 等）与全双工

本 spec 约定：表单交互态属于全双工可回放链路的一部分，SHOULD 存放在 Module state 的专用子树中（推荐 `state.ui`）。

目标：

- Devtools/TimeTravel 能回放 “用户如何一步步把表单弄到当前状态”（值变化 + 校验触发 + touched 变化）；
- 校验触发策略（如 blur 才展示、submit 后改为 change 复校验）可以纯粹地由 `state.ui` 决定，而不是散落在 UI 组件本地状态里；
- UI 层只负责把 DOM 事件映射为“值变化/失焦/注销”等领域事件，并由 `@logix/form` 将其写入 `state.ui`；kernel 不直接感知 DOM。

概念草图（只表达“专用子树 + 同构树”的心智，不锁死字段清单）：

```ts
type BoolTree<T> = unknown

// 建议的“同构布尔树”心智（概念）：字段就是字段、数组就是数组。
// 实现层允许内部用路径字典优化，但对外应保持同构读写体验。
//
// type BoolTree<T> =
//   T extends ReadonlyArray<infer A>
//     ? ReadonlyArray<BoolTree<A> | undefined>
//     : T extends object
//       ? { readonly [K in keyof T]?: BoolTree<T[K]> }
//       : boolean

type FormUiState<S> = {
  readonly touched?: BoolTree<S>
  readonly dirty?: BoolTree<S>
  readonly submitCount?: number
}

type StateWithFormUi<S> = S & {
  readonly ui?: FormUiState<S>
}
```

说明：

- `BoolTree<S>` MUST 与 FormView 值结构“同构”：字段就是字段、数组就是数组；不引入 `$list/$item`。以便开发者按同一路径读写（字段/数组元素同构）与 Devtools 可视化；实现上允许内部用路径字典优化，但对外心智建议同构树。
- `@logix/form` 负责维护 `state.ui` 的写入，以及在需要时触发 StateTrait 的局部/全量校验（validate）。

---

## 8. Form.traits 领域糖（可选）

Form.traits 用于把“表单视角的配置”收敛为可 spread 的 StateTraitSpec 片段，提升可读性，但**不增加新的 verbs**。

概念形态：

```ts
namespace Form {
  function traits<S>(
    schema: Schema.Schema<S, any>,
  ): (spec: {
    [P in StateFieldPath<S>]?: StateTraitEntry<S, P> | StateTraitListSpec<S, any>
  }) => StateTraitSpec<S>
}
```

说明：

- traits 只是帮助编排 list/check/source 的小工具；  
- 输出仍然是 kernel 的 `StateTraitSpec<S>`，最终交给 StateTrait.build/install。

---

## 9. TraitLifecycle.install（桥接 UI 事件 → state.ui → scoped validate）

本小节刻意把 “install” 从 Form 领域叙事里抽出来：它应该是 **Trait 生命周期**提供的通用桥接能力（见 spec FR-020/FR-021），用于把“上层领域事件”接到某个具体 ModuleRuntime 上执行。

Form 只是第一个吃到这套桥接能力的领域包：`@logix/form` 可以选择性地 re-export 这一能力（例如 `Form.install = TraitLifecycle.install`），但 API 的语义与所有权属于更底层的 Trait 生命周期。

概念职责：

- 监听（或约定）一组标准的 form action（例如 `form/valueChange`、`form/blur`、`form/validate`、`form/unregister`）；
- 在对应 action 到来时：
  - 更新 `state.ui`（touched/dirty/submitCount…，同构布尔树）；
  - 触发一次 scoped validate（向 runtime 发出 `ValidateRequest`），由 Graph/Plan 推导“需要执行哪些 check”；
  - 写回 `state.errors`（遵守 scope 规则与清理语义）。

示意（API 形状，不锁死实现）：

```ts
type FormInstallOptions = {
  readonly uiPath: string    // 推荐 "ui"
  readonly errorsPath: string // 推荐 "errors"
}

// install 的最小产物必须是可直接塞进 ModuleImpl.logics 的一段逻辑（ModuleLogic）
declare const TraitLifecycle: {
  install: <S>(module: unknown, opts: FormInstallOptions) => unknown
  Ref: {
    field: <S>(path: string) => FieldRef<S>
    list: <S>(path: string, listIndexPath?: ListIndexPath) => FieldRef<S>
    item: <S>(
      path: string,
      args: { readonly listIndexPath?: ListIndexPath; readonly index: number; readonly field?: string },
    ) => FieldRef<S>
    root: <S>() => FieldRef<S>
  }
}
```

说明：

- `TraitLifecycle.install` 必须发生在 **ModuleImpl/Runtime 作用域内**，因为 scoped validate 需要读取该模块的 StateTraitProgram/Graph/Plan 并对当前 state 执行；
- UI 层只负责 dispatch 领域 action（携带 FieldRef/ValidateRequest），不直接操作 `state.errors`。
</file>

<file path="quickstart.md">
# Quickstart: Trait→StateTrait（支点）→Form（领域包）——数组/校验/异步/可回放（RHF≥）

> 本文以 **Trait→StateTrait（支点）** 为主线，展示如何在不引入第二套运行时的前提下构建 Form 领域系统：  
> 规则/错误树/异步约束由 StateTrait（node/list/check/source）承载；Form 领域包（`@logix/form`）只提供语法糖与 helper；Trait 生命周期的桥接能力（install/refs/validate/cleanup）下沉为可复用能力，未来更多 `xxxTrait` 也可复用同一形状。
>
> 备注：`StateTrait` 是本 spec 选定的“第一个支点 Trait”，但不是强制中间层；未来某些领域也可以直接走 **Trait → Form（领域包）** 的链路。
>
> Kernel 只保留一套 verbs：
>
> - `computed`：纯派生（包含表单视图 meta/options 的派生）
> - `source`：异步资源依赖声明（真实 IO 在 ResourceSpec.load: Effect 中）
> - `link`：跨字段传播
> - `check`：语义糖，本质是“写 errors/诊断子树的 computed”
>
> 数组字段通过 `StateTrait.list({ item, list })` 一等公民化；`item/list` 两个 scope 内部用 `StateTrait.node({ ... })` 统一声明形状。  
> `Form.traits / Form.Rule` 仅作为**可选领域糖**，最终都会回落为等价的 kernel 结构。
>
> 备注：`StateTrait.list` 的 `item` / `list` 两个 scope 都是可选的。大多数表单只需要 `item`；只有在需要“跨行/列表级”规则或摘要时才声明 `list`。

## 1. 场景 1：订单行列表 + 前后行依赖

**业务描述**

- 用户在订单编辑页维护多行明细 `items[]`，每行包含：订单号 `orderNo`、供应商编码 `supplierCode`、金额 `amount`；
- 需要规则：
  - R1：当前行 `orderNo` 不能小于上一行 `orderNo`；
  - R2：当 `supplierCode` 不为空时，本行 `amount` 必须大于 1000；
- 增删 / 重排后规则语义保持稳定，错误准确落到对应行控件。

**推荐写法：StateTrait.list（kernel）**

```ts
import { StateTrait } from "@logix/core"
import { Form } from "@logix/form"
import { Schema } from "effect"

interface OrderItem {
  orderNo: number
  supplierCode: string | null
  amount: number
}

interface OrderFormState {
  items: OrderItem[]
  errors?: {
    // 数组字段错误节点就是数组本身（可附带 $list）
    items?: (Array<{
      orderNo?: string
      amount?: string
      $item?: string
    } | undefined> & { $list?: string })
  }
  // 表单交互态（全双工可回放）：由 @logix/form 维护（示意）
  ui?: unknown
}

const OrderFormStateSchema = Schema.Struct({
  items: Schema.Array(
    Schema.Struct({
      orderNo: Schema.Number,
      supplierCode: Schema.NullOr(Schema.String),
      amount: Schema.Number,
    }),
  ),
  errors: Schema.optional(Schema.Any),
})

export const OrderTraits = StateTrait.from(OrderFormStateSchema)({
  items: StateTrait.list<OrderFormState, OrderItem>({
    item: StateTrait.node({
      // 行内校验（R2）
      check: {
        amountWithSupplier: (item) => {
          if (item.supplierCode && item.amount <= 1000) {
            return Form.Error.item(
              { amount: "当选择供应商时，金额必须大于 1000" },
              { item: "本行校验失败" },
            )
          }
          return undefined
        },
      },
    }),

    list: StateTrait.node({
      // 列表级校验（R1：orderNo 单调递增）
      check: {
        nonDecreasingOrderNo: (items) => {
          const rowErrors = items.map(() => undefined as { orderNo?: string } | undefined)

          for (let i = 1; i < items.length; i++) {
            if (items[i]!.orderNo < items[i - 1]!.orderNo) {
              rowErrors[i] = { orderNo: "orderNo 不能小于上一行" }
            }
          }

          return rowErrors.some(Boolean)
            ? Form.Error.list(rowErrors, { list: "orderNo 必须单调递增" })
            : undefined
        },
      },
    }),
  }),
})
```

**可选：使用 Rules 语法糖**

在真实项目中，可以用 `Form.Rule.make` 组合常用校验规则，再挂到 kernel 的 `check` 槽位上：

```ts
import { StateTrait } from "@logix/core"
import { Form } from "@logix/form"

const orderItemCheck = Form.Rule.make<OrderItem>({
  validate: {
    amountWithSupplier: (item) =>
      item.supplierCode && item.amount <= 1000
        ? "当选择供应商时，金额必须大于 1000"
        : undefined,
  },
})

const orderListCheck = Form.Rule.make<ReadonlyArray<OrderItem>>({
  validate: {
    nonDecreasingOrderNo: (items) => {
      const rowErrors = items.map(() => undefined as { orderNo?: string } | undefined)
      for (let i = 1; i < items.length; i++) {
        if (items[i]!.orderNo < items[i - 1]!.orderNo) {
          rowErrors[i] = { orderNo: "orderNo 不能小于上一行" }
        }
      }
      return rowErrors.some(Boolean)
        ? Form.Error.list(rowErrors, { list: "orderNo 必须单调递增" })
        : undefined
    },
  },
})

export const OrderTraitsWithRules = StateTrait.from(OrderFormStateSchema)({
  items: StateTrait.list<OrderFormState, OrderItem>({
    item: StateTrait.node({ check: orderItemCheck }),
    list: StateTrait.node({ check: orderListCheck }),
  }),
})
```

---

## 2. 场景 2：语言选择规则（「无」选项联动）

**业务描述**

字段 `languages[]`，每行有：

- `type`: 语言类型（英语 / 日语 / 无）；
- `level`: 语言等级；
- `score`: 语言分数；

规则：

- R1：语言数量大于 1 条时，不展示「无」选项；
- R2：选择「无」后不能新增其他语言（隐藏新增按钮）；
- R3：选择了其他语言后不能再选「无」；
- R4：当语言类型为「无」时，隐藏 `level/score`。

**kernel 写法：meta 用字段级 computed，行内用 list.item.node**

```ts
import { StateTrait } from "@logix/core"
import { Schema } from "effect"

interface LanguageItem {
  type: "英语" | "日语" | "无" | string
  level?: string
  score?: number
  ui: {
    hideLevelAndScore: boolean
  }
}

interface LanguageFormMeta {
  canAddLanguage: boolean
  languageTypeOptions: string[]
}

interface LanguageFormState {
  languages: LanguageItem[]
  meta: LanguageFormMeta
}

const LanguageFormStateSchema = Schema.Struct({
  languages: Schema.Array(
    Schema.Struct({
      type: Schema.String,
      level: Schema.optional(Schema.String),
      score: Schema.optional(Schema.Number),
      ui: Schema.Struct({
        hideLevelAndScore: Schema.Boolean,
      }),
    }),
  ),
  meta: Schema.Struct({
    canAddLanguage: Schema.Boolean,
    languageTypeOptions: Schema.Array(Schema.String),
  }),
})

export const LanguageTraits = StateTrait.from(LanguageFormStateSchema)({
  // 列表级 meta：写在独立字段上（不在 list 内做 patch）
  "meta.canAddLanguage": StateTrait.computed((s) => {
    const hasNone = s.languages.some((i) => i.type === "无")
    const count = s.languages.length
    const maxLanguageCount = 5
    return !hasNone && count < maxLanguageCount // R2
  }),

  "meta.languageTypeOptions": StateTrait.computed((s) => {
    const hasNone = s.languages.some((i) => i.type === "无")
    const count = s.languages.length
    const allLanguageTypes = ["英语", "日语", "无"]

    // R1 + R3
    return hasNone || count > 1
      ? allLanguageTypes.filter((t) => t !== "无")
      : allLanguageTypes
  }),

  // 行内隐藏字段：写回到每行的 ui 字段（不依赖外部 UI runner）
  languages: StateTrait.list<LanguageFormState, LanguageItem>({
    item: StateTrait.node({
      computed: {
        "ui.hideLevelAndScore": (item) => item.type === "无", // R4
      },
    }),
  }),
})
```

UI 层只需读取：

- `meta.canAddLanguage`（是否展示“新增语言”按钮）；
- `meta.languageTypeOptions`（下拉选项过滤）；
- `languages[i].ui.hideLevelAndScore`（隐藏/展示行内字段）；

联动逻辑全部集中在 Traits 中。

---

## 3. 场景 3：合同选择 + 供应商异步约束

**业务描述**

- 选择「合同」后自动带出「供应商编码」并禁用手动修改；  
- 选择供应商编码后，异步拉取供应商信息，约束：
  - 「费用网点」下拉；
  - 「采购品类」下拉；
- 该场景常与列表表单组合（多行合同明细）。

**kernel 写法：list.item.node.source + computed**

```ts
import { Resource, StateTrait } from "@logix/core"
import { Effect, Schema } from "effect"

interface SupplierInfo {
  allowedFeeSites: string[]
  allowedCategories: string[]
}

type ResourceSnapshot<Key, Out, Err = unknown> =
  | { status: "idle" }
  | { status: "loading"; key: Key }
  | { status: "success"; key: Key; data: Out }
  | { status: "error"; key: Key; error: Err }

interface ContractLine {
  contractId: string | null
  supplierCode: string | null
  feeSite: string | null
  category: string | null

  // 由 source 写回的远程快照（ResourceSnapshot）
  supplierInfo?: ResourceSnapshot<{ supplierCode: string }, SupplierInfo>

  // 由 computed 派生的视图辅助字段
  feeSiteOptions: string[]
  categoryOptions: string[]
  supplierCodeDisabled: boolean
}

interface ContractFormState {
  items: ContractLine[]
  errors?: {
    items?: Array<{ supplierCode?: string }>
  }
}

// 资源 id 常量（纯数据：供 Traits/Devtools/生成使用；不承载 load 实现）
const SupplierInfoResource = {
  id: "SupplierInfo",
  meta: {
    label: "供应商信息",
    tags: ["form", "vendor"],
  },
} as const

// 供应商信息资源（统一定义在 Resource 体系中）
const SupplierInfoSpec = Resource.make({
  id: SupplierInfoResource.id,
  keySchema: Schema.Struct({ supplierCode: Schema.String }),
  load: (key: { supplierCode: string }) =>
    Effect.tryPromise({
      try: async () => {
        const res = await fetch(`/api/suppliers/${key.supplierCode}`)
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        return (await res.json()) as SupplierInfo
      },
      catch: (e) => e,
    }),
})

const ContractFormStateSchema = Schema.Struct({
  items: Schema.Array(Schema.Any),
  errors: Schema.optional(Schema.Any),
})

export const ContractTraits = StateTrait.from(ContractFormStateSchema)({
  items: StateTrait.list<ContractFormState, ContractLine>({
    item: StateTrait.node({
      // 1) 同步联动 + 远程结果派生（纯派生：每个字段各自产值）
      computed: {
        supplierCodeDisabled: (row) => !!row.contractId,

        // 合同 -> 供应商编码（禁用时强制回填；否则保持用户输入）
        supplierCode: (row) =>
          row.contractId
            ? deriveSupplierCodeFromContract(row.contractId)
            : row.supplierCode,

        // supplierInfo -> options
        feeSiteOptions: (row) => {
          const snap = row.supplierInfo
          const info = snap && snap.status === "success" ? snap.data : undefined
          return info ? info.allowedFeeSites : []
        },
        categoryOptions: (row) => {
          const snap = row.supplierInfo
          const info = snap && snap.status === "success" ? snap.data : undefined
          return info ? info.allowedCategories : []
        },
      },

      // 2) 异步资源依赖：供应商编码 -> supplierInfo（写回 ResourceSnapshot）
      source: {
        supplierInfo: {
          resource: SupplierInfoResource,
          triggers: ["onMount", "onValueChange"],
          debounceMs: 300,
          // 默认 switch：以“最新 key”为准（尽量取消旧 in-flight，且无论是否可取消都必须丢弃 stale）。
          // 若该资源请求成本高/需限流，可改用 exhaust：in-flight 期间合并触发，结束后补一次最新 key 的刷新。
          concurrency: "switch",
          key: (row) =>
            row.supplierCode
              ? { supplierCode: row.supplierCode }
              : undefined,
        },
      },

      // 3) （可选）基于资源结果派生错误
      check: {
        supplierInfoFailed: (row) => {
          if (row.supplierCode && row.supplierInfo?.status === "error") {
            return { supplierCode: "获取供应商信息失败" }
          }
          return undefined
        },
      },
    }),
  }),
})

function deriveSupplierCodeFromContract(contractId: string): string {
  // 真实项目中可通过 ctx.env / Resource 做映射，此处仅示意
  return contractId.slice(0, 8)
}
```

要点：

- 远程依赖只通过 `source` 声明 resourceId + key；  
- 对资源结果的 UI 影响只在 `computed/check` 中做纯派生；  
- 真实 IO 只在 `SupplierInfoSpec.load` 内部发生，由 Runtime/Middleware 统一调度。
- 当供应商编码高频变化导致请求乱序返回时，Runtime 会基于 snapshot.key 丢弃 stale 结果，避免旧 key 覆盖新 key。

---

## 4. 与 RHF 的映射心智（能力 ≥，路径不要求一致）

本 spec 的对齐目标是“**表达能力与错误模型 ≥ RHF**”，不是字符串路径 1:1 兼容。

示意表（概念）：

| 维度 | RHF 写法示例 | StateTrait 写法（概念） |
|------|--------------|-------------------------|
| 字段注册 | `register('items.0.amount')` | `StateTrait.list({ item: StateTrait.node({ ... }) })` 中直接访问 `row.amount` |
| 行级错误 | `errors.items?.[i]?.amount` | `list.item.node.check(row)` 写出 `errors.items[i].amount` 形状的错误 |
| 列表级错误 | `errors.items?.root` | `list.list.node.check(rows)` 写出 `errors.items.$list`（或等价节点） |
| 依赖上一行 | `validate` 中 `getValues()` | `list.list.node.check(rows)` 顺序遍历 `rows[i-1]` |
| 异步约束 | `setError/clearErrors` + 自管缓存 | `source + computed/check` + Resource/Query 统一接管 |

迁移时只需遵循「写法映射规则」，不强求无缝自动迁移。

---

## 5. Schema / transformer 集成示意（概念）

当 FormView 与 Domain/后端字段名不一致时，推荐通过 effect/Schema 的 transform 建立双向边界：

```ts
import { Schema, Effect } from "effect"

const FormOrderItemSchema = Schema.Struct({
  supplierCode: Schema.String,
  amount: Schema.Number,
})

const DomainOrderItemSchema = Schema.Struct({
  supplier_code: Schema.String,
  amount: Schema.Number,
})

const FormToDomainOrderItem = Schema.transform(FormOrderItemSchema, DomainOrderItemSchema, {
  decode: (form) => ({
    supplier_code: form.supplierCode,
    amount: form.amount,
  }),
  encode: (domain) => ({
    supplierCode: domain.supplier_code,
    amount: domain.amount,
  }),
})

// 提交前：
// const domainInput = yield* Schema.decode(FormToDomainOrderItem)(formItem)
// 回填时：
// const formView = yield* Schema.encode(FormToDomainOrderItem)(domainItem)
```

提交期（边界）校验建议同样放在 Schema decode 中，并把 decode 失败映射回同一套 ErrorTree（写回 `state.errors`），避免出现第二套错误来源：

```ts
import { Effect, Schema } from "effect"
import { Form } from "@logix/form"

// 提交时：FormView -> Domain
const submit = (formItem: unknown) =>
  Effect.gen(function* () {
    const domainInput = yield* Schema.decode(FormToDomainOrderItem)(formItem)
    return domainInput
  }).pipe(
    // 示例：把 Schema 错误映射为 ErrorTree（最终写回 state.errors）
    Effect.catchAll((schemaError) =>
      Effect.fail(Form.Error.fromSchemaError(schemaError)),
    ),
  )
```

Traits / Rules 只面对 FormView 字段名；字段名映射与深度业务校验由 Schema/transformer 在边界统一处理。

---

## 6. 与 Module / Logic 的集成示意（概念）

Form 场景的 Traits 仍然是 Module 图纸 traits 槽位的一部分：

```ts
import { Module, StateTrait } from "@logix/core"
import { Schema } from "effect"

const OrderFormStateSchema = Schema.Struct({
  items: Schema.Array(Schema.Any),
  errors: Schema.optional(Schema.Any),
})

const OrderTraits = StateTrait.from(OrderFormStateSchema)({
  items: StateTrait.list({
    item: StateTrait.node({ /* computed/source/link/check */ }),
    list: StateTrait.node({ /* computed/source/link/check */ }),
  }),
})

export const OrderModule = Module.make("OrderModule", {
  state: OrderFormStateSchema,
  actions: {},
  traits: OrderTraits,
})
```

心智：

- Module/Runtime 只有一条主线（StateTrait → Txn/EffectOp/Resource）；  
- Form 相关能力只是 traits 中的一类领域用法；  
- 可选的 `Form.traits / Form.Rule` 只是提升可读性，输出仍是等价的 kernel 结构。

---

## 7. `state.ui` + scoped validate（更贴近真实的最小片段）

> 目标：把 touched/dirty 等交互态纳入全双工链路，并展示“按目标局部校验”的调用方式（对齐本 spec 的 FieldRef/ValidateRequest 心智）。
>
> 说明：以下代码按本 spec 的规划给出“真实项目会怎么写”的代码形状：**动作（Action）是 UI→Runtime 的唯一入口**，TraitLifecycle 负责把动作桥接为 `state.ui` 与 scoped validate（写回 `state.errors`）。

```ts
import { Module, StateTrait, TraitLifecycle } from "@logix/core"
import { Form } from "@logix/form"
import { Schema } from "effect"

interface State {
  profile: { email: string }
  errors: { profile: { email?: string } }
  ui: {
    touched: { profile: { email?: boolean } }
    dirty: { profile: { email?: boolean } }
    submitCount: number
  }
}

/**
 * 可序列化 FieldRef（用于 onChange/onBlur/unregister/scroll-to-error 等）。
 * - path 为“目标字段路径”（root/field 都可表达）；数组定位由 listIndexPath 承载。
 */
type FieldRef<S> =
  | { readonly kind: "root" }
  | {
      readonly kind: "field"
      readonly path: string
      readonly listIndexPath?: ReadonlyArray<number>
    }

const FieldRefSchema = Schema.Union(
  Schema.Struct({ kind: Schema.Literal("root") }),
  Schema.Struct({
    kind: Schema.Literal("field"),
    path: Schema.String,
    listIndexPath: Schema.optional(Schema.Array(Schema.Number)),
  }),
)

const ValidateModeSchema = Schema.Union(
  Schema.Literal("submit"),
  Schema.Literal("blur"),
  Schema.Literal("valueChange"),
  Schema.Literal("manual"),
)

const StateSchema = Schema.Struct({
  profile: Schema.Struct({ email: Schema.String }),
  errors: Schema.Struct({
    profile: Schema.Struct({
      email: Schema.optional(Schema.String),
    }),
  }),
  ui: Schema.Struct({
    touched: Schema.Struct({
      profile: Schema.Struct({
        email: Schema.optional(Schema.Boolean),
      }),
    }),
    dirty: Schema.Struct({
      profile: Schema.Struct({
        email: Schema.optional(Schema.Boolean),
      }),
    }),
    submitCount: Schema.Number,
  }),
})

const Traits = StateTrait.from(StateSchema)({
  "profile.email": StateTrait.node({
    check: {
      required: (email) => (email ? undefined : "必填"),
      format: (email) => (/^\\S+@\\S+$/.test(email) ? undefined : "邮箱格式不正确"),
    },
  }),
})

export const FormModule = Module.make("FormModule", {
  state: StateSchema,
  actions: {
    // 领域动作：TraitLifecycle.install 监听并桥接为 state.ui + scoped validate（写回 state.errors）
    "form/valueChange": Schema.Struct({
      target: FieldRefSchema, // FieldRef<State>
      value: Schema.Unknown,
    }),
    "form/blur": Schema.Struct({
      target: FieldRefSchema, // FieldRef<State>
    }),
    "form/validate": Schema.Struct({
      mode: ValidateModeSchema,
      target: FieldRefSchema, // FieldRef<State>
    }),
    "form/unregister": Schema.Struct({
      target: FieldRefSchema, // FieldRef<State>
    }),
  },
  traits: Traits,
})

// 在 ModuleImpl 上安装 Trait 生命周期桥接（Form 只是领域包：可选择性 re-export）
const TraitBridgeLogic = TraitLifecycle.install(FormModule, {
  uiPath: "ui",
  errorsPath: "errors",
})

export const FormModuleImpl = FormModule.implement({
  initial: {
    profile: { email: "" },
    errors: { profile: {} },
    ui: { touched: { profile: {} }, dirty: { profile: {} }, submitCount: 0 },
  },
  logics: [
    // 1) 维护 state.ui：touched/dirty/submitCount（全双工可回放）
    // 2) 执行 scoped validate：把 check 输出写回 state.errors
    // 3) 执行 unregister 清理：errors/ui/source snapshot 都要回收
    TraitBridgeLogic,
  ],
})

// UI 层（React/其他）在 input 事件里只 dispatch 领域动作：
//
// const emailRef = Form.Ref.field<State>("profile.email")
// dispatch({ _tag: "form/valueChange", payload: { target: emailRef, value: next } })
// dispatch({ _tag: "form/blur", payload: { target: emailRef } })
//
// submit 时：
// dispatch({ _tag: "form/validate", payload: { mode: "submit", target: Form.Ref.root<State>() } })
```

要点：

- `state.ui` 是事实源：touched/dirty/submitCount 都是可回放状态；  
- validate 是显式动作：blur 局部、submit 全量；具体执行范围由 Graph/Plan 推导；  
- 规则写法仍然只依赖 traits 的 `check`（写 `state.errors`），不在 UI 层手动 setError/clearError。
</file>

<file path="spec.md">
# Feature Specification: Trait 生命周期桥接 × Form（以 StateTrait 为支点：数组/校验/异步，RHF≥）

**Feature Branch**: `004-trait-bridge-form`  
**Created**: 2025-12-11  
**Status**: Draft  
**Input**: User description: "和RHF看齐，起码>=它，支持下数组，创建个新的 spec，但是不切分支，我们只是先做规划"

---

## Positioning

本 spec 的大目标不是“做一个表单库”，而是：

- 以 **Trait** 作为内核抽象，明确 Trait 的生命周期与桥接契约；
- 以 **StateTrait** 作为“第一个支点 Trait”（最先跑通：数组、错误树、异步资源、可回放事务）；
- 在此之上建立一套 **Form 领域系统**（`@logix/form`），并保证同一条链路未来可以自然扩展到更多 `xxxTrait`：  
  上层领域包只是在复用 Trait 的标准化桥接能力（install / refs / validate / cleanup），而不是发明第二套运行时或第二套心智。

因此，本 spec 同时承担两类约束：

1) Form 领域需求（RHF≥：FieldArray、错误树、rules、schema/transform、异步约束）；  
2) Trait 生态需求（标准桥接模式 + 最小 API 表面积 + 可回放/可生成/可诊断）。

## API Surface（最小集合）

本 spec 的核心目标之一是“**把 Form 做成 Trait 生态的第一个示范，而不是额外一套体系**”。为此我们把对外 API 的所有权与表面积做如下分层收口（拒绝向后兼容，优先寻求新的完美点）：

- **Trait Kernel（应归属 `@logix/core`）**
  - `StateTrait`（支点 Trait）：`from/build/install` + kernel verbs（`computed/source/link`）与表单语义糖 `check`
  - `StateTrait.node / StateTrait.list / $root`：纯编译期组合子（build 阶段展开为 kernel entries）
  - `TraitLifecycle`：标准桥接 helper（`install / Ref / scoped validate / cleanup`），用于把上层领域事件（如表单 change/blur/unregister/submit）接到 Module/Logic 上执行

- **Form 领域包（归属 `@logix/form`，只做领域糖与 helper）**
  - `Form.traits(...)`：可选语法糖入口（输出可 spread 的 `StateTraitSpec` 片段）
  - `Form.Rule.make(...)`：常用规则工厂（可组合、可语义化命名，最终回落为 `check`)
  - `Form.Error.*`：ErrorTree 组合/映射 helper（例如 list/item/$list/$item 的辅助构造、SchemaError 映射）
  - （可选）re-export：`Form.install = TraitLifecycle.install`、`Form.Ref = TraitLifecycle.Ref`（仅为体验，不改变所有权）

- **UI 适配层（如 `@logix/react`）**
  - 负责把真实 UI 事件（onChange/onBlur/…）映射为领域 action，并调用/触发 `TraitLifecycle` 维护 `state.ui` 与 scoped validate
  - 不得引入第二套不可回放“本地错误/交互态事实源”

## References

- 领域放置决策（Form vs 独立领域包 vs 最佳实践）：`specs/004-trait-bridge-form/references/01-domain-placement.md`

## Clarifications

### Session 2025-12-11

- Q: 数组元素的「身份」默认是按 index 还是按显式 id 绑定（影响错误归属与 Trait 语义）？ → A: 默认按 index 语义理解数组元素身份（与 RHF 一致），Trait 与错误模型都以 `items[index]` 为基准；如需稳定 identity，可在业务层维护 `id` 字段用于 UI key 或展示，但本 spec 的核心 IR 不依赖该字段。
- Q: 数组字段下的错误结构默认是与值结构同构的树，还是以路径字符串为 key 的字典？ → A: 默认采用与值结构同构的错误树（例如 `errors.items[index].fieldName`），用于与 `state.items[index].fieldName` 一一对应；路径字典只作为实现与适配层的可选手段，不纳入本 spec 的主 IR。
- Q: 首版正式支持的嵌套数组深度是多少，`sections[].items[]` 是否作为一等公民纳入 scope？ → A: 首版明确支持「两层嵌套」数组（例如外层 `sections[]` 下的内层 `items[]`），规范中将其视为一等公民场景，并要求 StateTrait.list / 错误模型 / Devtools 在该形态下工作良好；更深层级（3 层及以上）不禁止，但视为高级用法，不承诺首版 Devtools 具备完备可视化。
- Q: 通过列表操作新增数组元素时，默认是否立即执行 item.check（校验），还是只执行 item.computed（派生）？ → A: 默认只执行 item.computed，用于填充默认值、隐藏字段与 options 等；item.check 只在既有校验触发时机（如提交、显式校验）下运行，不在新增一行时立即触发，以避免“新增即报错”的体验与不必要的性能开销。
- Q: 针对数组本身的「至少一行 / 最少 N 行」这类约束，默认应通过 Schema（StateSchema.minItems）定义，还是通过 list.check 声明为列表级业务规则？ → A: 默认认为数组字段在值模型层面允许为空，「至少一行 / 最少 N 行」一律通过 list.check 声明为列表级业务规则；对应错误落在列表级错误节点（例如 `errors.items.$list` 或等价结构），Schema 层不强制定义 minItems，只作为未来可能的补充能力。
- Q: 根级规则与 Rules 命名空间如何对齐，是否需要单独的 Form.build / FormSpec 包壳？ → A: 不需要。根级跨字段/跨列表校验直接落为 `StateTrait.check`（写入 `errors` 子树），Rules 命名空间提供 `Form.Rule.make(config)` 作为默认根级规则工厂（产出等价的 `check(state, ctx)`），Form.traits 仅是可选语法糖入口，最终都编译为 StateTraitSpec。
- Q: Rules 工厂是否继续保留在 `Form.Rule` 命名空间，而不是提升到 Form 顶层？ → A: 是。Rules 作为**可选领域糖**保留在 `Form.Rule`，Form 顶层（如存在）只提供 `Form.traits(...)` 这一入口用于生成可 spread 的 Trait 片段，避免引入新的运行时 kind 或第二套 verbs。
- Q: 数组字段的错误节点在错误树上是否直接是数组（`errors.items[i]`），而不是额外再包一层 `items` 对象？ → A: 是。列表字段的错误节点就是与值结构同构的数组：`errors.items[i].field`；列表级错误统一挂在同一节点下的 `$list`（`errors.items.$list`）。
- Q: 表单语义层是否保留独立的 async 槽位 / AsyncRule？ → A: 不保留。所有异步约束与远程派生统一通过 kernel 的 `source + computed/check` 组合表达；如 Form.traits 提供便利写法，也只能映射为等价的 `source` 规则，不引入 onSuccess/onError 回调式 IR。
- Q: Trait / Form 领域糖里是否允许直接返回任意 Effect 作为异步执行体？ → A: 不允许。IO/异步实现必须收敛在 ResourceSpec.load（Effect）中，由 Runtime/Middleware 统一触发与接管；Trait 侧只做资源依赖声明与纯派生（computed/check）。
- Q: 跨字段/跨列表联动校验默认推荐写在根级 check 还是局部 check？ → A: 两者都允许；默认优先局部 check（贴近字段/列表归属、便于读写与局部复用），仅当规则需要同时写多个域的错误、或更适合集中维护时使用根级 check；用户文档需同时给出两种写法与取舍。
- Q: Form 场景的错误树根节点是否统一约定为 `state.errors`？ → A: 是。Form 场景统一以 `state.errors` 作为错误树根；所有 `check`（字段级 / item / list / root）默认写入同构的 `errors` 子树（如 `errors.items[index].field`），不额外引入可配置的 errorRootPath。
- Q: FieldError 的形状是否允许“多条命名错误”（对齐 RHF `types` / `criteriaMode="all"`）？ → A: 允许。`FieldError` 统一为 `string | Record<ruleName, string>`（无错误为 undefined）；默认返回 string（单条错误），需要多条/命名规则时返回对象以保留上限与 Devtools 可视化。
- Q: kernel 的 check/computed 是否支持 `Record<ruleName, fn>` 作为命名规则集合（单函数为语法糖）？ → A: 支持。`check/computed` 同时允许单函数与 Record 形态；当使用 Record 形态时，ruleName 作为诊断/展示的一等信息进入 Devtools 与错误树 leaf（Record 形态）。
- Q: 多条命名 check/computed 规则的执行顺序与合并语义是什么？ → A: 采用确定性深合并：Record 形态按 `ruleName` 字典序依次执行；返回 patch 做 deep‑merge。`check` 叶子若来自多条命名规则，合并为 `Record<ruleName, message>`（同名覆盖）；`computed` 叶子冲突时 last‑writer‑wins，dev 环境给出 warning。
- Q: Form 场景声明的 source 是否默认自动触发？触发枚举叫什么，并为 React 的 onBlur 等事件预留扣子吗？ → A: 是。Form.traits 中声明的 source 默认启用自动触发，触发枚举命名为 `onValueChange`（而不是 onKeyChange），并允许配置 `debounceMs`（仅对 onValueChange 生效）；同时预留 `onBlur` 等 UI 事件触发位：短期可由 @logix/react 的表单绑定层在对应事件发生时显式调用 refresh，长期可将这些事件纳入统一的 triggers 语义。
- Q: source 字段写回的值是否需要包含 loading/error（表单与 Devtools 可直接消费）？ → A: 需要。source 统一写回 `ResourceSnapshot`（`status: "idle" | "loading" | "success" | "error"` + `data?/error?`），而不是仅写回 raw data；表单/Devtools 直接读 snapshot，视图层再通过 computed/check 派生 options 与用户可见错误。
- Q: `ResourceSnapshot` 是否需要携带本次请求参数（resource key）用于 Devtools/回放/排查？ → A: 需要。snapshot 必须携带 `key`（与 ResourceSpec.keySchema 对齐），用于识别“当前数据对应哪个 key”与处理 key 变化下的竞态。
- Q: key selector 是否允许返回 undefined 表示“禁用/不触发”，并把 snapshot 置回 idle？ → A: 允许。key selector 返回 undefined 时视为“当前无有效 key”，不得触发 IO，目标字段写回 `{ status: "idle" }`（不携带 key）。
- Q: 当 key 高频变化导致请求乱序返回时，是否丢弃 stale 结果避免旧 key 覆盖新 key？ → A: 丢弃 stale 结果。只有当返回结果的 key 仍等于“当前 keySelector 推导的 key”时才允许写回 snapshot；否则忽略该结果，保持当前 snapshot 不被覆盖。
- Q: key 的“相等性/去重/竞态判断”是否基于 keySchema 规范化后的稳定 hash（keyHash）？ → A: 是。运行时必须先用 `ResourceSpec.keySchema` 规范化 key，再计算稳定的 `keyHash`，并以 `keyHash` 作为唯一的相等性/去重/竞态判断依据（而不是对象引用或不稳定的 JSON stringify）。
- Q: trait 触发的 resource 请求在竞态下是否允许选择并发策略（switch/exhaust）？ → A: 允许。每个 source 规则可选 `concurrency: "switch" | "exhaust"`（默认 `switch`）：`switch` 以“最新 key”为准（尽量取消旧 in-flight，且无论能否取消都必须丢弃 stale 结果）；`exhaust` 在 in-flight 期间忽略新的触发，但会记录一次 trailing refresh，当前请求结束后自动补一次“最新 key”的刷新（仍需 stale 丢弃）。

### Session 2025-12-12

- Q: 是否引入 `StateTrait.node` 作为统一 DSL 形状，并将数组 scope 命名从 perItem/perList 收敛为 item/list？ → A: 是。`StateTrait.node` 作为纯编译期组合子统一承载 `computed/check/source/link` 的声明形状；数组字段通过 `StateTrait.list({ item, list })` 表达两种输入域（单行/整列），不再使用 per* 前缀，降低心智负担并为未来 *Trait 同源形状铺路。
- Q: Form.traits 声明的 source 默认触发是否包含 onMount（用于编辑/回填时初始拉齐依赖资源）？ → A: 包含。Form.traits 的 source 默认采用 `triggers: ["onMount", "onValueChange"]`：既保证初始有值时能自动拉齐依赖资源，也保证输入变化时实时更新；若担心资源风暴，可改为 `triggers: ["manual"]` 或配合 `concurrency: "exhaust"` 与 `debounceMs` 收敛触发频率。
- Q: triggers 是否允许包含 "manual"，以及能否与其它触发混用？ → A: 允许包含 "manual"，但必须严格独占：只能写成 `triggers: ["manual"]`，不得与 `onMount/onValueChange/onBlur` 等混用，避免“既自动又手动”的歧义。
- Q: source.resource 是否允许传对象以承载蓝图元信息？这些元信息是否影响运行时语义？ → A: 允许。`resource` 允许为 `string | ResourceRef`（`{ id, meta? }`），运行时只使用 `.id` 查找 ResourceRegistry；`meta` 仅用于 Devtools/文档/代码生成等“蓝图展示/诊断”，不得影响运行时执行语义（否则会破坏全双工可回放与边界清晰）。
- Q: 同一 resourceId 在同一 Program 内出现多个不同 ResourceRef.meta 时如何处理（只影响展示/诊断）？ → A: dev 环境给出 warning 并采用确定性 first-wins：按 ownerFields（使用该 resourceId 的 fieldPath）字典序最小的那一处作为 canonical meta；其它 meta 不参与合并。建议工程内始终维护“每个 id 一个 ResourceRef 常量”避免冲突。
- Q: ResourceRef 的工程组织（id/spec 是否强制拆分文件）？ → A: 不强制。文档给出推荐组织方式（例如 id/spec 拆分）以降低耦合与 bundle 风险，但允许在小项目或局部场景把 id/spec 放在同一个文件里。
- Q: ResourceRef.meta 是否开放任意 Record，还是白名单字段集合？ → A: 白名单字段集合（`label/description/tags/owner/docUrl`）。meta 只服务于展示/诊断/生成，不允许演进成半套配置系统；运行时语义字段必须留在 ResourceSpec.meta / Middleware 配置中。
- Q: Devtools 展示资源信息时，ResourceRef.meta 与 ResourceSpec.meta（如 description）同时存在如何取舍？ → A: merge（只影响展示）：ResourceRef.meta 优先；缺失字段再 fallback 到 ResourceSpec.meta 中同名字段（例如 description），不做深合并，不引入执行语义。
- Q: 当 ResourceRef.meta.description 与 ResourceSpec.meta.description 同时存在且不一致时，Devtools 是否应在 dev 环境提示？ → A: 是。dev 环境 SHOULD 给出 warning（按 resourceId+字段去重），提示“展示元信息分叉”，但不影响执行语义；展示仍遵循 ResourceRef 优先、缺失再 fallback 的规则。
- Q: ResourceRef.meta.tags 的语义是否规范为“分类标签”（用于 Devtools 过滤/分组），并要求展示层做去重+排序以保证稳定性？ → A: 是。tags 只用于展示侧的分类/过滤/分组，不影响执行语义；Devtools 展示与索引时应对 tags 做去重与字典序排序，保证全双工稳定可对比。
- Q: keySelector 是否允许返回 undefined 作为通用的“禁用/无有效 key”语义（不仅 Form.traits）？ → A: 允许。kernel 的 `StateTrait.source` 允许 `keySelector` 返回 `undefined` 表示“当前无有效 key / 禁用”，此时不得触发 IO，并将目标字段写回为 idle 快照（Form 场景为 `{ status: "idle" }`）；Form.traits 只是默认给出更甜的 triggers，但 key=undefined 的禁用语义是 kernel 的通用能力。

### Session 2025-12-12

- Q: `check` 的返回值在不同作用域下是否必须是“相对 scope 的错误 patch”，还是一律从 `state.errors` 根写 GlobalErrorTree？ → A: 必须是相对 scope 的错误 patch：field/node 返回 FieldError；list.item 返回 ItemErrorTree；list.list 返回 ListErrorNode（数组节点，允许同时写 `$list` 与多行）；仅 `$root.check` 才返回 GlobalErrorTree（从 errors 根写入）。
- Q: Form 领域糖（`Form.traits` / `Form.Rule`）的落点是新增包还是放在 core？ → A: 新增独立包 `@logix/form`：只承载“表单领域糖与 helper”（Rules / traits / 迁移映射），不引入第二套运行时；最终必须编译为等价的 `@logix/core` StateTraitSpec（kernel 主线仍是 StateTrait → Program/Txn/EffectOp/Resource）。
- Q: 跨行/列表级联动校验在 `list.list.check` 下的写入能力如何定义（只写 `$list` 还是也能写行级错误）？ → A: `list.list.check` 允许同时写 `$list` 与任意行/字段的错误（`errors.items[i].x` / `errors.items[i].$item`），以覆盖真实 ToB 场景；其返回值仍是相对 scope 的 ListErrorNode（数组节点 + `$list`），不要求回退到 `$root`。
- Q: 嵌套数组（如 `sections[].items[]`）下的 ctx 如何提供最小且可扩展的定位信息（便于规则读取上下文）？ → A: 采用 `listIndexPath + index`：list ctx 固化 `listIndexPath`（list 实例锚点，如 `[sectionIndex]`）；item ctx 固化 `listIndexPath + index`（可拼出完整 indexPath），避免把所有层级都摊平进 ctx 字段，同时保持两层嵌套一等公民。
- Q: `StateTrait.list` 的 `item/list` 两个 scope 是否必须同时声明？ → A: 不必须。`item` 与 `list` 都是可选的：默认只声明 `item`（每行规则/派生/资源）；只有在需要“跨行/列表级”规则或摘要（如唯一性、单调性、最少 N 行）时才补充 `list`，避免无谓的 API 表面积。
- Q: `source.triggers` 的命名应更偏“状态语义”还是更贴近 UI 事件？ → A: kernel 统一使用状态语义命名：`onValueChange`（保留 `onBlur`），避免与 UI 层事件混淆；React 适配层负责把 input 事件映射为值变化触发。
- Q: 校验能力在 Rules（RHF rules 对标）与 Schema（effect/Schema）之间如何分工？ → A: 采用双轨但同构落盘：Rules 负责“输入体验/即时反馈”（field/item/list/root 的 check），Schema 负责“提交/边界校验 + transform”（decode 失败需可映射回同一套 ErrorTree）；两者产出的错误最终都落在同构的 `state.errors`，不要求开发者二选一。
- Q: Schema 解码错误映射（helper）应归属到 `@logix/form` 的哪个命名空间？ → A: 归属到 `Form.Error`：`Form.Error.fromSchemaError(error)`，因为它本质是“错误结构与映射”，而不是校验规则本身；`Form.Rule` 只负责产出 `check`。
- Q: FieldError leaf 是否要支持 RHF `criteriaMode="all"` 那种“多条命名错误”（保留校验上限）？ → A: 支持。`FieldError` 固化为 `string | Record<ruleName, string> | undefined`（undefined 表示无错误）；默认简单场景返回 string，需要保留多条命名规则输出时返回 Record，以便 Devtools/Studio 可展示 ruleName。
- Q: `ListErrorNode`（数组节点 + `$list`）在 TypeScript 中如何避免强转、写出“真实代码感”的构造方式？ → A: 保持错误模型“数组节点 + `$list`”不变，但在 `@logix/form` 提供极薄的 helper：`Form.Error.list(items, { list?: FieldError })`（或等价 API）用于构造 `ListErrorNode`，quickstart/用户文档推荐使用它避免 `as any`。
- Q: `Form.Error.list(items, opts)` 的 opts 是否应该暴露 `$list`（带 `$`），还是用更友好的入参名？ → A: opts 使用更友好的入参名：`{ list?: FieldError }`（不暴露 `$`）；helper 内部负责写入 `$list`。错误树的事实源仍然是 `errors.items.$list`，不改变 IR。
- Q: 行级聚合错误（`$item`）是否也应提供对称的 helper，避免用户侧接触 `$`？ → A: 是。`@logix/form` SHOULD 提供对称 helper：`Form.Error.item(fields, { item?: FieldError })`，内部写入 `$item`；错误树事实源仍为 `errors.items[i].$item`，不改变 IR。
- Q: touched/dirty/focus/blur/unregister/滚动到首错/局部校验等“表单交互态”是否需要进入全双工可回放链路？ → A: 需要。交互态 SHOULD 存放在 Module state 的 `state.ui`（或等价命名）的专用子树中，由 `@logix/form` 维护其更新（通过 action/reducer/logic），并与 StateTrait 的校验触发（validate）形成稳定配合；React 层仅负责把 DOM 事件映射为“值变化/失焦/注销”等领域事件，不在组件本地维护第二套不可回放的交互态事实源。
- Q: `state.ui.touched/dirty` 的结构是走“同构值树/同构错误树/路径字典”哪一种？ → A: 采用与 FormView 值结构同构的布尔树：字段就是字段、数组就是数组（与 errors 的同构心智一致但不引入 `$list/$item`），便于按路径读写与 Devtools 可视化；实现层允许内部使用路径字典优化，但对外 SSoT 与 API 心智以同构树为准。

---

## User Scenarios & Testing *(mandatory)*

> 本特性站在「Trait 生态」视角，目标是固化一条可复用的链路：  
> **Trait（内核）→（可选）StateTrait（支点）→ Form（领域包）**，并让这条链路未来可以自然扩展到更多 `xxxTrait`。  
>
> 说明：  
> - `StateTrait` 是本 spec 选定的“第一个支点 Trait”（率先跑通数组/错误树/异步资源/事务可回放），但它不是强制中间层；某些领域也可以走 **Trait → Form** 的直接链路。  
> - Form 的目标不是“又一套表单运行时”，而是通过 `@logix/form` 提供自解释、可组合、可回放的 API 体系，并把可复用的“桥接玩法”下沉到 Trait 生命周期层（install/refs/validate/cleanup）。

### User Story 1 - Trait 作者沉淀可复用的桥接玩法（P1）

作为 Trait/Runtime 维护者（或领域能力作者），我希望：

- Trait 能提供一套标准化的“生命周期桥接”能力（如 `TraitLifecycle.install / Ref / validate / cleanup`），把上层领域事件接到 Module/Logic 上执行；
- 这套桥接能力不与 Form 绑定：Form 只是第一个领域包示范；未来的 `QueryTrait` / `PermissionTrait` / `WorkflowTrait` 也能复用同一套形状；
- Devtools 能以同一套心智观测：上层事件 → state.ui/state/errors 变更 → trait 规则执行（可回放、可追踪、可解释）。

**Why this priority**  
如果桥接模式不下沉并固化，上层领域包会各自发明 glue 逻辑，最终导致 API 不一致、心智不自洽，也无法作为未来 `xxxTrait` 的榜样。

**Independent Test**

- 用同一份“桥接生命周期”设计，分别支撑：
  - Form 的 blur/submit/validate/unregister；
  - 另一个假想领域（例如 Query 的 refresh / invalidate）；
- 让两位工程师只看文档就能写出它们的“安装点”（ModuleImpl.logics）与“调用点”（dispatch 领域 action）的代码草图。

**Acceptance Scenarios**

1. **Given** 一个新的领域 Trait（非 Form），**When** 它选择复用该桥接玩法，**Then** 它能在不发明第二套 Runtime 的情况下，把领域事件接入 Module/Logic，并保持可回放与可诊断。
2. **Given** Form 与另一个领域 Trait 同时存在，**When** 工程师阅读其安装/调用方式，**Then** 能在 10 分钟内理解它们共享的桥接结构（install/ref/validate/cleanup），而不需要重新学习一套概念。

---

### User Story 2 - Form 领域包提供自解释且自包含的 API（P1）

作为 `@logix/form` 的使用者（业务前端/框架侧），我希望：

- 我可以把“输入事件（change/blur/unregister/submit）”映射为少量领域 action，并通过 install 一次性接入（维护 `state.ui` + 触发 scoped validate + 写回 `state.errors`）；
- 我能用 `Form.Error.*` / `Form.Rule.*` 组合出清晰的错误树与规则库，而不需要在 UI 层手动 `setError/clearError`；
- Form API 的命名与结构足够自解释：读起来就知道在做什么，并且不要求先理解 Effect/Runtime 内核细节。

**Why this priority**  
最终用户是大量“没接触过 effect 的前端开发者”。Form API 需要在保持上限的同时，尽可能自解释与自包含，才能成为可推广的样板。

**Independent Test**

- 给出一个“复杂表单最小模块”的代码草图：包含 `state.ui`、`state.errors`、以及数组字段；
- 新工程师在 30 分钟内把 UI 事件映射为领域 action，并能跑通：
  - blur 显示错误；
  - submit 全量校验；
  - unregister 清理错误与 touched。

**Acceptance Scenarios**

1. **Given** 一个不熟悉 Effect 的前端工程师，**When** 他只看 quickstart 与 API 说明，**Then** 能完成 “安装 Form + 接入一个字段校验 + 渲染错误提示” 的闭环。
2. **Given** 一个包含数组字段的表单，**When** 工程师使用 `Form.Error.list/item` 构造错误与 `Form.Rule` 组织规则，**Then** 不需要写任何类型强转或 `$list/$item` 的底层细节。

---

### User Story 3 - 模块作者在复杂表单中声明数组级 Traits（P1）

作为 Logix 模块作者，我希望在包含数组字段（如订单行、动态联系人列表）的复杂表单中，能够像 RHF 一样自然地：

- 声明针对数组元素的计算字段（如每行小计）、联动逻辑（如勾选某行自动影响汇总），以及校验逻辑（行级错误）；
- 使用统一的「字段路径 / DSL」来表达这些 Trait，而不是为数组单独写一套 ad-hoc 逻辑；
- 同时保留良好的类型安全与可读性，至少不弱于我在 RHF 中使用 `Path<TFieldValues>` / `FieldArrayPath<T>` 的体验。

**Why this priority**  
数组 + 联动是 ToB 表单的高频难点场景，如果 StateTrait 在这里「短板明显于 RHF」，会直接影响 Logix 被前端团队采纳的可能性。因此需要优先在概念层和规范层把能力和边界定义清楚。

**Independent Test**  
仅实现本场景，就可以通过以下方式独立验证：

- 给出一个典型「订单 + 收货信息」表单的 StateSchema + TraitSpec 示例，包含：
  - 至少一个 FieldArray（如 `items`），包含多字段（name/quantity/price 等）；
  - 至少一个数组级计算 Trait（如总金额）；
  - 至少一个数组级联动 Trait（如选中行控制汇总）；
  - 至少一个行级错误 Trait（如某一行字段不合法）。
- 由两名不同背景的前端工程师（熟悉 RHF / 不熟悉 RHF 各一人）在不看实现代码的前提下，能根据文档推导出等价的 TraitSpec 写法，并确认其表达力足以覆盖 RHF 的 FieldArray 常见场景。

**Acceptance Scenarios**

1. **Given** 一个包含数组字段的复杂表单需求（如订单行 + 联系信息），**When** 模块作者根据本 spec 在 StateSchema + TraitSpec 中声明数组元素级的计算/校验/联动逻辑，**Then** 其表达能力至少能覆盖 RHF 文档中的典型 FieldArray 示例（增删行、行级校验、联动汇总），且不需要额外的 ad-hoc 状态。
2. **Given** 一份基于本 spec 编写的 TraitSpec，**When** 不同模块作者阅读该 TraitSpec 与配套文档，**Then** 可在 10 分钟内准确说出每个 Trait 针对的是哪个数组字段、哪个元素层级、与哪些字段存在依赖关系。

---

### User Story 4 - 表单开发者将数组错误与 UI 控件对齐（P1）

作为使用 Logix 的表单开发者（React / 其他 UI 框架），我希望：

- 能以清晰、稳定的结构读取表单状态中的错误信息（包括数组元素级错误），并一一映射到具体的输入控件；
- 不需要为 Logix 单独维护一套错误对象形状，而是将 Trait 定义的错误模型与 UI 库（如 RHF、内部 Form 组件）进行自然对接；
- 当数组增删/重排时，错误信息的归属行为是可预期的，有明确的规范说明。

**Why this priority**  
表单错误提示体验直接影响最终用户感知，且往往是业务表单开发中最痛的点之一。如果 Logix 的数组错误模型与常见表单库（尤其是 RHF）差异过大，接入成本会显著增加。

**Independent Test**

- 构造一个包含 FieldArray 的示例模块 + 表单 UI，只关注：
  - Trait 中的错误声明；
  - 状态中的错误结构；
  - UI 侧如何根据路径与错误结构渲染错误提示；
- 验证开发者可以在不阅读 Logix 内部实现的前提下，根据文档完成：
  - 行级错误的渲染；
  - 删除/添加行后的错误归属调整；
  - 提交失败时的「滚动到第一条错误」等交互。

**Acceptance Scenarios**

1. **Given** 一个由本 spec 定义错误模型的复杂表单模块，**When** 表单开发者参照文档接入 UI（例如使用内部 Form 组件或 RHF），**Then** 可以在 30 分钟内完成数组错误的渲染与联动，而无需额外引入 ad-hoc 错误状态。
2. **Given** 用户在含有 FieldArray 的表单上制造多种错误（缺行、行内字段错误、联动错误），**When** 触发一次统一的「提交」操作，**Then** 所有错误提示都能正确对应到具体控件，且数组增删/重排不会导致错误提示错位。

---

### User Story 5 - 架构师从 SSoT 理解 Trait 链路与边界（P2）

作为负责 Logix 平台规划的架构师/规范维护者，我希望：

- 在 docs/specs 中，有一份清晰的章节描述 “Trait →（可选）StateTrait → Form” 这条链路的角色与边界；
- 这份规范既能与 RHF 的字段路径/错误模型做对照，也能作为未来 `xxxTrait` 的模板（桥接玩法、错误/交互态事实源、可回放策略）；
- 当后续实现/演进 Trait 生命周期桥接、StateTrait 数组支持、Form 集成与 Devtools 视图时，都可以直接引用本 spec 作为唯一事实源，而不是每次重新解释。

**Why this priority**  
Trait 链路一旦落实现，会牵动 StateSchema、TraitSpec、Runtime/Devtools、表单库适配、未来其他领域 Trait 等多个层面。如果没有清晰的 SSoT，后续实现容易「各说各话」，导致难以维护。

**Independent Test**

- 抽象出至少 3 种数组使用模式（简单列表、嵌套数组、跨字段联动），在本 spec 中给出统一的概念抽象与术语；
- 由未参与本 spec 编写的工程师审阅文档后，为这 3 种模式各自设计一个 TraitSpec 草图，并指出实现/Devtools 的落点；
- 评审时确认这些草图没有违背 SSoT，对应关系清晰。

**Acceptance Scenarios**

1. **Given** 本 spec 与现有的 StateTrait SSoT 文档，**When** 新工程师在不看代码的情况下阅读这些文档，**Then** 能够区分：
   - 「Trait 生命周期桥接」与「领域包语法糖」的差别；
   - `StateTrait` 作为“支点 Trait”的角色，以及何时可以直接走 Trait→领域包；
   - 「Trait 表达能力 ≥ RHF」意味着什么（能力上限 vs 路径语法兼容）。
2. **Given** 一个新需求涉及「数组字段 + 校验 + 联动」，**When** 架构师根据本 spec 评估其是否属于当前阶段 scope，**Then** 可以在 10 分钟内判断该需求是：
   - 已被本 spec 覆盖；
   - 需要延伸 spec（如嵌套数组的更深层支持）；
   - 需要交给后续版本处理。

---

### Edge Cases

- 当数组为空时（例如 `items.length = 0`），数组级 Trait（汇总、错误）如何定义「0 行」的语义（如总金额=0、是否视为错误等）？
- 当数组中存在大量元素（例如 100+ 行）时：
  - Trait 对每一行进行计算/校验是否有「节流 / 采样」语义约束？
  - 增删/重排时 Trait 执行次数和事务边界如何控制？
- 对于嵌套数组（如 `sections[].items[]`），本 spec 明确将「两层嵌套」（外层 section 列表 + 内层 items 列表）纳入首版正式 scope：  
  - 需要在概念层定义「两层数组元素级 Trait」的行为语义，并确保 Trait DSL（StateTrait.list）/ 错误模型可以自然覆盖该结构；  
  - 要求 StateTrait.list 与 Devtools 至少能覆盖「外层 section + 内层 items」这类典型两层嵌套结构；更深层级（3 层及以上）可以在实现上支持，但视为高级用法，不作为本轮 Devtools 视图与文档的强制要求。

---

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001 · 数组字段路径模型**  
  规范 MUST 定义「数组字段 / FieldArray」在 State 模型中的路径语义，至少能够表达「数组元素级」的 Trait 作用范围（例如通过显式数组段或等价 DSL），并给出与 RHF 字段路径（如 `items.0.name` / `items[index].name`）的概念映射关系。

- **FR-002 · 数组元素级 Trait 能力**  
  StateTrait 模型 MUST 支持在数组元素层级挂载以下类别的 Trait：
  - 计算型（computed）：如每行小计、聚合 summary；
  - 联动型（link）：如列表字段驱动其他字段联动；
  - 校验型（validation）：如行级错误、整体列表错误。  
  这些能力的表达力在业务上 MUST 至少覆盖 RHF FieldArray 的典型用法（增删行、行级校验、联动汇总），允许通过更抽象的 DSL 或 Helper 实现，而不强制要求与 RHF 的字符串路径语法一一对应。
  - 默认行为上，新增数组元素时 Runtime 必须自动执行 item.computed（派生默认值/联动 meta）以确保状态正确；item.check 的执行时机则沿用整体校验策略（例如 onSubmit / 显式 validate 调用），不得在新增一行时强制立即触发全量校验，以避免“新增即报错”的体验与不必要的性能开销。

- **FR-003 · 错误模型与 UI 映射**  
  规范 MUST 定义一个面向数组字段的错误模型：
  - 能够表示行级错误、字段级错误以及整体列表错误；
  - Form 场景统一约定 `state.errors` 为错误树根节点，所有 `check` 的返回 patch 默认写入该同构 `errors` 子树；
  - 默认采用与值结构同构的错误树模型：例如 `errors.items[index].fieldName` 与 `state.items[index].fieldName` 一一对应，嵌套数组下错误树与嵌套值结构保持同构；  
  - 列表级约束（如「至少一行 / 最少 N 行」）默认通过 list.check 声明为业务规则，其错误落在列表级错误节点（例如 `errors.items.$list` 或等价结构），而不是在 StateSchema 中强制定义 minItems；  
  - 可在实现或适配层利用「以路径为 key 的错误字典」作为内部表示或桥接手段，但本 spec 的主 IR 与文档示例一律以同构树模型为准；  
  并通过示意/示例说明常见 mapping 场景（表单项下方错误、列表顶部错误、提交摘要错误等）。

- **FR-004 · 数组操作语义（增删 / 重排）**  
  规范 MUST 明确数组增删、重排时 Trait 与错误模型的语义，包括但不限于：
  - 行被删除后，该行相关 Trait / 错误的清理策略；
  - 行在中间插入/重排时，错误与派生语义默认随 index 重新计算，即将数组元素身份视为 `items[index]`（与 RHF 一致）；  
  - 在文档中给出「默认 index 身份」的 trade-off 说明，并推荐在需要稳定 identity 的场景下在业务层维护 `id` 字段（用于 UI key / 展示），但不将 `id` 納入本 spec 的核心 IR。  

- **FR-005 · Devtools / SSoT 可视化视图**  
  规范 MUST 要求 Devtools / runtime-logix 文档中，以清晰的方式呈现数组字段上的 Trait 结构与行为：
  - TraitGraph 能区分「列表字段节点」与其 Traits；
  - StateTransaction / Timeline 能在高层概览中反映「一次操作对哪些行产生了 Trait 更新」；  
  具体实现细节由后续 runtime spec 承载，本 spec 只负责约束需要呈现的概念和层级。

- **FR-006 · RHF 对齐边界定义（能力 ≥，路径不强制兼容）**  
  规范 MUST 明确「与 RHF 看齐 / 优于 RHF」的含义和边界，重点在于**表达能力与错误模型**至少不弱于 RHF，而不是在字符串路径层面 1:1 兼容：  
  - 必须在概念与 DSL 能力上覆盖 RHF FieldArray 的典型用法（如增删/插入、行级校验、跨字段联动），包括嵌套数组场景；  
  - 可以在字段路径语法与错误对象结构上与 RHF 存在差异（例如通过 kernel DSL（StateTrait.list）/ Helper 表达数组元素级行为，而不直接使用 `'items.0.name'` 这类路径作为规范的一部分）；  
  - 必须提供一份面向实际项目的「迁移指南」，说明如何将典型 RHF 表单（含 FieldArray）迁移到 StateTrait 模型（含 list/check），包括字段路径、错误结构、增删/重排语义的对照表；  
  - 若未来提供 RHF 适配层，可在适配层处理 path/错误结构的兼容转换，但本 spec 不将「字符串路径兼容 RHF」视为核心契约。

- **FR-007 · StateTrait.source 与 Resource/Query 复用约束（表单异步约束）**  
  规范 MUST 要求所有「字段/表单语义」层面的异步行为（例如根据供应商编码拉取供应商信息、根据远程配置约束下拉选项）统一通过 **Resource/Query + kernel source** 表达：  
  - 异步依赖只能以 `StateTrait.source`（或 list.item/list.source 的等价 kernel 形式）声明「哪个字段依赖哪个逻辑资源、key 如何从 state/row/rows 推导」；  
  - 资源结果如何影响表单视图（值/错误/meta/options）必须通过 `computed/check` 派生完成，保持单向数据流与事务可回放；  
  - Trait 侧 **不得直接返回或嵌入任意 Effect/IO**。所有真实 IO 必须收敛在统一的 Resource 事实源（`ResourceSpec.load: Effect`）中，由 Runtime/Middleware 触发与接管；  
  - 资源本身的定义（包括访问方式、错误模型等）必须在 Resource 事实源中集中管理并以 Layer 注入 Runtime，而不是在表单 Trait 层定义「影子资源」。

- **FR-008 · Resource 组织与作用域的最佳实践指引**  
  规范 MUST 对「资源如何在项目中组织与注入」给出清晰的最佳实践约束，并要求在用户文档中以专门章节形式呈现，包括但不限于：  
  - 推荐按照领域（如供应商、合同、结算）集中定义 Resource，而不是按页面/模块零散分布；  
  - 推荐在应用级或特性级 Layer 中组合 ResourceLayer，并在 Runtime.make 的 layer 中统一注入；允许在 ModuleImpl.imports 中挂载局部 ResourceLayer，但必须避免在同一 Runtime 作用域内用不同实现重复注册同一 resourceId；  
  - 明确「同一 Runtime 作用域内 resourceId 不能冲突，跨 Runtime 作用域可以为同一 id 提供不同实现」的约束，并在文档中给出典型用法与误用示例（如多租户、分环境配置）。

- **FR-009 · Rules 语法糖与内置校验库（对标 RHF rules，基于 check）**  
  在 kernel 的 `check` 槽位之上，规范 SHOULD 提供一层面向日常开发的规则组合语法糖（Rules API），以便在不改变 IR 的前提下显著提升表单校验的表达力与复用性：  
  - Rules API 只保留一个规范入口：`Form.Rule.make<V>(config)`，根据使用位置自动推断为 Field / item / list / root 级校验，并编译为等价的 `check(input, ctx)` 函数；  
  - 内置规则能力 MUST 覆盖 RHF `rules` 的核心集合（`required`、`min`/`max`、`minLength`/`maxLength`、`pattern`、以及命名的多条自定义 validate 规则）；  
  - Rules 允许组合已有 RuleSet（compose / pipe / merge）以便在不同表单/模块间复用相同的校验与联动逻辑；  
  - Rules 输出始终是 IR 层统一的 `check` 函数（本质为写 errors 子树的 computed），StateTrait / Runtime / Devtools 只感知 `check`，不直接依赖具体 Rule 配置结构。

- **FR-010 · effect/Schema 集成与字段名映射（Form ↔ Domain 边界）**  
  为了在保证 Domain 层 SSOT 与后端接口一致的前提下，仍然让 FormView / 表单领域糖保持良好的表达力与命名自由度，本规范对 effect/Schema 集成提出如下要求：  
  - Form 层以 FormView 模型为主（字段名与结构面向 UI/交互友好，例如 `supplierCode`、`languages[].type`），Domain 层以 Domain 模型为主（字段名与结构对齐后端接口或领域模型，例如 `supplier_code`、`language_type_code`）；  
  - 两者之间推荐通过 `Schema.transform` 风格的双向转换 Schema（FormViewSchema ↔ DomainSchema）完成字段名与结构的映射：  
    - 提交前：先将 FormState 通过 transformer/Schema 解码为 DomainInput，再由 Resource/HTTP 客户端发往后端；  
    - 回填时：将后端返回的 DomainOutput 通过 transformer/Schema 编码为 FormViewState，避免在 Form 层散落手写字段名映射逻辑；  
  - 深度业务校验（跨字段、跨结构、跨版本的强约束）应优先由 Domain Schema 的 decode 流程承担，Form Rules 则侧重于输入体验与即时反馈；  
  - 当 Domain Schema decode 失败时，规范 MUST 提供“将 Schema 解码错误映射为 Form ErrorTree”的规则（可通过 helper/适配层实现），从而把提交期错误以与 Rules 一致的结构写回 `state.errors`（必要时允许落到 `errors.$form` 或 `errors.<fieldPath>`）；  
  - 规范 MAY 提供从 Schema 派生基础 Rules 的 helper（例如 `Form.Rule.fromSchema(schema, "amount")`），但不强制要求所有表单规则都回写到 Schema，中短期内允许存在纯 UI 级的 Rules；  
  - 无论是否使用 Schema，Form 层最终暴露给 StateTrait / Runtime 的仍然是统一的 `check` 函数与错误树结构（本质为写 errors 子树的 computed），Schema/transformer 只在 Form ↔ Domain 边界与深度校验路径出现。

- **FR-011 · 根级 check 槽位（跨字段 / 跨列表规则）**  
  为了承载跨字段、跨列表甚至跨 Section 的纯校验逻辑，本规范要求支持可选的「根级 check」：  
  - 根级 check 直接面对**整份 Module/State**，签名为 `(state: Readonly<S>, ctx: FormCtx<S>) => GlobalErrorTree<S>`，并以 `StateTrait.check` 的形式写入 `errors` 子树（具体 error path 由实现层约定，例如 `errors.$form`）；  
  - 根级 check 允许读取与校验蓝图中未显式声明的字段，返回的 GlobalErrorTree 也允许对任意 path 写入错误 patch（不仅限于 lists 子树），以满足真实 ToB 场景的跨域约束；  
  - 根级 check MUST 保持纯粹的「状态 → 错误树 patch」语义，不得在其中直接触发副作用或执行 IO；涉及异步校验与副作用的跨表单逻辑由 Logic/Flow + Resource 承担；  
  - Rules API SHOULD 支持在 root 位置直接使用 `Form.Rule.make(config)` 生成等价 check。

- **FR-012 · 校验规则的归属与组织（root vs local）**  
  为了降低心智负担并提升可维护性，规范 MUST 在用户文档中给出明确的组织建议，并在示例中贯彻：  
  - root check 与 local check（字段级 / item / list）**同时允许**，并且语义等价地回落到 kernel `check`；  
  - 默认 SHOULD 优先使用 local check：当错误主要归属到某个字段/某个列表（或某一行）时，把 check 挂在该域下；  
  - root check SHOULD 仅用于“跨域不变量”：需要同时对多个字段/多个列表写入错误，或更适合在一个地方集中表达的整表规则；  
  - 文档 MUST 提供同一类规则在两种位置的等价写法对照，并解释取舍（可读性/复用性/定位成本）。

- **FR-013 · 命名规则集合（check/computed 的 Record 形态）**  
  为了提升规则可读性、复用性与 Devtools 可还原性，kernel MUST 支持在 `check/computed` 上声明**命名规则集合**：  
  - `check` / `computed` 允许写成单函数或 `Record<ruleName, fn>` 两种形态；单函数是语法糖（内部等价为一个默认 ruleName）；  
  - 当使用 Record 形态时，Devtools / Studio MUST 能显示 ruleName，并在错误树 leaf 为 Record 时与 ruleName 对齐；  
  - 规则名称仅用于诊断、展示与组合，不改变运行时语义；底层仍回落为一组 kernel  Entry。

- **FR-014 · 命名规则的顺序与合并语义（确定性 deep‑merge）**  
  当 `check/computed` 使用 Record 形态声明多条命名规则时，kernel MUST 提供确定性的执行与合并语义：  
  - 执行顺序固定为 `ruleName` 字典序（与对象字面量书写顺序无关），保证全双工可重放与可对比；  
  - 每条规则返回的 patch 在同一事务内按顺序做 deep‑merge：  
    - 对 `check`：同一路径的 leaf 若来自多条规则，最终合并为 `Record<ruleName, message>`（同名覆盖）；  
    - 对 `computed`：同一路径 leaf 冲突时 last‑writer‑wins，并在 dev 环境产生结构化 warning 便于定位；  
  - 合并语义不得引入非确定性（如依赖运行时遍历顺序）；  
  - Devtools MUST 能还原每条命名规则的输出与最终合并结果（至少在 debug 视图中可追溯）。

- **FR-015 · Form 场景 source 的默认触发（onValueChange + debounce + 事件扩展）**  
  为了让“输入变化 → 资源约束变化”的表单链路足够甜且可演进，规范 MUST 满足：  
  - kernel `StateTrait.source` 默认保持“只显式 refresh”（避免资源风暴）；  
  - Form.traits（领域糖）中声明的 source 默认启用自动触发，默认 `triggers: ["onMount", "onValueChange"]`：  
    - `onMount` 用于“编辑/回填”场景：初始 state 已有有效 key 时，自动触发一次 refresh；  
    - `onValueChange` 用于“输入变化”场景：当 keySelector 推导得到的 key 发生变化时触发 refresh（实现层可做 key 去重）；  
  - `triggers: ["manual"]` 表示“仅显式 refresh”，并且 MUST 与其它 trigger 互斥（不得出现 `["manual", ...]`）；  
  - 可选配置 `debounceMs`：默认仅对 `onValueChange` 生效（onMount 不需要防抖）；  
  - keySelector 允许返回 undefined 表示“当前无有效 key / 禁用”：此时不得触发 IO，并将 snapshot 置为 `{ status: "idle" }`（该禁用语义是 kernel 的通用能力，不仅限于 Form.traits）；  
  - triggers 的命名以用户心智为主（`onValueChange`），不在对外文档中强调“key change”；  
  - 预留 `triggers: ["onBlur"]`（以及未来更多 UI 事件）的扩展位：本轮不强制实现自动 wiring，但用户文档必须给出在 @logix/react 中如何在 blur/submit 等事件上触发 refresh 的推荐模式（通过显式调用 refresh 或等价 helper）。

- **FR-016 · source 的写回形态（ResourceSnapshot）**  
  为了让表单链路在不引入额外 ad-hoc 状态的前提下具备 loading/error 心智，本规范要求：  
  - `source` 的目标字段写回值 MUST 是 `ResourceSnapshot`，而不是 raw data；  
  - `ResourceSnapshot` 至少包含 `status`（`idle/loading/success/error`）、`key`（与 ResourceSpec.keySchema 对齐）以及 `data/error`（按 status 分支可选）；  
  - `computed/check` 可基于 snapshot 派生 options、disabled、错误提示等 UI 友好字段；  
  - Devtools MUST 能将 source 的刷新过程体现在 Timeline（进入 loading、成功/失败落盘）与 StateTraitGraph（字段依赖）中。

- **FR-017 · source 的竞态处理（丢弃 stale 结果）**  
  为了避免表单输入高频变化时出现“旧 key 覆盖新 key”的错乱状态，本规范要求：  
  - 当某次 refresh 开始时，运行时 MUST 先用 `ResourceSpec.keySchema` 规范化 key，并计算稳定 `keyHash`；进入 `{ status: "loading", key }`（对外只要求保留 key，但所有比较必须基于 keyHash）；  
  - 当请求返回 success/error 时，在写回 snapshot 前必须重新计算当前 keySelector 的结果：  
    - 若当前 keyHash 与本次请求 keyHash 不相等，则视为 stale 结果，必须忽略（不得覆盖当前 snapshot）；  
    - 仅当 key 相等时才允许写回 `{ status: "success"/"error", key, data/error }`；  
  - Devtools SHOULD 能看见 stale 结果被丢弃的诊断信息（至少在 dev 环境下可观测）。

- **FR-018 · source 的并发策略（switch / exhaust，默认 switch）**  
  为了在“表单输入高频变化”与“资源请求成本/限流”之间提供可控取舍，本规范要求：  
  - 每个 `source` 规则 MAY 声明 `concurrency: "switch" | "exhaust"`，默认 MUST 为 `"switch"`；  
  - `switch` 语义：以“最新 key”为准；当同一 source 在前一次请求仍 in-flight 时触发了新的 refresh，运行时 SHOULD 尽量取消旧 in-flight（若底层不支持取消也不强求），但无论是否取消都 MUST 按 FR-017 丢弃 stale 结果，确保不会“旧 key 覆盖新 key”；  
  - `exhaust` 语义：同一 source 同时最多一个 in-flight；in-flight 期间的 refresh 触发 MUST 被抑制，但运行时 MUST 记录一次 trailing refresh（只保留最后一次），当前请求结束后自动补发一次“最新 key”的 refresh（同样必须按 FR-017 做 stale 丢弃）；  
  - Devtools SHOULD 能观测到被抑制/合并的 refresh（至少在 dev 环境显示计数或事件），保证全双工可回放与可解释。

- **FR-019 · ResourceRef（resource id 的领域常量 + 蓝图元信息，不影响语义）**  
  为了让 Module/Traits 在保持“只依赖 resourceId + key”边界清晰的同时，仍能具备更好的可读性、可诊断性与可生成性，本规范要求：  
  - `source.resource` 在 DSL/领域糖层 MAY 接受 `string | ResourceRef`，其中 `ResourceRef` 为纯数据对象：`{ id: string; meta?: ResourceMetaHint }`；  
  - build 阶段 MUST 归一化为 `resourceId: string`（取 `resource` 的 string 或 `.id`），并且 Program/Plan/EffectOp 中只存 string resourceId，确保运行时事实源稳定；  
  - `ResourceRef.meta` 仅用于 Devtools/文档/代码生成，且 MUST 为白名单字段集合（`label/description/tags/owner/docUrl`）；不得改变运行时执行语义（不得承载 cache/retry/concurrency 等语义字段）；  
  - Devtools/诊断展示资源信息时，`ResourceRef.meta` 优先；缺失字段再 fallback 到 `ResourceSpec.meta` 的同名字段（例如 description）。该合并只用于展示，不得反向影响任何运行时语义；  
  - 当 `ResourceRef.meta` 与 `ResourceSpec.meta` 的同名展示字段（例如 description）同时存在且值不一致时，dev 环境 SHOULD 给出 warning（按 resourceId+字段去重），提示“展示元信息分叉”；展示仍遵循“ResourceRef 优先、缺失再 fallback”；  
  - `ResourceRef.meta.tags` 的语义为展示侧的“分类标签”，用于 Devtools 的过滤/分组/检索；tags 不影响执行语义。Devtools 在展示与索引时 SHOULD 对 tags 做去重与字典序排序，保证稳定可对比；  
  - 用户文档 SHOULD 给出推荐工程组织：Traits/Module 图纸层优先依赖 `resources/*.id.ts`（只导出 ResourceRef 常量），Runtime/实现层在 `resources/*.spec.ts` 中用 `Resource.make({ id: ResourceRef.id, ... })` 定义并通过 `Resource.layer([...])` 注入；以降低 bundle/循环依赖风险。  
    但该拆分不作为强制约束：允许在小项目或局部场景把 ResourceRef 与 ResourceSpec 放在同一个文件里。

- **FR-020 · Form UI 交互态的全双工落点（state.ui）**  
  为了让表单在真实业务中具备可回放、可调试、可生成的“全过程”，规范 MUST 支持把表单交互态纳入全双工链路：  
  - 表单交互态（touched/dirty/blur/focus/unregister/submitCount 等）SHOULD 存放在 Module state 的专用子树中（推荐 `state.ui`）；  
  - `@logix/form` MUST 提供把 UI 事件映射为领域事件并写入 `state.ui` 的标准方式（action/reducer/logic 皆可），而不是在 React 组件本地维护第二套不可回放的事实源；  
  - Devtools/TimeTravel MUST 能回放 `state.ui` 的演进（至少与 `state.errors` 同等可观测），以支持“滚动到首错”“复现输入轨迹”等调试能力。

- **FR-021 · TraitLifecycle：Trait 与上层领域的标准桥接 API（FieldRef + scoped validate + cleanup）**  
  为了让上层（`@logix/form` / `@logix/react` / 未来更多 `xxxTrait`）能以最小 glue 实现 RHF 级体验，Trait kernel MUST 提供可组合的桥接能力（本 spec 暂称 `TraitLifecycle`）：  
  - 必须存在一种可序列化的 FieldRef/FieldKey，能够唯一定位一个字段实例（至少包含 field path + listIndexPath/index 等数组定位信息），用于表达 blur/change/unregister/scroll-to-error 等目标；  
  - 必须支持对 `check` 的**局部**执行（scoped validate）：允许仅校验某个字段/某行/某个列表，或按策略触发（如 onSubmit 全量、onBlur 局部），而不是只能全量跑；  
  - 必须定义 unregister / 行删除 / 重排时的错误与资源清理语义：对应 scope 的 `errors` 子树必须被确定性清理；对应 source 需遵守 stale 丢弃/取消/回 idle 语义，避免“删行后请求回写到幽灵字段”。

### Kernel IR 核心原语（computed/source/link/check + node/list 组合子）

> 本小节只定义「IR 级别的唯一主线」，不锁死 TypeScript 具体 API 形态，方便 full‑duplex：  
> 从需求/spec 生成代码，以及从代码/Devtools 反向还原 spec 时，都以同一套 kernel 概念对齐。

**0. 运行时主线不变：只有三种运行时 kind（computed/source/link）**

本 spec 的“表单数组能力”仍然只有一条运行时主线：`computed / source / link`。  
其中：

- `computed`：纯派生（写入某个具体目标字段的值）；  
- `source`：声明资源依赖与 key 规则，真实 IO 在 ResourceSpec.load 中；  
- `link`：跨字段传播（把 from 字段的值写入某个目标字段）。  

`check` 是语义糖：本质是“写 `state.errors` 同构错误树”的 computed，不引入新的运行时 kind。

**1. StateTrait.node：统一 DSL 形状（纯编译期组合子）**

为了让「标量字段 / 数组字段 / 根级规则」共享同一套声明形状，本 spec 引入 `StateTrait.node(...)`：

- node 只是一种 DSL 组合子：用于把某个作用域上的 `computed/check/source/link` 以同一种结构组织起来；  
- build 阶段必须把 node 展开为等价的 kernel entries（computed/source/link，以及写 errors 的 check），Runtime/Devtools 只感知展开后的 kernel；
- node 中的 `computed` **不得返回任意 patch**：每条 computed 必须对应一个明确的目标字段，并产出该字段的值；每个目标字段下允许单函数或命名规则集合（Record 形态，便于 Devtools 展示与确定性合并）。

**2. 标量/对象字段：node 直接挂在字段路径上**

```text
StateTrait.from(StateSchema)({
  "profile.email": StateTrait.node({
    check: {
      required: (email) => (email ? undefined : "必填"),
      format:   (email) => (/^\S+@\S+$/.test(email) ? undefined : "邮箱格式不正确"),
    },
    // 可选：source/link/computed 同理
  }),
})
```

约定：

- 字段级 node 的 check 输出会被写入 `state.errors` 的同构叶子：这里是 `errors.profile.email`；无错误返回 `undefined`；  
- 命名规则集合（Record 形态）仍然按 `ruleName` 字典序做确定性合并（见 FR-014）。

**3. 数组字段：StateTrait.list + item/list 两个 scope**

对任意数组字段 `path = "items"`，通过 `StateTrait.list({ item, list })` 一等公民化数组语义：

```text
items: StateTrait.list({
  item: StateTrait.node({
    computed: { /* 行级派生：按字段产值 */ },
    check:    { /* 行内/行级校验：写 errors.items[i].x / errors.items[i].$item */ },
    source:   { /* 行级资源依赖：写回 ResourceSnapshot */ },
    link:     { /* 行内联动 */ },
  }),

  list: StateTrait.node({
    check: { /* 跨行/列表级校验：写 errors.items.$list 或写多行错误 */ },
    // computed/source/link 允许但应谨慎：多数“列表级 meta”建议写在独立的 meta 字段上（非 list 内 patch）
  }),
})
```

语义：

- `item`：面对单个数组元素（行/子字段域）；ctx 至少包含 `state / path / index`（实现层可额外提供 items/prev/next）；  
- `list`：面对整个列表（跨行/全局）；ctx 至少包含 `state / path`；  
- list/node 都是 DSL 组合子：build 阶段会把其内容展开为等价的 kernel entries（主要落在 `items[]` 与 `items[].field` 级路径上），不引入第二套 runtime。

**4. 根级规则：$root**

为了承载跨字段/跨列表的整表不变量，允许在 traits spec 中声明一个保留键 `$root`：

```text
$root: StateTrait.node({
  check: (state, ctx) => ({ $form: "..." }),
})
```

约定：

- `$root` 的 check 面向整份 state；错误写入 `errors.$form`（或更细的全局错误子树），仍然是纯“状态 → 错误树 patch”，不得触发 IO。

**5. 与全双工 / SDD 的关系**

- Spec 写作层：只需要声明「字段/列表/root 的 node 里有哪些 computed/check/source/link」，不关心具体语言实现；  
- 代码生成层：可以机械地将 node/list 结构映射为 `StateTrait.node` / `StateTrait.list({ item, list })`（或可选的 Form.traits 领域糖）调用，保持 IR 等价；  
- Devtools 层：按「字段/列表 → node → computed/check/source/link」展开 TraitGraph，使人类与 LLM 都能从运行时状态反向还原 spec 中的意图。

### Key Entities *(include if feature involves data)*

- **数组字段（Array Field / FieldArray）**  
  - 表示 State 中的数组类型字段，如订单行列表、教育经历列表；
  - 需要在 SSoT 中明确其路径模型（到数组本身、数组元素、元素内子字段）。

- **数组元素 Trait（Array Element Trait）**  
  - 作用于某个数组元素及其子字段的 Trait 抽象；
  - 可用于描述 per-item 的计算、联动与校验行为；
  - 与当前 StateTrait 的 computed/source/link 语义保持兼容。

- **错误模型（Error Model for Arrays）**  
  - 描述数组字段及其元素的错误结构；
  - 需支持行级错误、字段级错误和整体列表错误；
  - 与 UI 组件的错误展示结构（如 RHF 中的 `errors.items[3].name`）存在明确映射关系。

- **字段定位（FieldRef / ListRef）**  
  - 用于唯一定位一个“字段实例”（而不仅是字段路径字符串），是 `@logix/form` / `@logix/react` 与 Runtime/StateTrait 的桥接货币；
  - 必须可序列化、可比较：至少包含字段 path，以及数组场景下的 `listIndexPath + index` 等定位信息；
  - 用于表达 blur/change/unregister、滚动到首错、以及 scoped validate 的 target。

- **校验请求（ValidateRequest）**  
  - 表示一次“局部/全量校验触发”的输入（mode + target）；
  - 支撑 RHF 级体验：submit 全量、blur 局部、valueChange 局部复校验；
  - 执行范围必须由 Graph/Plan 推导（只运行可能影响 target 的 check），避免全量校验的性能陷阱。

- **表单交互态（Form UI State / `state.ui`）**  
  - 表示 touched/dirty/submitCount 等交互态，属于全双工可回放链路；
  - 推荐以与 FormView 值结构同构的布尔树表达（字段=字段、数组=数组），不引入 `$list/$item`；
  - 由 `@logix/form` 维护写入，Devtools/TimeTravel 可回放，用于驱动“何时展示错误/何时触发校验”的策略。

---

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001 · 覆盖典型 RHF 场景**  
  给出至少 3 个来自 RHF 文档或内部实践的典型 FieldArray 场景（如「动态教育经历列表」「订单行 + 折扣」「多级嵌套地址表单」），经小组评审确认，本 spec 中定义的 StateTrait 数组模型在概念上可以一一覆盖这些场景，无需引入额外的 ad-hoc 状态。评审结果需记录在 spec 旁的 notes 中。

- **SC-002 · 文档可理解性**  
  对 3 名未参与本 spec 编写的前端/架构工程师进行阅读测试：  
  - 要求他们在 30 分钟内阅读本 spec 和相关 SSoT 章节；  
  - 然后独立画出「某个复杂表单的 StateSchema + TraitSpec 草图」；  
  - 若至少 2 人的草图与预期模型高度一致（只存在细节差异），则视为通过。

- **SC-003 · 迁移指导有效性**  
  选取一个现有 RHF 表单（含 FieldArray）作为样本，用本 spec 提供的模型和指南重写一版「Logix + StateTrait」设计文档：  
  - 由原项目维护者评估：是否能在 1 个工作日内根据该文档完成 PoC 实现；  
  - 若评估结果为「可以」，且在 PoC 中未出现本 spec 未覆盖的核心概念，则视为满足。

- **SC-004 · 设计一致性约束**  
  在本 spec 落地后 1 个月内，审查新增/修改的与表单数组相关的设计/实现：  
  - 不再出现新的、与本 spec 相冲突的数组路径 / 错误模型设计；  
  - 所有新引入的数组 Trait 场景要么明确引用本 spec 概念，要么在本 spec notes 中登记「计划中的偏离/扩展」。  
  如检查结果中出现未对齐的实现，需回到本 spec 做增补或更正。
</file>

</files>
