# Feature Specification: 实现 `@logix/data` 字段能力核心包（已废弃 / 仅供参考）

> ⚠️ **状态说明（2025-12-10 更新）**  
> 本规范对应早期方案，目标是实现独立的 `@logix/data` 包作为字段能力宿主。  
> 随着 `specs/001-module-traits-runtime` 的引入，字段能力与 State Graph 的主线已经统一收敛到 `@logix/core` 内部的 StateTrait 内核，本规范不再作为当前事实源，仅保留为历史 PoC 与 IR 参考。  
> 如需了解最新设计，请优先参考：`specs/001-module-traits-runtime/spec.md` 与 `docs/specs/runtime-logix/core/02-module-and-logic-api.md` 中关于 StateTrait 的描述。

**Feature Branch**: `[001-implement-logix-data]`  
**Created**: 2025-12-09  
**Status**: Archived (superseded by 001-module-traits-runtime)  
**Input**: User description: "我想实现 @logix/data 这个包，请你检索当前项目下的相关文档"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 统一字段能力定义（Computed / Source / Link） (Priority: P1)

作为 Logix 场景包维护者（例如表单、列表、AI 场景包的负责人），我希望有一个统一的 `@logix/data` 包来承载字段能力（Computed / Source / Link），这样在不同业务场景中可以用同一套方式声明「字段如何被计算、从哪来、跟谁联动」，而不用在每个包里重复造轮子。

**Why this priority**:  
没有统一的数据/字段能力层，表单、查询、AI 等场景会各自实现一套“计算字段、远程数据、字段联动”的机制，导致心智负担大、工具难以复用，也难以在平台侧画出一致的 State Graph。先把字段能力统一起来，是后续 DevTools 和平台出码的前置条件。

**Independent Test**:  
在一个示例模块中，仅引入 `@logix/data` 提供的能力（不依赖其他新特性），就能完成：  
- 声明至少一个计算字段（Computed）；  
- 声明至少一个远程数据字段（Source）；  
- 声明至少一个跨模块联动字段（Link）；  
并通过集成测试验证这些字段在典型操作下行为稳定。

**Acceptance Scenarios**:

1. **Given** 一个模块的状态模型中包含 A、B 两个基础字段和一个 C 计算字段，**When** 用户只修改 A 或 B 的值，**Then** C 会根据最新的 A、B 自动更新，无需在业务逻辑中手动赋值。  
2. **Given** 一个字段被声明为远程数据 Source，**When** 触发加载且上游服务返回成功或失败，**Then** 该字段的值及其状态（如“加载中 / 成功 / 失败”）均可被上层场景包一致地感知和展示。  
3. **Given** 一个字段被声明为 Link，指向另一个模块中的某个字段，**When** 源字段发生变化，**Then** 被 Link 的字段在当前模块中也会更新，且不会出现“部分刷新/状态不一致”的情况。

---

### User Story 2 - 模块作者可以声明式配置字段能力 (Priority: P2)

作为使用 Logix 的业务模块作者，我希望在定义模块状态模型时，就能够以声明式方式为字段配置「原始字段 / 计算字段 / 远程数据 / 联动字段」等能力（包括嵌套对象和列表项上的字段），而不需要在散落的逻辑代码中手工维护依赖关系和更新顺序。

**Why this priority**:  
字段能力如果只能在逻辑代码里“手写”，会让模块难以阅读和演进，也难以在平台侧做可视化与对比。让字段能力直接出现在状态模型中，可以让业务开发者更快理解和修改，也为后续平台出码提供结构化输入。

**Independent Test**:  
在一个演示模块中，只通过配置状态模型和 `@logix/data` 的声明式能力（不修改已有逻辑流程）就实现字段间的依赖关系；对于包含动态列表的模块，测试通过检查新增、删除、更新列表项时，相关计算字段、远程字段与联动字段能否按配置正确响应来验证。

**Acceptance Scenarios**:

1. **Given** 模块作者在状态模型中为某字段标记为 Computed 并声明其依赖字段集合，**When** 运行时加载该模块，**Then** 字段间的依赖关系会自动生效，无需额外编码即可按预期计算。  
2. **Given** 模块作者在状态模型中为某字段标记为 Source 并配置数据来源和触发条件，**When** 运行时按照触发条件发起加载，**Then** 该字段的值和元信息会自动更新并暴露给上层逻辑使用。  
3. **Given** 模块作者在状态模型中为某字段标记为 Link 并指定目标模块及字段，**When** 目标模块状态发生变化，**Then** Link 字段会在不修改现有业务逻辑代码的前提下更新到最新值。

---

### User Story 3 - 平台与工具可以构建统一的 State Graph 视图 (Priority: P3)

作为平台与 DevTools 的维护者，我希望 `@logix/data` 能为每个字段提供统一的能力元信息（例如字段类型、是否为 Computed / Source / Link、依赖关系等），这样可以在工具中生成可视化的 State Graph，用于调试、对比以及后续的自动出码。

**Why this priority**:  
没有统一的字段能力元信息，平台和工具很难准确展示模块的状态结构与依赖关系，也无法对规则进行静态分析或生成代码。把这些信息集中在 `@logix/data` 层，有利于形成“Schema → State Graph → 代码”的清晰链路。

**Independent Test**:  
在一个示例模块中，只要使用 `@logix/data` 提供的能力定义字段，就可以通过工具或检查函数获得完整且一致的 State Graph 数据结构，并用它生成可视化视图或报告。

**Acceptance Scenarios**:

1. **Given** 一个模块使用 `@logix/data` 定义了包含 Raw / Computed / Source / Link 的多种字段，**When** 工具读取模块的字段能力元信息，**Then** 可以生成一个包含所有字段节点及依赖边的 State Graph 结构。  
2. **Given** 两个版本的同一模块分别使用 `@logix/data` 定义字段，**When** 工具对两版 State Graph 做对比，**Then** 可以准确指出哪些字段新增/删除、哪些依赖关系发生变化，为代码评审和回归提供依据。

---

### Edge Cases

- 当多个 Computed 字段形成依赖环（A 依赖 B，B 又依赖 A）时，应如何检测并报错，以避免进入无限循环或不稳定状态。  
- 当一个 Source 字段的上游数据长期不可用（例如连续失败或超时）时，字段的当前值、错误信息和降级策略应怎样表现，避免让业务模块陷入“半加载”状态。  
- 当 Link 链接跨模块过深或链路中某个模块未正确初始化时，如何保证当前模块的字段仍有可预测的行为（例如使用最近一次有效值或约定的默认值）。  
- 当基础字段高频更新（例如输入框实时输入）时，如何保证 Computed / Link 字段的更新对最终用户呈现为“稳定且无明显卡顿”的体验，而不是产生闪烁或状态撕裂。
 - 当动态列表发生频繁的增删改（例如简历教育经历列表或上传文件列表）时，如何保证列表项级的计算字段、远程数据字段和联动关系在索引变化或项被删除后仍然保持一致且不会泄漏旧状态。

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须支持在模块的状态模型中，为每个字段声明其能力类型（至少包括 Raw / Computed / Source / Link），并保证这些能力类型在不同场景包中含义一致。  
- **FR-002**: 对于声明为 Computed 的字段，系统必须能够基于配置的依赖字段集合自动计算其值，在任一依赖字段变化时触发重新计算，且计算过程应保持确定性（同样输入得到同样输出）。  
- **FR-003**: 对于声明为 Source 的字段，系统必须支持从外部数据源获取值，并统一暴露“未加载 / 加载中 / 成功 / 失败”等状态，供上层逻辑和 UI 使用，避免各场景包自己定义不兼容的状态枚举。  
- **FR-004**: 对于声明为 Link 的字段，系统必须支持将当前模块字段与其他模块或 Store 中的字段建立单向或双向的数据联动关系，并保证在源字段更新后，所有已声明的 Link 字段在合理时间内（同一次用户交互周期内）完成同步。  
- **FR-005**: 系统必须为每个字段生成可查询的能力元信息（包括能力类型、依赖字段、关联模块等），以便平台和工具可以构建统一的 State Graph 视图，并在代码评审或排错时使用。  
- **FR-006**: `@logix/data` 必须可以被多个上层场景包（如表单、查询、路由、AI 等）复用，而不直接依赖具体的界面技术或交互框架，确保同一字段能力定义可以在不同前端或运行环境中工作。  
- **FR-007**: 系统必须支持在现有模块中按需渐进式引入字段能力：未使用 `@logix/data` 的模块继续按原有方式工作，使用该包的模块可以只为部分字段配置能力，而不强制一次性迁移全部状态模型。  
- **FR-008**: 当字段能力配置存在明显错误（例如依赖字段不存在、出现依赖环、同一字段被声明为不兼容的能力类型）时，系统必须在加载或开发阶段给出清晰的错误提示，帮助模块作者尽早发现问题。
 - **FR-009**: 系统必须支持在嵌套对象和列表结构中应用字段能力：列表项内的字段可以像顶层字段一样被声明为 Computed / Source / Link，并且在 State Graph 中以正确的层级和依赖关系呈现，便于分析和调试复杂动态列表场景。  
 - **FR-010**: 对于声明为 Source 的字段，系统必须允许在元信息中区分不同类型的外部资源来源（例如查询类、长连接类、存储类或智能服务类），并能为这些字段记录与其他模块状态的关联关系，以便统一建模和可视化不同来源的数据字段。

### Key Entities *(include if feature involves data)*

- **字段（Field）**：模块状态模型中的一个属性，拥有名称、当前值和可选的能力元信息。字段可以是基础类型（如字符串、数字、布尔值）或结构化对象。  
- **字段能力（Field Capability）**：描述字段在数据层的角色及行为的抽象，例如 Raw（普通字段）、Computed（由其他字段计算而来）、Source（来自外部数据源）、Link（与其他模块字段联动）。能力包含能力类型、依赖字段集合、关联模块信息以及可选的错误/状态元信息。  
- **状态图 / State Graph**：由字段节点和依赖关系边组成的有向图，表示模块中各字段（包括嵌套对象和列表项）之间的计算、来源和联动关系，是平台和工具进行可视化、分析与出码的基础数据结构。  
- **场景包（Scenario Package）**：在特定业务场景下复用字段能力的上层包（如表单、查询、AI 等），它们通过读取 `@logix/data` 提供的字段能力信息，在各自的领域内呈现或扩展这些行为。

## Assumptions

- `@logix/data` 只负责字段值与字段能力的声明和元信息管理，不直接承载“只做副作用、不更新 State”的响应式行为；纯副作用型响应由 Logic 层的通用 Helper 承担。  
- 动态列表的增删改和复杂交互逻辑可以由上层 Helper 或场景包封装，但这些 Helper 应基于 `@logix/data` 提供的字段能力与 State Graph 信息来工作，而不是绕过这一层直接操作内部状态。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 在至少一个表单场景和一个列表/查询场景的试点中，所有被声明为 Computed / Source / Link 的字段，在功能测试中均能按照字段能力定义自动更新或加载，测试用例通过率达到 100%。  
- **SC-002**: 在针对开发者的可用性测试中，至少 80% 的模块作者在阅读说明文档后，可以在 15 分钟内完成一个包含 Computed 和 Source 字段的简单模块建模，而无需额外培训。  
- **SC-003**: 在集成 `@logix/data` 后，对比同一业务模块的“改造前后”，为字段间依赖关系编写的自定义胶水逻辑数量减少至少 30%，代码评审中关于“字段依赖不清晰”的问题数明显减少。  
- **SC-004**: 使用 `@logix/data` 的模块在 DevTools 或分析工具中生成的 State Graph 视图，与规范文档中描述的字段结构和依赖关系相比，字段和依赖的匹配率达到 100%，便于排错和回归验证。
