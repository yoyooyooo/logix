# Feature Specification: EffectOp 边界收口（移除局部加固入口）

**Feature Branch**: `[001-effectop-unify-boundaries]`  
**Created**: 2025-12-12  
**Status**: Draft  
**Input**: User description: "那这块我们创建个新 spec 去好好收个尾巴，顺带可以检查下之前 001 是否还有遗漏"

## Clarifications

### Session 2025-12-12

- Q: 边界操作覆盖范围是什么？ → A: 覆盖所有当前已存在的边界类型（包含内部类边界与调试类边界），一律进入同一条中间件管线
- Q: 全局策略 vs 局部策略的优先级是什么？ → A: 全局守卫不可被局部关闭；局部只允许追加信息或收紧约束；局部可关闭“纯观测类”能力
- Q: 中间件“拒绝执行”的可见结果是什么？ → A: 返回“显式拒绝失败”（可区分于成功），且不产生任何业务副作用
- Q: 多步边界操作是否需要关联键（链路 id）？ → A: 必须提供一个关联键（操作链路 id），用于把同一链路下的多次操作关联起来

## User Scenarios & Testing _(mandatory)_

<!--
  IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
  Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
  you should still have a viable MVP (Minimum Viable Product) that delivers value.

  Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
  Think of each story as a standalone slice of functionality that can be:
  - Developed independently
  - Tested independently
  - Deployed independently
  - Demonstrated to users independently
-->

### User Story 1 - 统一的运行时拦截与观测 (Priority: P1)

作为使用运行时框架的业务开发者/平台开发者，我希望所有“会执行的边界操作”都能被同一套中间件能力拦截与观测，从而避免遗漏关键守卫（例如鉴权/审计）并获得一致的调试与追踪体验。

**Why this priority**: 这是后续可靠性、合规与可观测能力的共同基础；如果边界未统一，任何策略都会出现“漏网之鱼”。

**Independent Test**: 在一个最小示例应用中，触发多类边界操作后，能够确认每次操作都被统一中间件看见，并且按配置执行守卫/观测逻辑。

**Acceptance Scenarios**:

1. **Given** 一个应用启用了至少一个全局中间件，**When** 触发任意一种边界操作，**Then** 中间件能够接收到这次操作的结构化上下文并影响其执行结果（允许/拒绝/仅观测）。
2. **Given** 应用未启用任何中间件，**When** 触发任意一种边界操作，**Then** 该操作仍可正常执行，且不会因为中间件体系缺失而改变对外可见行为。

---

### User Story 2 - 保持业务侧写法稳定 (Priority: P2)

作为业务开发者，我希望在完成“边界收口”后，日常的业务写法不需要大范围改动；只有当我需要声明局部策略（例如某条操作需要 loading/toast/鉴权）时，才需要做最小增量的标注。

**Why this priority**: 降低迁移成本，避免“为追求统一而破坏 DX”，同时为平台/出码器提供稳定的生成目标。

**Independent Test**: 选取一个现有示例/PoC，在不改动业务逻辑结构的情况下完成迁移，并能以局部标注启用/关闭特定策略。

**Acceptance Scenarios**:

1. **Given** 一个现有业务逻辑示例，**When** 升级到新体系后仅做必要的 API 形状调整，**Then** 其核心行为保持一致且无需引入额外样板代码。

---

### User Story 3 - 清理遗留与规格对齐 (Priority: P3)

作为维护者，我希望在实现收口后能够删除遗留的旧入口（“局部加固/包一层”的历史机制），并同时回查 `001-module-traits-runtime` 中已承诺但未落地/未收口的内容，形成明确结论（实现/删除/降级为草案）。

**Why this priority**: 避免长期双轨，减少概念漂移，让后续新增能力只需要接入一条总线。

**Independent Test**: 在仓库层面确认旧入口不再被引用，并能给出一份“001 遗漏项检查结果”的可追踪清单。

**Acceptance Scenarios**:

1. **Given** 仓库包含历史遗留入口，**When** 执行清理，**Then** 公共 API、示例与文档中不再出现遗留入口，且替代方案可用。
2. **Given** `001-module-traits-runtime` 的规格与现状可能不一致，**When** 完成本次收尾，**Then** 每一处不一致都有明确处置（实现/调整规格/标记为后续主题），并可被后续工作复用。

---

### Edge Cases

- 中间件拒绝执行某次边界操作时：调用方应得到“显式拒绝失败”（可区分于成功），且不产生任何业务副作用。
- 同一次用户交互触发的多步边界操作：必须能区分并通过关联键（操作链路 id）关联它们。
- 边界操作嵌套触发（在一次操作内部又触发另一类操作）：中间件观察到的上下文必须保持一致性且不会无限递归。
- 局部策略与全局策略冲突时：行为必须确定且可解释；全局守卫不得被局部关闭，局部仅可追加信息或收紧约束，且局部可关闭“纯观测类”能力。

## Requirements _(mandatory)_

### Functional Requirements

**Scope Note**: 本 spec 关注“边界收口 + 遗留清理 + 001 对齐”，不定义具体业务策略内容（例如鉴权规则本身），只要求“挂载点与上下文”完备可用。

- **FR-001**: 系统 MUST 将所有对外可触发的“边界操作执行”统一建模为同一种结构化操作事件，并在执行前进入同一条中间件管线。
- **FR-002**: 系统 MUST 支持在应用级配置中间件管线，并保证该配置对所有边界操作一致生效。
- **FR-003**: 系统 MUST 为每次边界操作提供足够的上下文信息，使中间件能够实现：观测（日志/追踪）、运行策略（重试/超时/并发策略）与守卫（允许/拒绝）。
- **FR-003a**: 系统 MUST 为每次边界操作提供一个关联键（操作链路 id），用于把同一链路下的多次边界操作关联起来。
- **FR-004**: 系统 MUST 支持对单次边界操作附加“局部策略标注”（例如标签/策略名/开关），以便中间件做差异化处理；未标注时必须有明确的默认行为。
- **FR-004a**: 系统 MUST 定义全局策略与局部策略的优先级：全局守卫不得被局部关闭；局部仅可追加信息或收紧约束；局部可关闭“纯观测类”能力。
- **FR-004b**: 系统 MUST 为“守卫拒绝执行”定义统一的可见结果：对调用方表现为“显式拒绝失败”（可区分于成功），且不产生任何业务副作用。
- **FR-005**: 系统 MUST 提供明确的迁移路径，使现有业务逻辑在不大改写的前提下迁移到统一管线，并且迁移后行为对业务使用者保持一致。
- **FR-006**: 系统 MUST 移除或禁用遗留的“局部加固入口”（历史上用于给单条逻辑包裹守卫/观测的机制），并确保没有公共文档/示例仍依赖遗留入口。
- **FR-007**: 系统 MUST 对 `001-module-traits-runtime` 中与本次收口相关的承诺进行一次一致性检查，并为每一处差异给出可追踪的处置结果（实现/调整规格/延期到后续主题）。

### Assumptions

- 本次收口的“边界操作类型”以当前已存在的全部类别为准（包含内部类边界与调试类边界），并一律进入同一条中间件管线。
- “局部策略标注”只描述意图（标签/策略名/开关），不携带具体规则逻辑本身。
- 若发现 `001-module-traits-runtime` 中存在与本 spec 冲突的表述，以“本次收口后的单一事实源”为准同步修订，避免双轨并存。

### Dependencies

- 需要同步更新相关规范与用户文档，使其仅描述统一管线后的能力与用法。
- 需要至少一个可运行的代表性示例用于验收端到端的“全局中间件 + 局部策略标注”。

### Key Entities _(include if feature involves data)_

- **边界操作（Operation）**: 一次可被中间件拦截/观测/守卫的执行单元；包含类别（例如交互、状态变更、生命周期、服务调用等）、名称、输入与上下文信息。
- **操作上下文（Operation Meta）**: 用于描述一次操作的结构化元信息（例如来源模块、关联链路、字段/资源标识、用户可见标签等），供中间件决策使用。
- **中间件（Middleware）**: 在操作执行前后运行的一段可组合逻辑，可做观测、运行策略或守卫；中间件不定义业务规则内容，只承载挂载点与组合语义。
- **局部策略标注（Local Policy Annotation）**: 针对单次操作声明的策略信息（例如标签/策略名/开关），用于覆盖或补充全局默认策略。

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: 所有当前已存在的边界操作类型（包含内部类边界与调试类边界）都可被同一条中间件管线观测到，且在最小示例中覆盖率达到 100%（每次操作均产生可识别的结构化上下文）。
- **SC-002**: 仓库中不再存在对遗留入口的引用（公共 API、示例与用户文档均为 0 处遗留引用）。
- **SC-003**: 至少 1 个代表性示例可仅通过“全局中间件 + 局部策略标注”实现差异化行为（例如对特定操作启用 loading/toast/守卫），且不需要引入第二套并行机制。
- **SC-004**: 针对 `001-module-traits-runtime` 的一致性检查产出一份清单，其中每条差异均有明确处置结论，且该清单可用于后续规划与验收。
