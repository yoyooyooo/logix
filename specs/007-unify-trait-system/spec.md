# Feature Specification: Trait 系统统一（Form 形状 × Kernel 性能 × 可回放）

**Feature Branch**: `007-unify-trait-system`  
**Created**: 2025-12-13  
**Status**: Draft  
**Input**: User description: "整合 004-trait-bridge-form 与 006-optimize-traits，并吸收 runtime/DX review 建议，消除冲突，生成统一的 007 spec。"

## Assumptions

- 本 spec 定义的是「对外行为与验收边界」，而不是某种具体实现方案；允许为了达标进行大规模重构，不要求向后兼容历史实现细节。
- 对外（API & 行为）必须保持 004 的核心心智：数组按 index 语义、错误树同构、交互态全双工；对内（Kernel & 调度）必须满足 006 的性能与一致性红线。
- Form 与 Query 是首批对照领域：007 必须能同时支撑“复杂表单联动/校验/数组”和“参数化查询的自动触发/竞态/缓存/失效”，以验证 Trait 系统的可推广性。
- Query 作为 Form 的对照组主要用于压力测试链路 API 设计：允许延迟其完整领域包落地，但必须先在 007 中锁定其语义约束、验收指标与回放/诊断口径。
- Query 的缓存与 in-flight 去重等工程复杂度允许委托给可替换的外部查询引擎；但对外语义（触发/并发/可回放/可解释）与可回放事实源必须仍由本系统保证。
- “Operation Window”定义为一次用户动作触发的状态变更窗口（一次领域事件/一次派发）。异步请求的开始与结束属于不同的 Operation Window。
- 典型目标场景是 ToB 复杂表单：多字段联动/校验/汇总 + 动态数组（含两层嵌套）+ 异步约束（弱网/竞态）。
- 默认“超预算”阈值为 200ms（允许配置）；默认诊断历史保留 60s（用于排查长尾抖动，允许配置）。

## Out of Scope

- 不引入新的运行时能力类别：Trait 仍以「派生 / 联动 / 异步资源状态 / 错误写回」为主，不把长耗时业务流程塞进 Trait。
- 不要求对外路径语法与任意第三方库 1:1 兼容；“对齐”只作为心智参照（例如 RHF），以表达能力与错误模型为准。
- 不把任何真实网络/外部副作用当作回放时的必选路径：回放优先保证可复现与不破坏外部系统。
- Query 的“完整领域包体验”可以晚于 Form/Kernel 达标；但不得以牺牲 007 的链路一致性、诊断口径或回放语义为代价。

## Dependencies

- 需要至少 1 个“真实复杂表单基准场景”和 1 个“可调合成压力基准场景”，用于验收与回归（含 10x 规模放大）。
- 需要至少 1 个“典型查询基准场景”（如搜索列表 + 筛选 + 分页），用于验证自动触发、竞态丢弃、缓存复用与失效刷新。
- 需要可观测信号（诊断摘要/事件日志）来验证：最小触发、0/1 次提交、循环/冲突诊断、以及回放一致性。

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 复杂表单在规模与联动下仍可用 (Priority: P1)

作为业务开发者，我希望在一个包含数组、联动、校验与异步约束的复杂表单中：

- 交互始终可用（持续输入不丢失、不需要等待数秒才能继续）；
- 只会更新“相关内容”（不相关的校验/汇总不会被无谓触发）；
- 错误展示与交互态（touched/dirty 等）可回放、可调试、可复现。

**Why this priority**: 这是系统进入真实业务的底线体验；如果高频输入与复杂联动不稳，上层 DX 再好也无法落地。

**Independent Test**: 使用基准复杂表单场景，执行一段固定输入脚本（含数组增删/插入/重排、字段联动与异步约束），可独立验证交互可用、错误归属正确、以及相关派生的响应指标。

**Acceptance Scenarios**:

1. **Given** 一个包含 100+ 字段与动态数组的表单，**When** 用户连续输入与修改（含快速输入/删除），**Then** 交互始终可用且相关派生与错误提示在可接受时间内稳定更新。
2. **Given** 一个数组字段在头部插入一行，**When** 插入发生，**Then** 系统对外仍以 index 语义定义结果（值/错误按新 index 对齐），同时不会触发与行内容无关的全量重算或明显卡顿。
3. **Given** 某个异步资源的 key 变为空（无效/禁用），**When** key 变为空，**Then** 在同一次可观察更新中资源状态会变为 idle 且清空 data/error，不出现“key 已空但 data 仍旧”的中间态。

---

### User Story 2 - 单次操作窗口内派生收敛且可解释 (Priority: P1)

作为运行时维护者，我希望每一次用户操作窗口内：

- 派生传播可收敛、确定性、可重复复现；
- 对外产生 0 或 1 次最终可观察状态提交（无变化则 0，有变化则 1）；
- 发生配置错误（冲突写回/循环）时硬失败并阻止提交；发生运行时错误/超预算时软降级并可解释。

**Why this priority**: 没有“收敛 + 0/1 次提交 + 可解释”，就无法在真实复杂联动中保证一致性与调试效率。

**Independent Test**: 在一个包含联动链与校验链的最小示例中，通过可观测信号验证：触发范围最小、提交次数为 0/1、冲突/循环被阻止且有明确诊断。

**Acceptance Scenarios**:

1. **Given** 一条联动链（例如 A 影响 B，B 影响 C），**When** 仅触发对 A 的局部校验/派生，**Then** 系统只执行依赖于 A 的最小闭包范围内的规则，并以 0/1 次提交对外呈现最终稳定结果。
2. **Given** 两条规则在同一操作窗口内试图写回同一目标字段，**When** 冲突发生，**Then** 系统阻止本次产生新的可观察提交，并输出包含“冲突目标 + 涉及规则集合”的诊断信息。
3. **Given** 存在循环依赖或振荡派生，**When** 触发该链路，**Then** 系统不会无限更新或卡死，会阻止本次产生新的可观察提交，并在可接受时间内给出可理解的诊断信息与建议动作。

---

### User Story 3 - 回放可复现 + Schema 错误归属可控 (Priority: P2)

作为开发者，我希望：

- 发生线上/弱网问题时，可以基于事件日志回放交互序列并复现当时的资源状态变化（而不是重新发起真实请求）；
- 当数据结构变形很复杂、无法自动把解码错误归属到 UI 字段时，我可以显式声明错误应落到哪些字段，从而保证错误提示可控、可解释。

**Why this priority**: 复杂系统的调试成本来自“不可复现”和“错误归属不清”；这两点必须被工程化消除。

**Independent Test**: 在一个包含慢加载与解码失败的样例中，录制一次交互并回放，验证资源状态变化与错误归属与录制一致，且回放不会触发真实网络请求。

**Acceptance Scenarios**:

1. **Given** 一段包含慢加载与失败/成功结果的交互录制，**When** 启用回放模式重放该序列，**Then** 资源状态（idle/loading/success/error）与其 payload 的变化顺序可复现，且不会触发真实网络或外部副作用。
2. **Given** 一个复杂结构变形导致解码失败的错误，**When** 开发者提供 errorMap 将该错误映射到一组字段路径，**Then** 错误会被确定性地归属到这些字段（或列表/根级错误节点），并能被回放复现。

---

### User Story 4 - 查询场景的自动触发与缓存复用 (Priority: P2)

作为业务开发者，我希望在“参数 → 异步数据”的查询场景里：

- 参数变化可以自动触发加载，并正确处理竞态（只认最新）；
- 同一查询在同一作用域内可以复用（避免重复请求与重复 loading 抖动）；
- 我可以显式触发刷新/失效，并在 Devtools 上看懂“为什么触发/为什么复用/为什么丢弃”。

**Why this priority**: Query 是与 Form 平行的第二个对照领域；它能暴露表单语境外的缓存、竞态与触发语义问题，逼迫 Trait 系统在更广谱的真实场景中自洽。

**Independent Test**: 在基准查询场景中对参数进行快速连续变更，并重复触发相同参数的查询；可独立验证竞态丢弃为 0、复用生效、以及失效刷新可回放。

**Acceptance Scenarios**:

1. **Given** 一个搜索列表查询，**When** 用户快速连续输入导致参数连续变化，**Then** 最终展示的数据必须对应最后一次参数；不会出现旧参数结果覆盖新参数的可观察错误。
2. **Given** 同一参数被重复触发，**When** 缓存可用且未显式失效，**Then** 系统应复用既有结果并避免不必要的重复 loading 抖动，同时给出可解释的诊断摘要。
3. **Given** 开发者发起一次“按资源/按参数”的失效请求，**When** 失效发生，**Then** 下次触发会重新加载并写回新快照，且该行为可被录制与回放复现。

### Edge Cases

- 多层嵌套数组（至少两层）中，插入/删除/重排导致 index 变化时：错误与交互态如何保持同构且可解释？
- 局部校验请求的 target 在数组内：当插入/重排导致 index 漂移时，target 的“字段实例”如何被稳定定位，避免误校验/误清理？
- 异步资源在短时间内 key 高频变化：如何保证 stale 结果不会覆盖新 key 的状态，且不会产生可观察的撕裂中间态？
- 回放模式下时间尺度变化（现实网络变快/变慢）：如何保证回放以“录制事实”为准而不是“现实环境”为准？
- 查询场景中“自动触发 + 手动触发”共存时：如何避免语义歧义（例如 manual 必须独占），并让诊断能解释每次触发来源？
- 查询的失效请求（按资源/按参数/按标签）在回放模式下如何重赛，确保不会因为现实环境差异而改变结果？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须提供统一的 Trait 行为模型，支持“派生/联动/异步资源状态/错误写回”，并允许被上层领域能力（如表单）以标准化桥接方式接入（安装、字段引用、局部校验、清理），且该桥接方式不与某一领域强绑定。
- **FR-002**: 系统必须支持数组字段的声明与运行语义，并以 index 作为对外身份语义（与 RHF 心智对齐）；至少两层嵌套数组必须作为首版正式 scope 的一等公民场景。
- **FR-003**: 系统必须定义与值结构同构的错误树模型：字段级错误落在对应叶子；列表级错误落在列表节点的固定位置（例如 `$list` 或等价结构）；当某个校验 scope 被判定为“无错误”时，系统必须清理该 scope 对应的错误子树以避免残留；错误树必须可回放与可调试。
- **FR-004**: 系统必须支持局部校验（scoped validate）：对任意校验 target，执行范围必须等于依赖关系图中“依赖于该 target 的反向闭包范围”（最小必要集合），不得退化为全量校验。
- **FR-005**: 系统必须以显式依赖声明作为派生与校验传播依据；运行时不得依赖动态分支或隐式推导来改变依赖集合，保证可解释性与可复现。系统应在开发/调试模式提供 deps 一致性诊断与修正建议（例如提示“实际读取到的字段路径集合”与“声明 deps”的差异），并应提供生成或辅助填充 deps 的手段，以降低漏写导致的静默不更新风险。
- **FR-006**: 系统必须保证单次 Operation Window 内派生可收敛，并对外产生 0 或 1 次最终可观察提交：若最终对外可观察状态与操作前等价则 0 次，否则 1 次。
- **FR-007**: 系统必须避免“无意义写回”：当某条规则的派生结果与目标字段现值等价时，该规则必须被视为可跳过，且不得因此产生新的可观察提交。
- **FR-008**: 系统必须保证确定性：在相同初始状态与相同输入序列下，最终对外可观察状态结果一致，并且诊断摘要在同一诊断等级下可稳定对比。
- **FR-009**: 系统必须支持依赖链的正确传播顺序，使“上游变化 → 下游派生/校验”最终收敛到稳定状态；当出现循环依赖、不收敛或振荡时，系统不得无限更新，必须阻止本次产生新的可观察提交，并输出可理解诊断（至少包含涉及范围与规则集合）。
- **FR-010**: 系统必须检测并处理同一 Operation Window 内的冲突写回：当多条规则试图写回同一目标字段时视为配置错误，本次不得产生新的可观察提交，并输出包含冲突目标与涉及规则集合的诊断信息。
- **FR-011**: 系统必须提供可观测诊断信号，用于解释“为什么这次更新发生/为什么没发生”：至少能回答本次窗口触发了哪些规则、哪些规则被跳过（因为等价）、以及成本最高的前 3 条规则（可读标识 + 成本等级）；同时必须支持至少两档诊断等级，并说明每一档的信号范围与开销边界；诊断历史默认保留 60s（允许配置），用于排查长尾抖动。
- **FR-012**: 系统必须在不改变对外 index 语义的前提下，支持数组场景的性能稳定性：插入/删除/重排不应导致与行内容无关的规则节点被迫整体失效或重建。系统可以在内部维护稳定身份层以复用既有计算结果；并应预留可选的 identityHint/trackBy，以便在极端规模下进一步降低无谓重算；用于渲染层的稳定 key（如 FieldArray item 的 `id`）必须仅用于 UI key，不得写回业务 values。
- **FR-013**: 当异步资源的 key 变为空（无效/禁用）时，系统必须同步地将对应资源快照变更为 idle，并清空 data/error，保证订阅者不会观察到“key 已空但 data 仍旧”的中间态。
- **FR-014**: 系统必须定义异步资源快照的状态机与竞态规则：触发刷新时进入 loading；完成时进入 success/error；用于去重、竞态丢弃与缓存复用的“参数相等性”必须基于稳定的 key 规范化与其稳定标识（例如 hash），禁止用对象引用相等或不稳定的序列化作为相等性依据；若返回结果对应的 key 已过期则必须被丢弃（不得覆盖当前快照）；并必须支持至少两种并发策略：
  - 默认策略：以最新 key 为准。当同一资源在前一次刷新仍 in-flight 时发生新的触发，运行时可以尝试取消旧刷新，但正确性不得依赖取消；旧结果在写回前必须被 stale 门控丢弃，确保不会覆盖当前快照。
  - 备选策略：in-flight 期间抑制新的触发（同一资源同时最多一个 in-flight），但必须记录一次 trailing 刷新（只保留最后一次）；当前刷新结束后自动补一次“最新 key”的刷新，写回前同样必须 stale 门控。
- **FR-015**: 系统必须支持回放模式：回放时不得发起真实网络请求，而应以事件日志中记录的资源结果与其状态变化“重赛（re-emit）”；回放必须以录制事实为准，能复现资源状态变化顺序与关键 payload，并避免破坏外部系统。
- **FR-016**: 系统必须提供 Schema 解码错误的“归属逃生舱”：当结构变形复杂导致无法自动映射时，开发者必须能提供一个纯函数 errorMap，将错误映射到一个或多个字段路径（或列表/根级节点）；运行时必须按该映射写入错误树并保持可回放。系统应同时提供一套默认的 Path Mapping 能力，覆盖大多数常见的重命名与结构映射（含数组内路径对齐）场景，使“无需手写 errorMap 的自动归属”覆盖至少 80% 的常见用例；超出覆盖面时再回退到 errorMap。
- **FR-017**: 系统应提供“生成优先（codegen-first）”的降门槛路径：开发者可以从 Schema/蓝图输入生成可编辑的表单骨架与 Trait 声明模板，从而避免手工维护深层嵌套场景下的高门槛声明；生成结果必须与本 spec 的对外行为契约一致，并应优先生成可维护的 deps 声明（或等价的可追溯来源），以降低显式 deps 的手写负担。
- **FR-018**: 系统必须支持查询场景的触发语义：至少包含“初始触发（onMount）”“参数变化触发（onValueChange，可选防抖）”“仅手动触发（manual，且必须独占）”，并保证触发来源可被诊断与回放；当“自动触发被关闭”时，系统不得触发新的请求，且默认应保留最后一次可观察结果快照（除非 key 被显式清空并进入 idle 语义）。
- **FR-019**: 系统必须支持查询场景的缓存复用与 in-flight 去重：在同一作用域内，相同的“资源标识 + 参数相等性”应复用既有结果并避免重复 loading 抖动；该复用行为必须可解释（能说明复用/未复用原因）；缓存与去重允许委托给外部查询引擎，但对外语义与可回放事实源不得被外部引擎反向定义。
- **FR-020**: 系统必须支持查询场景的失效/刷新请求，并且该请求必须可组合：至少支持按资源失效、按参数失效、按标签/分组失效；失效行为必须以可回放事件的形式进入事件日志，回放时按录制事实重赛；若失效/刷新由外部查询引擎执行，本系统仍必须产出一致的可观测事件与结果快照写回。
- **FR-021**: 系统必须支持 Query 的 UI 全双工交互态：例如是否允许自动触发、最近一次触发来源、手动触发次数、以及参数草稿等；这些状态必须进入 `state.ui`（或等价专用子树）并可回放，UI 层不得维护第二套不可回放事实源。
- **FR-022**: 系统必须固化并文档化链路分层：Trait（内核）→（可选）StateTrait（支点）→ 领域包（Form/Query/…）→ UI 适配层。上层所有领域糖与 UI 事件桥接都必须可还原为内核语义，且不得引入第二套不可回放事实源（错误、交互态与资源快照必须走同一条全双工链路）。
- **FR-023**: 系统必须提供面向该链路的可视化与文档（Devtools/SSoT）：至少能展示规则集合与依赖关系、每次窗口的触发/跳过摘要、资源状态变化、错误树与交互态演进、以及冲突/循环/降级原因；并能基于回放日志重现同一套解释口径。
- **FR-024**: 系统必须明确“对齐主流表单心智（RHF≥）”的边界与迁移指南：至少提供数组路径/错误结构/数组操作/局部校验触发的对照说明，并能指导将一个真实样例迁移为等价的链路设计（不要求 1:1 的字符串路径兼容，但要求表达能力与错误模型不弱于对照）。
- **FR-025**: 系统必须提供可复用的校验规则组织方式：支持局部（字段/行/列表）与根级规则，并支持规则组合与命名；常见校验能力（必填、范围、长度、模式、多条自定义规则）必须可表达；所有校验规则必须是纯粹的“状态 → 错误树写回”，不得触发 IO 或副作用。
- **FR-026**: 系统必须支持“命名规则集合”的确定性合并语义：同一字段/列表的多条校验规则若同时产出错误，最终错误叶子必须能保留每条规则的命名与信息，且合并顺序可预测；对派生值（非错误树）而言，若多条规则试图写回同一目标字段，必须按配置错误处理（遵循 FR-010），不得默默 last-writer-wins。
- **FR-027**: 系统必须定义 Form 场景的资源触发语义：内核默认仅显式触发；领域包可提供默认自动触发（初始触发、参数/值变化触发，可选防抖），并允许 UI 事件扩展（如 blur/submit 触发）；若支持 manual 模式，则 manual 必须独占；当 key 变为空时必须遵循 FR-013 的同步 idle 清空语义；触发来源必须可诊断与可回放。
- **FR-028**: 系统必须定义资源与缓存的作用域约束：同一运行时作用域内，同一资源标识不得出现互相冲突的实现；跨运行时作用域允许同名资源标识并互不干扰。该约束必须在文档中明确，避免误用导致不可解释的回放/缓存行为。
- **FR-029**: 系统应支持仅用于可读性/诊断/生成的元信息（例如 label/description/tags/owner/docUrl）附着在规则/资源/领域声明上：元信息字段必须受白名单约束且不得改变执行语义；Devtools 与失效/分组能力可以使用它们做稳定展示与索引；当同一标识出现多个不同元信息时必须给出明确提示，并以确定性规则选取 canonical 元信息（例如按引用路径字典序最小 first-wins），不得做 deep-merge；展示与索引时 tags 必须去重并按字典序排序；展示优先使用声明侧元信息，缺失字段才允许 fallback 到运行时注册的同名展示字段。
- **FR-030**: 系统必须采用分级失败与降级策略并保证订阅一致性：配置错误（冲突写回/循环）必须硬失败并阻止本次产生新的可观察提交；运行时错误或成本超预算（默认阈值 200ms，允许配置）必须软降级（仍提交基础字段变更、派生字段冻结为上一次稳定结果），并以诊断信号标记影响范围；订阅者不得观察到“半成品状态”。
- **FR-031**: 系统必须提供可复现的基准与回归方式，至少包含：真实复杂表单基准、可调合成压力基准、以及典型查询基准；每个基准必须定义可重复的输入序列与验收指标，以便持续验证 SC-001~SC-014 并发现回归。
- **FR-032**: 系统必须固定内核运行时原语集合：派生（computed）、资源（source）、联动（link）三类；校验（check）是“写错误树”的派生语义糖，不得引入新的运行时能力类别；领域包不得发明第二套运行时类别来绕开 0/1 次提交、回放与诊断约束。
- **FR-033**: 系统必须提供“可选的 StateTrait 支点”来承载领域 DSL：至少支持字段 scope、数组 scope（item/list 两层）与根级 scope；该 DSL 必须可被展开为等价的内核原语集合，并保持可回放、可诊断与可生成。
- **FR-034**: 系统必须约束规则的写回目标以保持可解释与可冲突检测：派生/联动/资源写回必须对应明确的目标字段或明确的目标范围；跨多个字段写入错误仅允许通过根级规则表达，并必须保持纯函数语义（不得触发 IO）。
- **FR-035**: 系统必须定义结构变更时的确定性清理语义：字段 unregister、数组行删除与数组重排时，必须清理对应范围内的错误子树与交互态标记；若该范围内存在资源快照，必须按约定回收为 idle 或等价“未激活”状态，并确保任何 in-flight 结果不会再写回到已被清理/已变更归属的范围。
- **FR-036**: 系统必须提供可序列化、可比较的字段实例引用与校验请求协议，用于上层领域包与 UI 适配层桥接：字段实例引用至少能表达 field/list/item/root 四类 target，并能表达嵌套数组锚点（listIndexPath）与行 index；校验请求至少包含 mode（submit/blur/valueChange/manual）与 target（字段实例引用），并要求 UI 层只通过“领域事件/请求”触发校验与清理，而不是直接读写错误树。
- **FR-037**: 系统必须把 Form 的交互态纳入全双工事实源：touched/dirty 等必须落在专用 UI 子树中（如 `state.ui`），并建议以与 values 同构的布尔树表达（字段就是字段、数组就是数组），不得引入额外的 `$list/$item` 特殊节点；实现层允许内部做等价优化，但对外语义与回放必须以同构读写体验为准。
- **FR-038**: 系统必须明确并固化“外部查询引擎”的职责边界：外部引擎可负责缓存、in-flight 合并、可选取消/重试等请求层工程复杂度；本系统必须负责触发语义、并发语义、稳定 key 相等性、写回门控（stale 丢弃）、回放（重赛结果而非重发请求）与诊断解释。正确性不得依赖外部引擎的取消能力：即使无法取消，旧结果也必须在写回前被门控丢弃。外部引擎的引入不得破坏本系统的 0/1 次提交、可回放与可解释约束。

### Key Entities *(include if feature involves data)*

- **Trait Rule**: 一条派生/联动/校验/资源状态写回规则，包含目标与显式依赖集合。
- **Dependency Graph**: 由规则依赖关系构成的图，用于最小触发、传播顺序与反向闭包计算。
- **Reverse Closure (反向闭包)**: 对某个 target，所有“直接或间接依赖该 target”的节点集合，用于 scoped validate 的最小执行范围。
- **Operation Window**: 一次用户动作触发的收敛窗口，对外提交与诊断以此为单位。
- **Observable Commit**: 订阅者可观察到的一次最终状态更新；本 spec 约束单窗口 0/1 次。
- **Error Tree**: 与值结构同构的错误树，包含字段级/列表级/根级错误节点。
- **Field Reference**: 用于稳定定位一个“字段实例”的引用（尤其在数组插入/重排下），支撑局部校验与确定性清理。
- **Resource Snapshot**: 描述异步资源的当前状态（idle/loading/success/error）及其关键数据/错误，用于派生 UI 友好信息与回放。
- **Replay Log**: 用于回放的事件日志，至少记录资源状态变化事件与关键 payload，使回放可复现且不触发真实网络。
- **Error Map**: 由开发者提供的纯映射函数，将解码错误归属到字段路径集合，用于复杂结构变形场景。
- **Query Parameters**: 查询参数（筛选/分页/排序等），进入请求前需要被规范化并形成稳定相等性（用于复用与竞态门控）。
- **Invalidate Request**: 组合型失效/刷新请求（按资源/按参数/按标签），用于显式控制缓存失效与后续重新加载，并可被回放重赛。
- **External Query Engine**: 可替换的外部查询引擎（可选），用于承担缓存与请求合并等工程复杂度；其行为不得成为对外语义的事实源，必须被本系统以快照与可观测事件方式纳入回放与解释口径。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 在基准复杂表单场景中，单次 Operation Window 的对外可观察提交次数为 0 或 1（无变化为 0，有变化为 1）。
- **SC-002**: 在基准复杂表单场景中，连续输入 60 秒过程中交互始终可用，且丢字符率 = 0。
- **SC-003**: 在基准复杂表单场景中，95% 的输入驱动操作在 100ms 内完成“相关派生与错误提示更新到最终稳定结果”的可见反馈。
- **SC-004**: 在至少一个“只改动局部字段”的场景中，与该字段无依赖关系的规则触发次数 = 0（以诊断信号或等价可验证方式衡量）。
- **SC-005**: 在可调合成压力基准场景中，当规模提升 10 倍（规则规模与数据规模同时提升，使单次输入触发的依赖边数约 10 倍）时，局部字段输入的 95% 响应时间劣化不超过 2 倍。
- **SC-006**: 在构造的循环依赖/冲突写回场景中，系统不会无限更新或卡死，并阻止本次窗口产生新的可观察提交，同时在 1 秒内给出明确诊断（包含问题范围与涉及规则集合）。
- **SC-007**: 在一次录制与回放对比中，回放模式不触发真实网络请求，并可复现资源状态变化序列与关键 payload（成功/失败）的一致性。
- **SC-008**: 在一个复杂结构变形导致解码失败的样例中，提供 errorMap 后，错误可被稳定归属到指定字段路径集合，并可被回放复现。
- **SC-009**: 在基准查询场景中，对参数进行 10 次快速连续变更后，最终状态对应最后一次参数；旧参数结果覆盖新参数的次数 = 0（以可观测快照与诊断信号验证）。
- **SC-010**: 在基准查询场景中，重复触发相同参数 10 次（未显式失效），产生的“进入 loading 的次数”不超过 1 次，并可通过诊断信号解释复用原因与触发来源。
- **SC-011**: 给出至少 3 个“复杂表单数组”典型场景与至少 2 个“参数化查询”典型场景，经评审确认 007 的链路分层与需求定义能够一一覆盖这些场景且不需要引入第二套不可回放事实源。
- **SC-012**: 对 3 名未参与本 spec 编写的工程师进行阅读测试：在 30 分钟内阅读 007 后，至少 2 人能独立画出同一条链路的“分层职责草图 + 一个表单/一个查询的状态/规则草图”，且与预期模型高度一致（仅允许细节差异）。
- **SC-013**: 选取一个真实项目中的表单样例（含动态数组）与一个查询样例（搜索/筛选/分页），依据 007 提供的对齐/迁移说明重写一版链路设计文档；由原项目维护者评估：是否能在 1 个工作日内根据该文档完成 PoC 实现与基本调试（可回放/可解释）。
- **SC-014**: 在 007 落地后 1 个月内审查新增/修改的相关设计与实现：不再出现与 007 冲突的数组语义、错误模型、触发/回放/诊断口径；如出现偏离，必须回流更新 007 规范以恢复单一事实源。

## TODO

- 若 “生成优先（codegen-first）”的完整工程化落地（包含骨架生成、增量更新、与手写变更的合并策略）在单点成本上显著超过本轮全链路实现成本，则先以最小可用骨架生成满足 SC-002/SC-003 的开发闭环，其余工程化能力延后推进。  
