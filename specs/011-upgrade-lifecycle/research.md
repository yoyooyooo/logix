# Phase 0 Research: Lifecycle 全面升级

**Feature**: [spec.md](./spec.md)  
**Plan**: [plan.md](./plan.md)  
**Created**: 2025-12-16  

本文件用于在实现前固化关键决策与取舍，避免“语义先跑偏、实现后补文档”的事实源漂移。

## Decision 1: 生命周期为“声明式注册”，由 Runtime 统一调度执行

**Decision**: 生命周期 API 的核心语义从“调用点直接执行”调整为“注册任务”，执行由 Runtime 在确定阶段统一调度（初始化门禁、终止清理、平台信号处理与错误兜底）。

**Rationale**:

- 让生命周期语义与模块实例存在性/可用性绑定，支持“可等待获取”模式下的初始化门禁。
- 避免生命周期逻辑分散在 Logic 书写顺序/调用点中，减少 phase guard 的偶然性。
- 为可诊断性提供稳定锚点：每个生命周期阶段的开始/完成/失败都可被结构化事件覆盖。

**Alternatives considered**:

- 继续沿用“调用点直接执行”：实现成本低，但无法保证初始化门禁与可等待获取一致，且难以保证顺序与诊断一致性。
- 仅在 React 侧做 Suspense 门禁：会把语义锁死在某个平台适配层，违背“少用 hooks、模块内完成”的目标。

## Decision 2: 初始化分层——“必需初始化”与“启动任务”明确区分

**Decision**: 初始化阶段区分两类任务：

- **必需初始化**：决定实例可用性；必须串行执行并在失败时使初始化失败（对消费方可观测）。
- **启动任务**：不阻塞实例可用性；失败必须被上报，但默认不应影响实例可用性（策略可配置）。

**Rationale**:

- 满足“门禁一致性”与“非阻塞启动”的同时存在。
- 让模块作者能把“必须成功的前置条件”和“可延后/可重试的后台任务”分开表达，减少初始化噪音与 UI 抖动。

**Alternatives considered**:

- 仅提供一个 `onInit`：语义混杂，无法表达“可失败但不阻塞”的启动任务。
- 让作者用 `fork` 自己表达：可行但错误策略、诊断链路与任务分类会退化成约定而非契约。

## Decision 3: 模块拥有一个可关闭的内部 Scope，以支持“错误导致终止”

**Decision**: 每个模块实例在父 Scope 下 fork 一个内部可关闭子 Scope（“数据 Scope”）。生命周期任务与长期 Fiber 运行在该子 Scope 内；当发生“致命生命周期失败”（例如必需初始化失败、策略选择为 fatal 的后台失败）时，关闭子 Scope 触发销毁任务并进入终止态。

**Rationale**:

- 让“未处理错误 → onError/诊断 → 销毁 → 终止”成为可实现且可测试的闭环。
- 让模块实例的终止不依赖外部容器（例如缓存 GC），便于在非 React 环境也维持一致语义。

**Alternatives considered**:

- 仅记录错误不终止：容易掩盖运行时不一致，且与“错误将导致终止”的用户心智不一致。
- 直接关闭父 Scope：父 Scope 可能承载多个实例/资源，影响面过大。

## Decision 4: 稳定标识模型——去随机化，使用可复现序列

**Decision**: 移除运行时关键路径的随机/时间默认 id，改用可复现的稳定序列与可推导组合：

- `instanceId`：模块实例级稳定标识（同一进程内确定性递增或基于稳定 key 推导）。
- `txnSeq`：同一实例内事务递增序列（替代随机 txnId 作为主锚点，必要时可派生字符串形式）。
- `opSeq`：同一实例内操作递增序列（用于 effectop/调试链路的因果串联）。

**Rationale**:

- 满足宪章“稳定标识”硬约束，使诊断/回放在不同运行/不同环境中具备可对齐性。
- 让 Devtools/Sandbox 侧能用稳定锚点串起生命周期、事务、effectop 与 UI trace。

**Alternatives considered**:

- 继续使用随机/时间：实现简单但破坏可对齐性与可回放性，且违背宪章。
- 使用哈希：可行但需要稳定输入源；在缺少业务 key 时仍需 fallback，复杂度更高。

## Decision 5: 诊断事件必须 Slim 且可序列化，并有明确预算

**Decision**: 生命周期相关的默认诊断事件载荷只保留可序列化的最小证据：

- 错误原因以“可序列化摘要”表达（例如可读文本 + 结构化字段），避免直接塞入不可序列化对象图。
- 每个实例的生命周期事件数量与体积有明确上界预算（与成功指标一致）。

**Rationale**:

- 满足宪章“诊断默认近零成本”与“ring buffer 可裁剪”的约束。
- 为未来 Sandbox/Alignment Lab 的跨线程/跨进程桥接提供可用协议基础。

**Alternatives considered**:

- 直接透传错误对象：本地调试体验好，但不可序列化且容易爆炸式膨胀，影响性能与桥接能力。

## Decision 6: 性能基线的测量策略

**Decision**: 以可复现脚本/基准用例记录“创建/初始化门禁/终止”的时间与分配基线，并在实现后复测，作为回归防线的最小证据包。

**Rationale**:

- 生命周期升级触及核心路径，必须先有基线，再谈预算与回归。

**Alternatives considered**:

- 只靠直觉或局部 profile：无法复现与对比，难以形成长期回归防线。

## Decision 7: `$.lifecycle.*` 仅允许在 setup 阶段注册（setup-only）

**Decision**: 将 `$.lifecycle.*` 固定为 setup-only 的“声明/注册”API：仅允许在 Logic 的 setup 阶段注册（推荐在 `Module.logic(($) => { ... })` 的同步部分，或 `LogicPlan.setup` 内完成）；run 阶段调用必须被拒绝并输出可行动诊断，但不得因为“误用”终止实例或改变既有注册结果。

**Rationale**:

- 避免 run 阶段“晚注册”引入竞态与语义漂移（初始化门禁、销毁顺序、兜底覆盖率会变得不可预测）。
- 让生命周期集合成为可审计的“静态输入”，便于 Devtools/平台解释与回放对齐。
- 与“尽量少用 hooks、把结构性能力下沉到 Module/Logic”的目标一致：setup 只做结构注册，run 只做长期行为。

**Alternatives considered**:

- 允许 run 阶段动态注册：看似灵活，但会破坏门禁与顺序的可推导性；同时会迫使运行时引入复杂的去重/版本化/竞态解决机制，最终难以解释与诊断。
