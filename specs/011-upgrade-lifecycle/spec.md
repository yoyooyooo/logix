# Feature Specification: Lifecycle 全面升级

**Feature Branch**: `[011-upgrade-lifecycle]`  
**Created**: 2025-12-16  
**Status**: Draft  
**Input**: User description: "对生命周期做个全面升级"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 声明式模块生命周期 (Priority: P1)

作为模块作者，我希望在模块内部以声明式方式定义“初始化 / 销毁 / 错误兜底”等生命周期行为，而不是依赖 UI 层的生命周期钩子。生命周期必须与“模块实例是否可用”严格对齐，且在不同消费模式下（同步获取 / 可等待获取）表现一致。

**Why this priority**: 生命周期是模块行为与资源管理的地基；如果语义不稳定，会导致初始化抖动、清理遗漏、错误难复现，进而拖慢上层领域能力（Form/Query/Pattern）的演进。

**Independent Test**: 仅实现该故事即可：用一个最小模块注册初始化/销毁/错误处理，创建实例并触发销毁与错误，验证顺序、次数与可用性门禁均符合预期。

**Acceptance Scenarios**:

1. **Given** 一个模块声明了“必需初始化任务”，且该任务需要一段可观测的完成时间，**When** 消费方以“可等待获取”的方式请求该模块实例，**Then** 在初始化完成前消费方无法读取到“可用实例”，初始化完成后才获得实例且可正常读写状态/派发动作。
2. **Given** 一个模块声明了多段初始化任务，**When** 创建模块实例，**Then** 初始化任务按声明顺序串行执行，且在任意一段失败时：系统会触发错误兜底与诊断事件，并使“该次初始化”对消费方呈现为失败（而不是静默忽略）。
3. **Given** 一个模块声明了多段销毁任务，**When** 模块实例被终止（无论是正常终止还是因错误导致终止），**Then** 销毁任务必定执行一次且仅一次，并且按“后声明先执行”的顺序执行，以符合资源释放直觉。

---

### User Story 2 - 平台信号与会话语义解耦 (Priority: P2)

作为平台/适配层作者，我希望能向模块实例广播“挂起 / 恢复 / 软重置”等平台信号，用于暂停高频行为、恢复订阅、或触发业务重置，但不应等同于销毁模块实例；未注册相关处理器时，系统应安全地忽略这些信号。

**Why this priority**: 平台信号是长任务/轮询/订阅等行为质量的关键；若必须通过销毁重建来响应，会造成状态丢失与额外初始化开销。

**Independent Test**: 仅实现该故事即可：创建模块实例后发送挂起/恢复/软重置信号，验证模块未被终止、状态不丢失、且仅注册过的处理器会被调用。

**Acceptance Scenarios**:

1. **Given** 模块实例处于可用状态并注册了挂起/恢复处理器，**When** 平台发出“挂起→恢复”信号，**Then** 对应处理器被调用且模块实例仍保持可用状态（无需重新初始化）。
2. **Given** 模块未注册任何平台信号处理器，**When** 平台发出挂起/恢复/软重置信号，**Then** 系统不会抛错、不会引发模块终止、也不会产生高成本的诊断噪音。

---

### User Story 3 - 生命周期可诊断、可解释 (Priority: P3)

作为使用 Devtools/诊断能力的开发者，我希望在模块出现初始化失败、后台逻辑崩溃或销毁异常时，可以在诊断事件中看到一致、可序列化、可关联的上下文，从而快速回答“哪个实例、在哪个阶段、因为什么原因”。

**Why this priority**: 生命周期问题通常发生在“系统边界”处（初始化/销毁/后台任务），一旦缺少上下文，定位成本高且易误判为业务 bug。

**Independent Test**: 仅实现该故事即可：构造初始化失败、后台逻辑崩溃、销毁失败三类场景，验证每类都产生结构化且可关联的诊断事件，并能在不查看源码的情况下确定阶段与实例。

**Acceptance Scenarios**:

1. **Given** 某模块实例初始化阶段发生未处理失败，**When** 失败被观测到，**Then** 产生一条结构化错误事件，其中包含可关联的实例标识与阶段信息（例如“初始化/后台运行/销毁/平台信号”），且事件负载可序列化。
2. **Given** 模块在后台运行中发生未处理失败并即将终止，**When** 错误被上报，**Then** 若模块未显式注册错误兜底处理器，系统仍会输出明确的诊断提示，引导作者补齐错误兜底策略。
3. **Given** 某模块实例处于初始化进行中且初始化任务长时间未完成（例如卡在外部依赖或逻辑自我等待），**When** 开发者查看生命周期状态或诊断事件，**Then** 必须能看到稳定实例锚点与初始化进度摘要（总任务数/已完成数/当前执行序号/已运行时长或开始时间），以便快速判断“卡在 init”而不是误判为 UI/Suspense 问题；上述摘要必须是 slim 且可序列化的。

---

### User Story 4 - 错误处理模式清晰分层（全局 → 模块 → 局部）(Priority: P1)

作为 Logix 的使用者与架构维护者，我希望从“应用全局”到“单个模块实例”再到“单次业务流程”，都有一套一致、可组合、可解释的错误处理模式：我能明确知道不同类型的失败（预期错误 / 缺陷 / 装配失败 / 中断 / 诊断提示）分别应该在哪里处理、会以什么形式暴露、以及默认会不会终止实例。

**Why this priority**: 生命周期升级会放大错误语义的不一致：同一类失败若在不同入口表现不同（抛出/吞掉/仅日志），会导致上层业务无法稳定设计兜底策略，平台与 Devtools 也无法给出统一解释。

**Independent Test**: 仅实现该故事即可：构造「预期错误被捕获」「未处理缺陷」「取消/中断」「装配解析失败」四类场景，验证错误在对应层级被处理/暴露，且不会出现“取消当错误上报”或“装配失败被静默吞掉”等语义漂移。

**Acceptance Scenarios**:

1. **Given** 业务流程产生预期错误且在局部被捕获并转化为状态更新，**When** 流程结束，**Then** 模块实例不应被终止，也不应产生“未处理错误”类事件；开发者能从文档明确知道应在何处用何种方式捕获预期错误。
2. **Given** 模块后台逻辑发生未处理缺陷，且模块注册了错误兜底处理器，**When** 缺陷被观测到，**Then** 模块级兜底处理器会被触发用于最后上报，同时全局层面的错误处理入口也会收到该失败；事件中包含一致的阶段与实例关联信息，便于 Devtools/平台解释。
3. **Given** 发生取消/中断（例如并发语义切换或实例终止导致 Fiber 被中断），**When** 取消发生，**Then** 系统不得将其当作错误上报（不触发错误兜底链路、不产生高严重级别诊断噪音），并且文档明确说明取消语义与失败语义的区别。
4. **Given** 发生装配/解析失败（例如依赖解析缺失提供者），**When** 失败被暴露给调用方，**Then** 错误信息应保持稳定且可修复（包含请求 token、发生位置、语义模式与修复建议），并在文档中提供清晰的排查与修复路径。

---

### User Story 5 - `$.lifecycle` 仅允许在 setup 注册 (Priority: P1)

作为模块作者，我希望 `$.lifecycle.*` 始终是“声明/注册”语义，并且必须在 Logic 的 setup 阶段完成注册；这样生命周期门禁、销毁顺序与错误兜底的行为才能稳定可预测，不会因为运行期的“晚注册”引入竞态与语义漂移。

**Why this priority**: 生命周期属于运行时契约层；一旦允许在 run 段动态修改生命周期注册集合，就无法保证门禁一致性、销毁顺序与兜底覆盖率，也会让 Devtools/平台难以解释“为什么这个实例在某次运行里行为不一样”。

**Independent Test**: 仅实现该故事即可：构造“run 段晚注册 lifecycle”与“run 段使用 Scope 原语做动态资源清理”两类用例，验证系统既能拒绝晚注册、又不会阻塞合理的动态资源模式。

**Acceptance Scenarios**:

1. **Given** 模块在 run 段尝试调用任意 `$.lifecycle.*` 注册 API（初始化/销毁/错误兜底/平台信号处理），**When** 该调用发生，**Then** 系统必须拒绝该注册并输出可行动的诊断提示（引导移动到 setup 段），且该调用不得改变既有生命周期注册结果，也不得导致模块实例因“误用”而终止。
2. **Given** 模块需要在 run 段按条件动态创建资源并在实例终止时释放，**When** 作者使用 Effect/Scope 原语表达 acquire/release 或 finalizer，**Then** 资源释放必须在实例终止时可靠执行，且不要求在 run 段通过 `$.lifecycle.onDestroy` 做“晚注册”。

---

### User Story 6 - React RuntimeProvider 的错误上报桥 (Priority: P2)

作为 React 应用集成者，我希望 `RuntimeProvider` 能提供一个可选的 `onError` 回调，用于统一接入团队的错误上报/监控系统：它既能上报 Provider 自身的“Layer 构建失败”等集成错误，也能监听到子树内模块实例的“未处理失败”事件（例如 `lifecycle:error` 与高严重级别诊断），而无需在应用里到处手写自定义 DebugSink。

**Why this priority**: React 集成是默认入口；若缺少一个统一的上报桥，团队往往会在 UI 层写零散的 try/catch 或重复的 logger glue，导致错误语义分裂且难以复用。

**Independent Test**: 仅实现该故事即可：构造“Provider.layer 构建失败”“模块后台逻辑崩溃产生 lifecycle:error”“嵌套 Provider 的 onError 叠加/覆盖行为”三类场景，验证回调触发时机、重复/遗漏与对现有 Devtools/DebugSink 的兼容均符合预期。

**Acceptance Scenarios**:

1. **Given** `RuntimeProvider` 传入的 `layer` 构建失败，**When** Provider 尝试构建该 layer，**Then** `onError` 必须被调用一次并携带可解释上下文（例如“layer.build failed”），且 Provider 不得让整个应用崩溃；调用方可选择展示 fallback 或交由 ErrorBoundary 处理。
2. **Given** 子树内某个模块实例发生未处理失败并产生 `lifecycle:error` 事件，**When** 该事件被记录，**Then** `onError` 必须被调用（至少包含 `moduleId + instanceId` 等关联信息），且不得破坏既有 DebugSink/Devtools 的事件消费（onError 仅作为观测桥，不改变语义）。
3. **Given** 存在嵌套的 `RuntimeProvider`（外层与内层均提供 `onError`），**When** 子树内发生错误事件，**Then** 错误上报行为必须可预测（例如“按 Provider 链路从内到外触发，或显式声明覆盖策略”），且不得因 Provider 重建导致 ModuleCache 退化为“每组件一份 cache”。

### Edge Cases

- 同一模块实例在短时间内被重复“创建→释放→再创建”（例如开发/调试模式下的重复装配与撤销导致的抖动）时，生命周期任务不会重复执行到破坏性程度，并且系统能检测到并发/重复执行风险并给出诊断提示。
- 初始化尚未完成时就发生终止（例如消费方放弃等待或发生致命错误）时，销毁逻辑仍能安全执行且不产生资源泄漏。
- 错误兜底处理器自身失败时，不会造成无限递归或吞掉原始错误；系统会记录“兜底失败”的二级诊断信息。
- 多实例并行运行时，生命周期事件不会串台，实例标识能稳定区分不同实例与不同会话。
- 生命周期相关任务若被错误地放入“同步事务窗口”执行，系统会输出可行动的诊断提示并避免死锁。

## Requirements *(mandatory)*

### Scope Boundaries

**In Scope**:

- 统一模块实例的生命周期语义：初始化门禁、销毁顺序、错误兜底与诊断链路、平台信号解耦。
- 提供“分形组合”能力：允许领域包/特性模块以可组合方式贡献生命周期行为，由宿主模块选择性启用。
- 提升可诊断性：补齐生命周期阶段上下文、事件关联与可解释链路，并控制默认开销。

**Out of Scope**:

- 不重做模块系统的整体建模（例如模块定义方式、状态模型本身），仅在生命周期相关语义上升级。
- 不要求一次性改写所有现存业务/示例代码，但必须提供可执行的迁移路径与验收用例覆盖。
- 不在本特性内引入新的持久化/存储机制；生命周期升级只关心“实例存在与行为”的语义。

### Assumptions

- 允许破坏性变更：旧生命周期写法可被替换，系统以“语义正确、可诊断、可测”为第一优先级。
- 生命周期钩子中的业务失败应当可控：模块作者需要显式区分“必须成功才能可用”的初始化与“可失败但需上报”的启动任务。
- 平台/适配层可以在需要时提供“稳定的实例标识来源”（例如某个业务 key），用于诊断关联与实例区分。

### Dependencies

- 依赖既有的诊断事件通道与调试工具消费能力来展示生命周期事件；若调试工具暂未支持新字段，仍需保证事件可被无损记录与回放。
- 依赖平台/适配层能够向运行时广播平台信号（挂起/恢复/软重置）；在缺少平台信号来源时，相关能力应自动降级为 no-op。

### Functional Requirements

- **FR-001**: 系统 MUST 提供一种声明式方式，让模块作者为“单个模块实例”注册生命周期行为：初始化、销毁、错误兜底，以及平台信号处理器（挂起/恢复/软重置）。
- **FR-002**: 系统 MUST 将初始化划分为“必需初始化任务”与“非必需启动任务”两类，并允许模块作者明确表达两类任务的差异：前者决定实例可用性，后者不影响实例进入可用状态但失败必须被上报。
- **FR-003**: 系统 MUST 保证必需初始化任务按声明顺序串行执行；全部完成前实例不得对外呈现为“可用”。
- **FR-004**: 系统 MUST 在必需初始化任务失败时，使“该次初始化”对消费方呈现为失败，并同时触发错误兜底与诊断事件（不得静默忽略）。
- **FR-005**: 系统 MUST 保证销毁任务在实例终止时执行一次且仅一次，并按“后声明先执行”的顺序执行。
- **FR-006**: 系统 MUST 统一错误上报语义：来自初始化/后台运行/销毁/平台信号处理器的未处理失败，都必须进入同一条错误兜底与诊断链路，并携带阶段上下文。
- **FR-007**: 系统 MUST 支持“分形组合”：领域包/特性模块可以以可组合的方式为宿主模块贡献生命周期行为，而无需借助 UI 层生命周期钩子；宿主模块可以选择性启用/禁用这些贡献。
- **FR-008**: 系统 MUST 支持平台信号（挂起/恢复/软重置）在不终止实例的前提下驱动行为变化；未注册处理器时必须安全忽略，且不产生高噪音错误。
- **FR-009**: 系统 MUST 提供一致的“初始化状态”对外表达，使消费方可以区分“未开始/进行中/成功/失败”，并可在需要时等待初始化完成后再进入业务交互。
- **FR-009a**: 当初始化处于进行中时，系统 MUST 提供可被诊断/Devtools 消费的“初始化进度摘要”（至少包含必需初始化任务的总数与已完成数；可选包含当前任务序号与开始时间/已运行时长）；该摘要必须与实例锚点可关联、slim 且可序列化。
- **FR-010**: 系统 MUST 防止生命周期任务在“同步事务窗口”内执行任何会导致等待/阻塞的工作；若发生违例，必须给出可行动的诊断提示并避免死锁。
- **FR-011**: 系统 MUST 定义并固化统一的错误分类与默认处理策略（预期错误 / 缺陷 / 装配失败 / 中断 / 诊断提示），并保证同一类失败在不同消费入口下对外表现一致且可解释。
- **FR-012**: 系统 MUST 将“全局 → 模块 → 局部”的错误处理模式沉淀为内部规范与用户文档：每一层提供清晰的推荐做法、边界与反例，并能通过独立验收场景验证文档描述与行为一致。
- **FR-013**: 系统 MUST 将 `$.lifecycle.*` 定义为 setup-only 的“声明/注册”API：run 阶段调用必须被拒绝并给出可行动诊断，且不得改变生命周期注册结果或导致实例因误用而终止。
- **FR-014**: React 集成层 MUST 为 `RuntimeProvider` 提供可选的错误上报桥（`onError`）：能上报 Provider 集成错误（如 layer 构建失败）并监听模块实例的未处理失败事件；该桥接仅用于观测与上报，不得改变运行时错误语义。

**Acceptance Coverage (Traceability)**:

| Requirement | Covered By |
|------------|------------|
| FR-001 | User Story 1 (Scenarios 1–3), User Story 2 (Scenarios 1–2) |
| FR-002 | User Story 1 (Scenarios 1–2) |
| FR-003 | User Story 1 (Scenarios 1–2) |
| FR-004 | User Story 1 (Scenario 2), User Story 3 (Scenario 1) |
| FR-005 | User Story 1 (Scenario 3), Edge Cases (init 未完成即终止) |
| FR-006 | User Story 3 (Scenarios 1–2), Edge Cases (兜底自身失败) |
| FR-007 | Scope Boundaries (In Scope), User Story 1 (Independent Test), User Story 2 (Independent Test) |
| FR-008 | User Story 2 (Scenarios 1–2) |
| FR-009 | User Story 1 (Scenario 1), User Story 3 (Independent Test) |
| FR-009a | User Story 3 (Scenario 3) |
| FR-010 | Edge Cases (事务窗口违例) |
| FR-011 | User Story 4 (Scenarios 1–4) |
| FR-012 | User Story 4 (Independent Test), Success Criteria (SC-006) |
| FR-013 | User Story 5 (Scenarios 1–2) |
| FR-014 | User Story 6 (Scenarios 1–3) |

### Non-Functional Requirements (Performance & Diagnosability)

- **NFR-001**: 系统 MUST 为本次升级触及的运行时核心路径建立可复现的性能基线，并定义预算：模块实例创建、初始化门禁、终止/清理这三条路径的开销不得超过基线的可接受增量。
- **NFR-002**: 系统 MUST 提供结构化诊断信号覆盖关键生命周期转折点（初始化开始/完成/失败、终止开始/完成、平台信号触发、错误兜底触发），且在诊断关闭时开销接近零。
- **NFR-003**: 系统 MUST 在诊断与回放表面使用确定性标识符关联“模块实例 / 生命周期阶段 / 事务与操作序列”，不得依赖随机值或时间戳作为默认标识来源。
- **NFR-004**: 系统 MUST 强制同步事务边界：事务窗口内禁止 IO/异步等待，并且禁止业务侧通过任何逃逸手段在事务外写入订阅式引用。
- **NFR-005**: 诊断事件 MUST 是 slim 且可序列化的；系统不得在默认诊断事件中嵌入不可序列化对象或超大负载（例如完整堆栈对象树）。

### Key Entities *(include if feature involves data)*

- **Module Instance**: 单个模块实例的运行单元，具备独立的初始化、后台运行、终止过程与平台信号响应。
- **Lifecycle Task**: 在某个生命周期阶段被系统调度的任务单元（必需初始化 / 非必需启动 / 销毁 / 平台信号处理）。
- **Lifecycle Outcome**: 初始化与终止的结果表达（成功/失败及失败原因），用于消费方与诊断系统统一理解。
- **Lifecycle Error Context**: 错误兜底与诊断所需的上下文字段集合，至少包含阶段、实例标识与关联信息。
- **Lifecycle Diagnostic Event**: 面向诊断与 Devtools 的结构化事件，承载可序列化的最小证据与可解释链路。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 模块作者在不依赖 UI 生命周期钩子的前提下，可以仅通过模块内部声明完成初始化/销毁/错误兜底的接线；上述能力可通过独立的自动化验收场景验证。
- **SC-002**: 在至少 3 个代表性场景（初始化失败、后台崩溃、销毁失败）中，诊断事件能让开发者在不查看源码的情况下明确定位到“哪个实例、哪个阶段、失败原因是什么”，且每个场景的定位步骤不超过 3 步。
- **SC-003**: 对于包含多个生命周期任务的模块实例：必需初始化任务的执行顺序与“实例可用性门禁”在所有运行模式下保持一致，且验收用例覆盖“成功/失败/中途终止”三类路径。
- **SC-004**: 性能不回归：在相同负载下，模块实例创建与终止在 95% 的情况下耗时相对基线增量不超过 5%，且测量方法可复现。
- **SC-005**: 诊断开销可控：在关闭诊断时，模块实例创建与终止在 95% 的情况下耗时相对基线增量不超过 1%；在开启诊断时，每个模块实例在一次完整生命周期内产生的生命周期相关事件数量不超过 20 条，且单条事件序列化后大小不超过 4 KB，并可通过验收场景自动化验证。
- **SC-006**: 错误处理模式可达且一致：内部规范与用户文档各提供一份独立的“错误处理”指南，覆盖至少 5 类错误与 3 个处理层级（全局/模块/局部），并且从生命周期/调试等入口在不超过 2 次跳转内可定位到该指南；开发者可以在不查源码的前提下按指南完成接线并通过验收场景验证行为一致。
