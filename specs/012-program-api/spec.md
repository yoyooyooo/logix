# Feature Specification: Process（长效逻辑与跨模块协同收敛）

**Feature Branch**: `[012-program-api]`  
**Created**: 2025-12-16  
**Status**: Draft  
**Input**: User description: "收敛跨模块长效逻辑为 Process，支持应用级/实例级/UI 子树三级作用域安装，统一触发/并发语义、生命周期监督与可观测事件"

## Terminology

- 本特性使用 **Process** 表示“跨模块协作 + 长效运行”逻辑；用于避免与 `Runtime.runProgram/openProgram` 的 “Program（根模块运行入口）” 以及 `StateTraitProgram` 等既有术语混淆。

## Clarifications

### Session 2025-12-25

- Q: Process 的默认错误策略选哪一个？ → A: `failStop`（失败即停）
- Q: Process 的默认诊断级别选哪一个？ → A: 默认 `off`（按需开启）
- Q: 依赖/触发的 moduleId 在当前安装作用域解析到多份实例时怎么办？ → A: 失败并给出可修复提示（禁止猜实例）
- Q: serial 并发语义下的默认 maxQueue 怎么处理？ → A: 默认 `unlimited`（但必须有背压/护栏与可诊断证据）
- Q: moduleStateChange 触发器的 path 路径语法选哪一种？ → A: `dot-path`（`.` 分段；数字段表示数组下标）

### 约束补充（可直接验收）

#### `serial` / `maxQueue`（默认 `unlimited`）护栏语义

- `serial` 表示同一 Process Instance 的触发与 dispatch 串行执行；触发到来时进入队列。
- 当未显式配置 `maxQueue` 时，视为 `unlimited`，但运行时 MUST 仍提供护栏以防止无界内存增长：
  - 默认超限策略 MUST 为停止并报错（failStop）：产出 `process:error` 且 `error.code` 固定为 `process::serial_queue_overflow`，并提供可修复 `hint`（建议配置 `maxQueue` 或改用 `latest/drop`）。
  - MUST 在 diagnostics `light/full` 下提供可诊断证据（至少包含队列峰值/当前长度/超限策略）；默认策略为 failStop 时应在 `error.hint` 中携带上述证据。
- 当显式配置 `maxQueue` 时，`maxQueue` MUST 作为硬上限；达到上限时行为与证据口径必须与上述护栏一致。

#### `moduleStateChange.path` 的 `dot-path` 语法约束

- `dot-path` 以 `.` 分段；数字段表示数组下标（例如 `items.0.id`）。
- `path` 解析/校验失败时 MUST 失败并给出可修复提示（指出出错段位与修复建议），禁止静默回退或广播。

## User Scenarios & Testing _(mandatory)_

### User Story 1 - 统一长效逻辑为 Process（应用级） (Priority: P1)

作为应用/平台开发者，我希望只用一个概念（Process）来承载“跨模块编排 + 长期运行”的逻辑（例如把模块 A 的事件转换为模块 B 的动作、后台轮询、平台事件桥接），并由系统在合适的生命周期自动启动/停止，避免出现多套机制并存导致的歧义与维护成本。

**Why this priority**: 这是“收敛对外入口”本身的最小闭环：只要 Process 在应用级可用，团队就能用同一套心智模型表达多数跨模块/长效逻辑，并为后续的实例级/子树级能力打基础。

**Independent Test**: 在一个最小应用里声明 1 个 Process，让它订阅模块 A 的事件并驱动模块 B 的动作；验证 Process 会随应用运行时启动/停止，并且协同结果可观察/可断言。

**Acceptance Scenarios**:

1. **Given** 应用运行时已装配模块 A 与模块 B，且声明了一个应用级 Process（依赖 A/B），**When** 应用启动并触发 A 的某个事件，**Then** Process 会驱动 B 产生预期动作/状态变化。
2. **Given** Process 正在运行，**When** 应用运行时被停止/销毁，**Then** Process 会被终止且不再产生任何跨模块影响（无残留后台行为）。
3. **Given** Process 声明依赖某个模块/能力但当前作用域未装配，**When** 应用启动该 Process，**Then** 系统会失败并提供可修复的错误信息（指出缺失依赖与修复建议），而不是静默回退到其他作用域。

---

### User Story 2 - 实例级协同：Process 随模块实例生命周期运行 (Priority: P2)

作为业务开发者，我希望在“会话/页面/流程”这种多实例场景下，让长效编排逻辑跟随某个模块实例而存在（而不是全局唯一）。当同一业务存在两份实例（例如 Session A/B）时，Process 必须只在各自实例作用域内协作，避免串实例。

**Why this priority**: 这是本体系相比传统全局事件总线模型的关键优势：把“实例选择”从隐式猜测变成作用域语义的一部分，显著降低跨模块 bug 与排查成本。

**Independent Test**: 在同一应用中创建同一宿主的两份实例（A/B），每份实例都安装同一个实例级 Process；验证它们各自只影响自己作用域内显式装配的子模块，不发生交叉影响。

**Acceptance Scenarios**:

1. **Given** 同一宿主存在两份实例（A/B），且每份实例作用域内装配了同构的依赖模块集合，**When** A 触发某事件，**Then** 只有 A 作用域内的目标模块被影响，B 不受影响（反之亦然）。
2. **Given** 某个宿主实例被销毁，**When** 该实例对应的 Process 仍有未完成工作或订阅，**Then** Process 会被终止并释放资源，不继续在后台影响系统。

---

### User Story 3 - 统一触发/并发语义与可诊断性 (Priority: P3)

作为开发者与运维者，我希望 Process 的触发方式（模块事件/状态变化/平台事件/定时等）与并发语义（例如“只处理最新一次”“串行排队”“忽略重入”“并行处理”）在系统层面保持一致，并且能被清晰解释与诊断：我能回答“哪个 Process 因为什么触发，进而驱动了哪个模块动作”。

**Why this priority**: 这是从“能跑”走向“可维护、可交付”的关键；没有统一语义与诊断，长效逻辑会迅速变成系统隐患。

**Independent Test**: 用最小示例声明一个 Process，分别验证两种并发策略（例如“最新覆盖” vs “串行排队”）在相同触发条件下得到可区分的、可预测的结果；并验证诊断信息可用于定位触发链路与失败原因。

**Acceptance Scenarios**:

1. **Given** 同一触发源在短时间内连续触发多次，且 Process 配置为“只处理最新一次”，**When** 触发发生，**Then** 系统只产生一次最终可见的结果，且中间过程不会导致资源泄漏或状态污染。
2. **Given** 同一触发源连续触发多次，且 Process 配置为“串行排队”，**When** 触发发生，**Then** 系统按顺序处理并产生多次可见结果（顺序可被验证）。
3. **Given** 诊断能力开启，**When** Process 启动/停止/失败或触发跨模块协作，**Then** 系统能够产出结构化、可序列化的诊断信号，定位到 Process 的稳定标识、作用域与触发链路。
4. **Given** Process 使用默认错误策略，**When** Process 发生可预期失败，**Then** 系统会以默认策略处理并产出可解释诊断信号（不会出现隐式无限重试）。
5. **Given** Process 显式配置为受控监督策略（有明确上限），**When** Process 连续失败，**Then** 系统会在上限内进行受控重启并产生对应诊断信号，达到上限后停止。

---

### Edge Cases

- 缺失依赖：Process 依赖的模块/能力在当前作用域未装配时，必须失败且给出可修复提示（禁止隐式回退）。
- 多实例歧义：同一模块存在多份实例时，Process 不得“猜”目标实例；必须由安装点/作用域决定。
- 多实例消歧失败：当 Process 在当前作用域内解析到多个候选实例时，必须失败并给出可修复提示（例如迁移到实例级安装点或调整作用域）；禁止自动广播或默认选择某个实例。
- 频繁启停：在开发环境重复挂载/卸载或 UI 子树频繁切换下，Process 不得发生重复启动导致的副作用放大。
- 错误风暴：Process 在短时间内连续失败时，系统必须避免无界重试/日志刷屏；错误策略需可控且可诊断。
- 高并发触发：触发源高频时，系统必须有明确背压/并发语义，避免隐式内存增长。

## Requirements _(mandatory)_

### Scope & Non-Goals

本特性关注“长效逻辑与跨模块协同”这一类能力的对外入口/语义收敛，目标是把现有分散机制统一为 Process，并提供可分层安装的生命周期与诊断能力。

**In Scope**:

- 统一概念：以 Process 作为唯一收口点，覆盖跨模块协作、后台常驻逻辑与平台事件桥接。
- 分层安装：应用级 / 模块实例级 / UI 子树级三种安装点的语义与生命周期。
- 统一语义：触发模型与并发语义的统一与可解释性。
- 可运维：错误策略（失败即停/受控监督）与结构化诊断事件（启动/停止/失败/“触发到驱动”的链路）。

**Out of Scope**:

- 分布式/跨进程调度与高可用（例如“进程挂了自动迁移到别的进程继续跑”）。
- 任务持久化与重启续跑（例如系统重启后自动恢复上一次未完成的 Process 状态）。
- 跨应用/跨运行时的隐式实例选择（禁止“全局猜实例”）。

### Migration Scope（避免“收敛口径”漂移）

为避免“统一/收敛”被理解成“所有历史入口都要迁移”，本特性只对以下入口/写法承担迁移义务：

**In Scope（需要迁移到 Process）**:

- 任何“跨模块协作 + 长效运行”的逻辑：统一收敛为 `Process`，并通过 `processes` 作为唯一运行承载（作用域随安装点决定）。
- `Link.make` 场景：默认以 `linkId` 作为 `processId`，作为应用级 Process 运行（用于 dogfooding 与稳定标识示例）。
- 对外文档/示例中把“长效逻辑”称为 Program 的写法：迁移到 Process（但保留 root runner 的 Program 概念，见下条）。

**Out of Scope（不在本特性内迁移）**:

- `Runtime.runProgram/openProgram` 的根模块运行入口语义（仍保留 Program 概念；本特性只做“长效逻辑入口”的 Process 收敛，避免概念混用）。

### Assumptions & Dependencies

- 模块与运行时的基础抽象保持稳定（本特性不同时引入另一套模块/依赖注入模型）。
- 运行时具备可扩展的诊断事件通道，可新增 Process 相关事件而不引入显著性能回退。
- UI 适配层能够提供“子树作用域”的明确生命周期边界，用于安装点的启停管理。

### Acceptance Coverage

为避免“需求写完但验收无抓手”，本特性至少提供以下端到端验收用例，并要求每条功能需求都能映射到至少一个用例中：

- **AC-1**: 应用级 Process 协同用例（模块 A 事件 → 模块 B 动作）
- **AC-2**: 双实例隔离用例（Session A/B 不串）
- **AC-3**: 缺失依赖可修复错误用例（失败 + 修复建议）
- **AC-4**: 并发语义用例（最新覆盖 vs 串行排队）
- **AC-5**: 诊断可解释用例（能复原“触发到驱动”的链路）
- **AC-6**: UI 子树作用域启停用例（挂载启动/卸载停止，无残留后台影响）
- **AC-7**: 错误策略用例（默认策略 + 自定义策略）

### Functional Requirements

- **FR-001**: 系统 MUST 提供统一的“Process”概念，用于表达“跨模块协作 + 长效运行”逻辑；历史上用于表达同类能力的机制/入口应被收敛为 Process 的不同安装形态。（验收覆盖：AC-1）
- **FR-002**: 系统 MUST 支持至少两种 Process 安装点：应用级作用域与模块实例作用域；每种安装点 MUST 有明确、可预测的启动/停止生命周期，并随其作用域自动清理。（验收覆盖：AC-1、AC-2）
- **FR-003**: 系统 MUST 支持第三种可选安装点：UI 子树作用域；其生命周期 MUST 与 UI 子树挂载/卸载一致（用于局部启停）。（验收覆盖：AC-6）
- **FR-004**: Process 的依赖解析 MUST 严格限定在其安装作用域内；缺失依赖 MUST 失败并给出可执行的修复建议；禁止任何跨作用域的隐式兜底或“猜实例”。（验收覆盖：AC-3）
- **FR-005**: Process MUST 能观察模块事件与变化（例如动作与状态变化），并能通过“模块动作协议”驱动其他模块；系统 MUST 防止 Process 绕过模块边界直接写入其他模块状态（跨模块影响必须通过动作/协议完成）。其中 `moduleStateChange` 触发器的 `path` MUST 使用 `dot-path` 语法（`.` 分段；数字段表示数组下标，例如 `items.0.id`）。（验收覆盖：AC-1、AC-2）
- **FR-006**: 系统 MUST 为 Process 提供统一的触发模型与并发语义（至少覆盖：最新覆盖、串行排队、忽略重入、并行处理 四类可区分策略），并且不同触发源（事件/变化/平台/定时）下的语义应一致可解释；其中 `serial` 若未配置 `maxQueue`，默认视为 `unlimited`，但必须有背压/护栏且在 `light/full` 下提供可诊断证据，避免隐式无界内存增长。（验收覆盖：AC-4）
- **FR-007**: 系统 MUST 提供 Process 的错误处理策略，且策略 MUST 显式可配置；默认策略 MUST 明确且可预测：默认 `failStop`（失败即停），`supervise` 必须显式配置且有明确上限；不得出现隐式无限重试。（验收覆盖：AC-7）
- **FR-008**: 系统 MUST 为 Process 提供结构化诊断信号（启动/停止/失败/重启、触发与跨模块驱动链路），并支持用稳定标识将诊断与具体作用域/实例关联。（验收覆盖：AC-5）

### Non-Functional Requirements (Performance & Diagnosability)

- **NFR-001**: 系统 MUST 在实现前后提供可复现的性能基线；并为“关键热路径”（模块事件分发、Process 触发与调度、作用域启停）定义明确预算，确保引入 Process 后无可见回退。
- **NFR-002**: 诊断能力 MUST 默认低成本；默认诊断级别为 `off`，按需开启；在约定基准场景下，diagnostics=`off` 时 Process 引入的 p95 额外开销目标 ≤ 1%（工程预算），并能对比 `off/light/sampled/full` 给出代价证据。
- **NFR-003**: Process/实例/作用域的标识 MUST 稳定且可预测，不得默认使用随机或时间戳作为唯一识别方式；同一输入下应生成一致的标识与诊断关联。
- **NFR-004**: 系统 MUST 保持同步事务边界：在事务窗口内禁止 IO/异步工作；Process 触发的跨模块驱动不得破坏该边界（避免出现“事务内 IO”或“越界写入”的逃逸）。

### Key Entities _(include if feature involves data)_

- **Process Definition**: 对“长效逻辑”的声明，包含稳定标识、依赖集合、触发源、并发与错误策略。
- **Process Installation**: Process 被安装到某个作用域的装配记录（应用级作用域 / 模块实例作用域 / UI 子树作用域）。
- **Process Instance**: Process 在某个具体作用域内的运行实例（随作用域启停），可用于诊断与定位。
- **Process Trigger**: 触发源（模块事件、状态变化、平台事件、定时等）及其触发上下文。
- **Process Event (Diagnostics)**: 结构化诊断事件（启动/停止/失败/重启、“触发到驱动”的链路），用于解释与回放。

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: 在一个最小示例中，仅通过声明 1 个应用级 Process，即可完成“模块 A 事件 → 模块 B 动作”的协作，并通过验收用例（功能正确）。
- **SC-002**: 在一个双实例示例中（Session A/B），实例级 Process 的协作结果严格隔离：A 的事件不会影响 B（反之亦然），通过验收用例（隔离正确）。
- **SC-003**: 在缺失依赖场景下，系统能在首次运行时给出可修复错误信息；开发者在 2 分钟内可根据错误提示完成修复并通过用例（可修复性）。
- **SC-004**: 在诊断开启时，系统能回答“哪个 Process 因什么触发，最终驱动了哪个模块动作”，并能通过结构化事件链路验证（可解释性）。
- **SC-005**: 在约定的基准场景下，引入 Process 后关键交互的 95 分位响应时间劣化不超过 5%（性能不回退）。
- **SC-006**: 在诊断关闭时，Process 相关诊断事件的产生与存储开销接近零（可通过基准对比验证）。
