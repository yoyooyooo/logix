# Quickstart: 事务性能控制（高性能最佳实践）

**Feature**: `specs/019-txn-perf-controls/spec.md`  
**Created**: 2025-12-20

## ≤5 关键词（心智模型）

1. **事务窗口**：一次同步入口的写入聚合边界，窗口结束最多一次对外提交。
2. **影响域（dirty-set）**：这次写入影响到哪些字段；决定增量派生/校验范围与诊断归因质量。
3. **派生闭包**：提交前的同步收敛链（converge/validate/source idle），应尽量留在同一事务内。
4. **可见性调度**：提交对 UI 的通知节奏（normal/low priority），用于减少非必要 render（不改变最终状态）。
5. **证据链**：每次提交都能解释“谁触发/影响什么/为何这样调度/为何回退”。

## 粗粒度成本模型（你在为哪些成本买单）

- **事务次数**：决定 UI 通知次数与派生/校验频率上界。
- **dirty-set 质量**：越精确，converge/validate 越容易走增量；越粗糙，越容易退化全量。
- **派生/校验规模**：规则越多、依赖越深，越依赖增量与缓存复用。
- **诊断等级**：越多证据越可解释，但启用时应有可预估的额外成本；关闭时应接近零成本。

## 优化梯子（从默认到极端兜底）

1. **默认写法先跑通**：保持写入在同步事务窗口内完成（无 IO/无 await），避免无意扩大事务次数。
2. **先观测再优化**：打开诊断后，先看每次提交的影响域与派生/校验摘要，确认瓶颈是“频率”还是“单次成本”。
3. **缩小影响域**：确保写入能产出字段级 dirty-set；避免未知写入导致 `dirtyAll`。
4. **合并同步反应**：把同步派生/同步校验写回留在同一事务窗口，保证一次触发最多一次可观察提交。
5. **稳定列表身份**：列表/数组相关的派生/校验，优先保证稳定 rowId/identity，避免 index 抖动扩大影响域。
6. **极端兜底（显式 opt-in）**：
   - **Batch Window**：显式包裹一段同步写入，对外只发一次提交。
   - **Low Priority**：显式把部分更新的“对外通知”降到低优先级/可合并，优先保障高优先级交互流畅。

## 反模式（高概率导致退化）

- 在事务窗口里做 IO/await，导致事务变长且不可预测（违规且应被诊断）。
- 用不可追踪的自定义 mutation 写入，导致 dirty-set 退化为 `dirtyAll`，进而派生/校验全量。
- 把大量无关字段绑到同一派生/校验依赖上，导致最小检查集仍然很大。
- 列表 identity 不稳定（用 index 当 id），导致小改动放大为大范围 dirty。

## 排障入口（先定位再改）

- 关注每次提交是否能解释：`origin`、`dirtySet`、`commitMode/priority`、converge/validate 摘要。
- 若频繁出现 `dirtyAll`：优先把写入改为可追踪的字段级写法，并让原因可诊断。
- 若一次触发出现多次提交：检查同步反应是否逃逸出事务窗口（或被错误拆分为多事务）。

## 用户文档落点（需要同步补齐）

- `apps/docs/content/docs/`：补充“高性能最佳实践”章节（关键词/成本模型/优化梯子/反模式/排障），并与诊断字段命名保持一致。

