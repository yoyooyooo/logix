# Feature Specification: 事务性能控制：增量派生、同步合并、低优先级更新与最佳实践

**Feature Branch**: `[019-txn-perf-controls]`  
**Created**: 2025-12-20  
**Status**: Draft  
**Input**: User description: "创建个新 spec，把这1234 全做了。 其实 1 算是 specs/013-auto-converge-planner/ 的延续或者未完全接上的一环吧。4 的话就是需要给用户文档补充完善高性能最佳实践"

## User Scenarios & Testing *(mandatory)*

<!--
  IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
  Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
  you should still have a viable MVP (Minimum Viable Product) that delivers value.
  
  Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
  Think of each story as a standalone slice of functionality that can be:
  - Developed independently
  - Tested independently
  - Deployed independently
  - Demonstrated to users independently
-->

### User Story 1 - 增量派生与校验（减少无效计算） (Priority: P1)

作为业务开发者/运行时使用者，当我只修改少量字段时，系统应只计算与这些字段相关的派生与校验，并跳过无关部分，从而在常规场景中稳定保持低开销与可预测响应。

**Why this priority**: 这是所有性能优化的“底座”：若不能可靠识别“哪些字段变了”，后续的合并/优先级也无法避免 converge/validate 的全量成本。

**Independent Test**: 在一个包含大量派生/校验的代表性模块中，仅修改单一字段即可验证：派生与校验的执行集合显著缩小，且结果正确。

**Acceptance Scenarios**:

1. **Given** 一个包含多条派生规则与校验规则的状态模型，且只修改字段 `A`，**When** 触发一次同步状态写入，**Then** 仅执行依赖 `A` 的派生/校验集合，且不影响其他字段的既有值与错误状态。
2. **Given** 仅修改字段 `A`，**When** 重复触发多次写入且每次写入的影响域相同，**Then** 系统的派生计划应复用既有决策/缓存（在不改变业务结果的前提下），避免重复全量规划。

---

### User Story 2 - 同步反应合并成单次可观察提交 (Priority: P1)

作为业务开发者/运行时使用者，当一次用户触发会带来 reducer、同步派生、同步校验写回等“同步反应”时，这些同步反应应在同一事务窗口内完成（除非该反应包含 IO/异步，或被显式标记为独立事务），从而只产生一次对外可观察的状态提交与一次状态更新事件。

**Why this priority**: 事务次数决定了 converge/validate 的频率与 UI 刷新次数的上界；把“同步反应”内聚到单事务，是减少频率最直接的方式。

**Independent Test**: 构造一个触发链路包含“初始写入 + 同步派生写回 + 同步校验写回”的用例，验证只发生一次对外状态提交。

**Acceptance Scenarios**:

1. **Given** 一次触发会引起多次同步状态写入（同一逻辑链路内），**When** 系统执行该触发，**Then** 对外可观察的状态更新（订阅通知/调试事件）最多出现一次，且最终状态等价于逐步写入后的结果。

---

### User Story 3 - 显式低优先级/批处理模式（极端高频场景兜底） (Priority: P2)

作为业务开发者，在极端高频交互（例如连续输入、拖拽、滚动联动）场景中，我希望能显式选择某些更新为“低优先级/可延迟”或“批处理”，以优先保障高优先级交互的流畅性，同时保证最终一致的状态结果可被正确观察与诊断。

**Why this priority**: 当负载超过预算时，系统需要一个“可控降级/调度”旋钮；显式 opt-in 能避免默认语义变复杂，同时为高压场景提供确定性方案。

**Independent Test**: 在高频触发下同时存在高优先级与低优先级更新，验证高优先级反馈保持稳定，低优先级可被合并/延后但最终必达。

**Acceptance Scenarios**:

1. **Given** 同一会话中存在高优先级交互更新与低优先级派生更新，**When** 发生持续高频触发，**Then** 高优先级交互的可见反馈不被低优先级更新拖慢；低优先级更新允许延迟/合并但最终会收敛到正确状态。
2. **Given** 开发者显式开启批处理窗口并在窗口内执行多次同步写入，**When** 批处理窗口结束，**Then** 对外只产生一次可观察提交（包含聚合后的变更），且诊断信息能解释该批处理的触发与影响域。

---

### User Story 4 - 高性能最佳实践与优化阶梯文档 (Priority: P3)

作为业务开发者，我希望在用户文档中获得一套稳定、可操作的高性能最佳实践：如何订阅、如何收敛写入、如何观察与定位、以及在必要时如何启用批处理/低优先级模式。

**Why this priority**: 运行时能力只有在被正确使用时才能兑现收益；文档是把“默认 → 观测 → 收敛 → 调参/拆分”的路径固化为共识的关键产物。

**Independent Test**: 仅交付文档即可独立验证：文档包含明确的心智模型、成本模型与优化阶梯，并覆盖典型反模式与排障入口。

**Acceptance Scenarios**:

1. **Given** 一名首次接触该能力的业务开发者，**When** 依照文档实践完成一次性能问题定位与修复，**Then** 能在不阅读实现细节的前提下完成：观察 → 归因 → 选择优化动作 → 验证改进。

### Edge Cases

- 当变更涉及列表/数组结构（插入、删除、重排）时，系统如何定义“影响域”，并确保既不过度全量也不漏算？
- 当系统无法可靠推断影响域（例如未知路径、不可解析路径、非法路径片段）时，如何确定性降级，并如何通过诊断信号暴露该降级？
- 当批处理窗口很大或嵌套时，系统如何保证事务边界的同步性与可诊断性，并避免“长事务”导致交互卡顿？
- 当低优先级更新长期积压时，系统如何保证最终可达与可解释（例如保证有上界的延迟/吞吐策略）？
- 当开发者误把 IO/异步工作放入同步事务或批处理窗口时，系统如何阻止并给出可行动的修复建议？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统 MUST 在所有“可追踪的同步写入路径”上生成“字段级影响域”（dirty-set），且不要求业务显式提供 dirty-set：至少覆盖 `$.state.mutate/$.state.update`、`Logix.Module.Reducer.mutate`（主 reducer）、以及 Trait 的同步写回（computed/link/check/source idle）。对于不可追踪写入（例如直接 set 整棵 state、普通 reducer 返回新对象且未提供 patch 证据），系统 MUST 确定性降级为 `dirtyAll=true` 并通过诊断给出原因与迁移建议。
- **FR-002**: 系统 MUST 将影响域归一化为稳定、可比较的字段路径集合（忽略数组索引/通配符等不稳定因素），以支持增量派生与可复现诊断。
- **FR-003**: 系统 MUST 使用字段级影响域驱动派生收敛（converge）的最小执行集合：当影响域与某派生步骤无交集时，该步骤必须被跳过。
- **FR-004**: 系统 MUST 使用字段级影响域驱动校验（validate）的最小执行集合：当影响域与某校验 scope 无交集时，该 scope 必须被跳过。
- **FR-005**: 系统 MUST 提供“同步反应合并”能力：同一触发链路内的同步派生与同步校验写回，应在一次事务窗口内完成，并只产生一次对外可观察提交。
- **FR-006**: 系统 MUST 提供显式的“批处理窗口”能力：在窗口内发生的多次同步写入将被聚合为一次对外可观察提交（订阅通知与调试事件不得被放大）。
- **FR-007**: 系统 MUST 提供显式的“低优先级更新”能力：开发者可将部分更新标记为可延迟/可合并，以优先保障高优先级交互的响应与流畅性。
- **FR-008**: 系统 MUST 定义并公开低优先级更新的可见性语义，至少保证：低优先级更新不会逆序覆盖高优先级结果；低优先级更新最终必达且具有明确的延迟上界；合并规则可被诊断解释。
- **FR-009**: 系统 MUST 为上述能力提供可观测的诊断元信息：每次可观察提交必须可追溯到触发源、影响域与调度模式（普通/批处理/低优先级）。
- **FR-010**: 系统 MUST 明确禁止在同步事务/批处理窗口内执行 IO/异步工作，并为违规用法提供可行动的诊断与替代路径（异步在事务外运行，写回以独立事务表达）。
- **FR-011**: 系统 MUST 给出迁移说明：如何将“多次同步写回/分散写回”的旧写法迁移到“同步合并/批处理/低优先级”模式，并保证迁移后行为可验证。
- **FR-012**: 系统 MUST 在用户文档中提供“高性能最佳实践”：包含心智模型（≤5 关键词）、粗粒度成本模型、优化阶梯、反模式清单与排障入口。

### Assumptions

- 默认模式以“正确性与可解释性优先”，不隐式改变既有提交语义；批处理与低优先级均为显式 opt-in。
- 同步事务窗口必须是短时、可预测的同步执行；任何 IO/异步必须在事务外执行，并以独立写回事务表达最终状态变化。
- 字段路径仅作为“影响域/归因”的结构化标识，不承诺与业务对象的存储结构一一映射（但必须稳定、可比较、可序列化）。
- 本特性不引入默认的“跨事务隐式合并”，也不改变跨实例并发与隔离语义；合并仅发生在显式批处理窗口内，或显式低优先级调度的可见性层。
- 依赖项：派生/校验规则需具备可判定的依赖关系（声明或可推导）；诊断体系需能承载影响域与调度模式元信息；需要可重复运行的代表性基线场景用于验证预算与回归。

### Non-Functional Requirements (Performance & Diagnosability)

<!--
  If this feature touches Logix runtime hot paths, treat performance and
  diagnosability as first-class requirements:
  - Define budgets (time/alloc/memory) and how they are measured
  - Define what diagnostic events/Devtools surfaces exist and their overhead
-->

- **NFR-001**: 系统 MUST 为“同步事务执行路径”与“派生/校验执行路径”定义性能预算，并在实现前记录可复现基线（含吞吐、延迟与内存/分配趋势）。
- **NFR-002**: 系统 MUST 提供结构化诊断信号用于解释关键状态提交与派生/校验决策；当诊断关闭时，额外开销必须接近零。
- **NFR-003**: 系统 MUST 在诊断与回放表面使用确定性标识符（实例/事务/操作序号），不得默认依赖随机数或时间戳生成身份。
- **NFR-004**: 系统 MUST 强制同步事务边界：事务窗口内不得包含 IO/异步；并禁止任何绕过事务/队列的写入逃逸路径。
- **NFR-005**: 系统 MUST 对“批处理/低优先级/增量派生”给出稳定的对外心智模型与成本模型，并在用户文档中提供一致的优化阶梯（默认 → 观测 → 收敛写入 → 缩小影响域 → 稳定列表身份 → 调参/拆分）。术语必须在文档、基线、诊断字段中保持一致。
- **NFR-006**: 系统 MUST 为低优先级更新定义可预测性边界：必须存在可配置的“最大可见延迟上界”，并保证在默认配置下不会出现无限期延迟；合并策略必须可解释且可通过诊断信号复现。

### Key Entities *(include if feature involves data)*

- **影响域（Dirty-Set）**: 一次同步变更影响到的字段路径集合，用于派生/校验的最小调度与诊断归因。
- **事务窗口（Transaction Window）**: 同步执行边界；窗口内聚合同一触发链路的写入，并在窗口结束时对外发布一次可观察提交。
- **批处理窗口（Batch Window）**: 显式开启的事务聚合模式；窗口内多次同步写入对外只形成一次可观察提交。
- **更新优先级（Update Priority）**: 描述更新的可见性与调度策略（例如普通/低优先级）；影响 UI 刷新调度与诊断解释，但不改变最终一致性语义。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 在代表性“高频输入/联动”场景中，高优先级交互的可见反馈延迟满足预算：p95 ≤ 16ms；启用低优先级更新后，高优先级交互不出现显著回退。
- **SC-002**: 在代表性“派生/校验规模较大”的场景中，当单次变更只影响少量字段时，派生/校验的实际执行集合显著小于全量集合：执行比例 ≤ 20%（以基线定义的全量集合为分母）。
- **SC-003**: 在代表性“同步反应链路”场景中，一次触发导致的对外可观察提交次数不随内部同步写回次数线性增长（目标：从多次下降为 1 次）。
- **SC-004**: 诊断与 Devtools 能在一次可观察提交上解释：触发源、影响域、调度模式（普通/批处理/低优先级）与因果链路，并能稳定复现（同输入得到同标识与同解释）。
- **SC-005**: 关键热路径在默认配置下不出现性能回退：基线对比中，p95 延迟退化不超过 5%，且吞吐不低于基线的 95%。
- **SC-006**: 用户文档补齐“高性能最佳实践”并通过评审：包含心智模型（≤5 关键词）、成本模型、优化阶梯、反模式与排障入口，且内容与诊断字段命名保持一致。
