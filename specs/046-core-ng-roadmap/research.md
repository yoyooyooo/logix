# Research: 046 After 045 路线图（core-ng 长期演进与切换门槛）

本 research 用于把“After 045 怎么走”的关键裁决收敛为可执行的里程碑与 gate，避免依赖 drafts 或口头共识。

## Decision 0：路线图的正式落点

**Chosen**：路线图以 `specs/046-core-ng-roadmap/roadmap.md` 作为可扫描主入口，draft topic（`docs/specs/drafts/topics/logix-ng-architecture/`）仅作为探索性参考。

**Rationale**：045 是分支点，后续优先级必须在 specs 侧固化，否则容易发生“草案漂移”与执行停滞。

## Decision 1：045 的定位（分支点，而非重写本体）

**Chosen**：045 的核心交付是 Kernel Contract + 证据分档 + 对照验证跑道（harness），使内核替换从“赌局”变成“可证据化的工程动作”。

**Rationale**：在没有对照验证与证据门禁的情况下推进 NG 重写，极易出现语义漂移或负优化，且难以定位。

## Decision 2：039 的后续处置

**Chosen**：

- 短期继续推进 039，作为“当前内核加固”的性能地基；
- 中期复用 039 的证据跑道与 guardrails 拦截 core-ng 的负优化；
- 长期在 core-ng 成为默认后，039 可“达标冻结”（不删，只停止扩展并保留证据作为对照基线）。

**Rationale**：你希望“能放心做平台”，那当前内核必须先达到一个可解释、可测量、可重复的稳定态；同时 039 的证据口径能反向保护 core-ng 的演进质量。

## Decision 3：core-ng 的进阶是否必须依赖 Vite/AOT 工具链？

**Chosen**：不必须。把 core-ng 的进阶拆成两条路线：

- **Runtime-only NG（主线）**：依赖 045 的 Kernel Contract，在运行时层面做整型化/零分配/复用/缓存等“纯赚”改进，逐步达成 M2/M3；
- **Compiler-assisted NG（可选）**：只有当证据显示解释层成为主瓶颈且难以再降时，才启动 AOT/工具链路线，并要求另立 spec 承载。

### 为什么“不做编译时”仍然能做到极致性能？

这里的关键是把“编译时”拆开看：你要的是 **运行时执行形态像编译产物**（线性指令流、整型索引、buffer 复用、零分配），而不是一定要把工作放到 Vite/构建阶段。

Runtime-only 仍然可以拿到大量“编译型收益”，典型路径是：

1) **构造期一次性预编译（JIT-style）**：在 `ManagedRuntime` / `ModuleRuntime` 创建期把重活做完（Static IR → Exec IR），热路径只执行“预编译好的 plan/访问器/bitset/typedarray”。  
   - 这正是 039 的方向：消灭字符串 split/往返、TypedArray/Bitset/Accessor 预编译、诊断 off 零分配闸门。
2) **数据结构与内存布局优化**：把热循环从对象/Map/Set 推到 TypedArray/位运算/SoA，减少 GC 与 deopt 风险；必要时进一步把“计划/图结构”驻留并复用。
3) **证据门禁驱动的“保守可解释”**：任何可能引入负优化的中间态（比如“ID 化到一半又还原回 string”）在证据门禁下不允许存在；这比“有没有 AOT”更影响极致性能的可持续性。

因此，“不做编译时”并不等于“只能做小修小补”，而是先把 **运行时执行内核**做到接近编译产物的形态；等 runtime 手段把收益榨干后，再考虑工具链作为最后一公里加速器。

### 045 的意义会不会因此少一半？

不会。045 的价值不在于“直接给你性能收益”，而在于把 NG 演进的风险面收敛成可控的工程机制：

- **契约化替换点**：无论 core-ng 走 runtime-only 还是 compiler-assisted，最终都需要通过 Kernel Contract 接入上层；没有 045，你的 AOT 产物也很难不把上层生态拖下水。
- **可对照验证跑道**：极致性能优化最怕“负优化/语义漂移/证据断裂”。045 的 harness + 证据分档让你能反复试错并拦截风险；这对 AOT 路线同样是前置条件，而不是可选项。
- **降低长期税**：工具链一旦引入就是长期维护成本。045 允许你先在不引入工具链的情况下把内核替换跑通，再用证据决定是否值得追加工具链投资。

**Guardrails**（若启动 Compiler-assisted NG）：

- 必须仍然落到统一最小 IR（Static IR + Dynamic Trace）并保留稳定锚点；
- 必须给出可解释的降级/回退口径（失败时回退到 runtime-only 路径）；
- 必须通过 `$logix-perf-evidence` 的 Node+Browser before/after/diff 证明收益与无回归。

## Decision 4：语义改变与新观测口径的隔离

**Chosen**：

- time-slicing（043）与 diagnostics sampling（044）都属于“语义/口径改变”，必须独立推进，不混入纯优化链路；
- 039/045 的主线优先聚焦“纯优化 + 契约 + 证据门禁”。

**Rationale**：避免把“纯赚优化”与“改变语义/口径”绑死，导致验证困难与心智模型复杂化。

## Decision 5：底层是否需要“从一开始就以未来构建阶段优化为目标”？

**Chosen**：需要，但目标应表述为 **AOT-ready（编译友好）而非 AOT-required（编译依赖）**。

这意味着我们从一开始就要保证：

- 底层的契约与工件形态足够“数据化/可序列化/可对比”（统一最小 IR + 稳定锚点），使得未来的构建阶段优化可以被建模为：**用另一种生产方式生成同一套 Static IR / Exec IR 工件**；
- 运行时可以在“构造期预编译（JIT-style）”与“直接消费预编译工件（AOT-style）”之间切换，但这不应改变对外语义，也不应把上层生态绑死在某个工具链上；
- “Vite/插件/宏”只是实现手段选择之一，不应该成为内核演进的前置依赖或命名锚点。

**Rationale**：

- 你追求的“极致性能”主要来自热路径执行形态（线性计划、整型索引、buffer 复用、零分配），这可以先通过 runtime 构造期预编译实现；
- 未来若要把预编译前移到构建阶段，最大的成本通常不是算法，而是“契约/工件/解释链路”的不稳定；提前把这些裁决固化（045 + 统一最小 IR）反而是最省成本的做法；
- 把工具链当作“可选加速器”而不是前置条件，能显著降低长期税与迁移风险。

## Decision 6：046 的定位（路线图 vs NG 总控/调度）

**Chosen**：046 不只是一页“里程碑路线图”，而是 core-ng 路线的**总控/调度 spec**：

- `roadmap.md`：负责“里程碑 + 硬门槛”一眼可见；
- `spec-registry.json`：负责“关系事实源”（members/依赖/状态，脚本可解析）；
- `spec-registry.md`：负责“人读阐述”（证据门禁 + kernel support matrix 口径 + 表格展示）；
- `tasks.md`：只做跨 spec 调度（创建/推进/回写证据入口），不实现 runtime 代码。

**Rationale**：你希望 After 045 有更长期、更可执行的目标；如果只有里程碑而没有“登记与调度机制”，NG 路线会再次退化为草案碎片、口头共识与并行真相源，最终让迁移路径变长且难以治理。
