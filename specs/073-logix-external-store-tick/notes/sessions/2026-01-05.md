# 2026-01-05 session（实现前探索）

## 为什么要 flush

- 073 Phase 3/4 涉及 core/runtime + react 双侧长链路改造；先把入口与关键不变量落盘，避免下次重读全仓。

## 发现（事实）

- `ModuleRuntime` 在 commit 时会：
  - 写入 `SubscriptionRef`（state 单写）并发布 `commitHub`（`StateChangeWithMeta`）；
  - 调用 `selectorGraph.onCommit(state, meta, dirtySet, diagnosticsLevel)`（static lane ReadQuery 的增量 recompute+通知）；
  - `diagnostics=off` 时允许 `onCommit` 先于 `Debug.record(state:update)`（perf-sensitive ordering）。
- React 侧当前存在两套 store：
  - `ModuleRuntimeExternalStore.ts`：按 module 维护 `currentState`，订阅 `changesWithMeta`，按 priority 节流 notify；
  - `ModuleRuntimeSelectorExternalStore.ts`：按 selectorId 维护 `currentValue`，订阅 `changesReadQueryWithMeta`（static lane 由 SelectorGraph 驱动）。
  - 该模型在“组件同 render 订阅多个模块”时存在跨模块 tearing 风险（不同 store 独立 notify 时序）。
- `DebugSink.record.ts` 支持 `trace:*` 事件的统一投影与 diagnostics 分级；`trace:tick` 可作为 GenericTraceEventType 接入（无需改事件联合类型）。

## 当前实现策略（草案）

- 在 core 增加 runtime 级服务：
  - `RuntimeStore`：持有 `{tickSeq, topicVersionByKey, moduleStates}` 的同步快照 + topic 订阅（对 React 提供单一快照真理源）。
  - `TickScheduler`：合并 microtask 内的提交信号，预算/step cap 防卡死；tick settle 时一次性 bump tickSeq + topicVersion，并按 topic 的聚合 priority 通知。
- selector-topic 版本：扩展 `SelectorGraph.onCommit` 输出 changedSelectorIds（复用现有 dirty roots 索引；不新增 per-commit 扫描），供 TickScheduler/RuntimeStore bump `${ModuleInstanceKey}::rq:${selectorId}`。

## 下一步阻断项

- Phase 3：先实现 TickScheduler/RuntimeStore + ModuleRuntime commit 通知（T020–T024），再上 `trace:tick` + tests（T025–T029），之后才能安全做 React cutover（Phase 4）。

