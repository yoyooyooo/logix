# Feature Specification: 保守自动补全 Platform-Grade 锚点声明（单一真相源）

**Feature Branch**: `079-platform-anchor-autofill`  
**Created**: 2026-01-09  
**Status**: Draft  
**Input**: 以编译期/构建期的保守补全方式，把“试跑/IR/全双工”所需的关键锚点缺口补齐，并回写到源码保持单一真相源（宁可错过不可乱补）

## Context

在平台终态里，“可诊断/可回放/可 diff”要求系统同时具备：

- **Static IR**：从源码可枚举的结构化锚点（用于关系图、门禁、解释链路）；
- **Dynamic Evidence**：试跑/运行期的证据（用于对齐检查与灰盒验证）；
- **Full-Duplex**：代码与图谱之间可稳定往返（受限子集可解析/可重写）。

现实中大量缺口并不是“能力不存在”，而是“关键锚点没显式写出来/写法不可解析”：例如忘记声明模块服务依赖、缺少 source 元数据导致无法跳转、装配关系未显式化导致试跑/门禁难以解释等。

本特性以“单一真相源”为铁律：任何补全都必须回写到源码（锚点声明即权威），避免引入第二份长期权威事实源。

## Clarifications

### Session 2026-01-09

- AUTO: Q: `services` 已显式存在但不完整时是否自动补齐？→ A: 不补齐、不覆盖（作者声明即权威）；仅输出 deviation 线索与 reason codes。
- AUTO: Q: 自动补全写入的默认端口名是什么？→ A: `port = serviceId`（确定性；不推断业务别名）。
- AUTO: Q: 当无法保证最小 diff / 写回安全时怎么办？→ A: 宁可失败或 report-only；不得为“能写回”而引入格式化噪音或不确定写法。

## Anchor Definitions（本特性覆盖的锚点范围）

为保证验收可判定，本特性把“可补全锚点”限定为以下三类（均以源码中的显式字段/元数据作为权威落点）：

1. **服务依赖锚点声明**：模块对其输入服务依赖的显式声明（例如模块定义中的 `services` 映射）。
2. **装配依赖锚点声明**：模块装配/组合关系的显式声明（例如实现/装配配置中的 `imports` 或等价机制）。
3. **定位锚点元数据**：用于解释链路与 code link 的定位元数据（例如模块的 `dev.source`、动作定义的 `source` 或等价元数据）。
4. **Workflow stepKey 锚点声明**：WorkflowDef（例如 `Workflow.make({ ... })`）中每个 step 的 `key`（稳定地址）；缺失/冲突会直接破坏全双工/门禁化（对齐 075）。

## Related Work（与现有规划/特性的关系）

- 与 `specs/078-module-service-manifest/spec.md` 互补：`078` 固化“显式声明 → Manifest IR 导出”，本特性负责在缺失声明时做保守补全以降低手写成本。
- Loader Pattern 参考：`docs/specs/sdd-platform/workbench/15-module-runtime-reflection-loader.md`。本特性不强依赖 AST，优先把“加载态/构建态可控执行”作为结构提取的入口，并把补全结果写回源码保持单一真相源。

## Non-Goals（明确不做）

- 不尝试推断业务语义别名（例如自动把 `ArchiveServiceTag` 命名为 `archiver`）；端口命名默认按 `FR-011`。
- 不把运行期证据当作长期权威事实源（TrialRun/Loader 采集仅作为建议/校验输入；权威永远是源码中的锚点声明）。
- 不覆盖“语义反射”类能力（例如具名逻辑插槽/Intent Rules）；应拆为独立特性以避免与锚点补全耦合。
- 不尝试“从运行期数据推断 stepKey”：stepKey 补全只在 Platform-Grade 子集内、且能确定性定位 step 节点时进行；不确定必须跳过并报告（宁可错过不可乱补）。

## Full-Duplex Deviation Reporting（报告范围，默认不自动改写）

本特性把“全双工写法偏离”的报告范围限定为：那些会显著降低平台侧解析/重写能力、或导致 IR 解释链断裂的代码形态。至少应覆盖：

- 依赖访问绕过统一锚点（例如未通过依赖锚点入口表达依赖关系，导致平台无法构建依赖图）。
- 规则/链路写法落在不可解析形态（例如把可解析规则拆成中间变量/动态组合，导致平台只能降级为黑盒）。
- 依赖/规则出现在条件/动态路径，导致无法静态确定（应报告为“不确定/需显式声明/需人工决策”，而不是自动补全）。

## Assumptions & Dependencies

- 自动补全依赖于“服务可被稳定标识（ServiceId）”的前提（权威规则见 `specs/078-module-service-manifest/contracts/service-id.md`）；若无法获得稳定标识，必须跳过补全并解释原因。
- 自动补全依赖于“源码定位可被稳定表达”的前提；若无法提供可用的定位信息，必须跳过补全并解释原因。
- 自动补全仅面向“能以高置信度确定”的依赖使用点；对条件/动态/歧义依赖默认不补全（宁可错过）。
- 补全报告是辅助诊断与门禁输入，但不应成为长期权威真相源；权威真相源始终是源码中的显式锚点声明（例如 `services`、装配关系、source 元数据等）。

## User Scenarios & Testing _(mandatory)_

### User Story 1 - 自动补全“依赖锚点声明”缺口（服务依赖/装配依赖） (Priority: P1)

作为业务模块作者/平台使用者，我希望当模块存在“明确的依赖使用点”，但缺少对应的“显式依赖锚点声明”时，系统能自动补全缺失声明，使平台可以稳定构建依赖图、进行试跑前置校验与门禁，并把缺失/冲突定位到可解释的锚点。

**Why this priority**: 缺失依赖声明会直接导致 Static IR 不完整，进而使试跑/诊断/回放对齐只能依赖运行时痕迹或人工约定，难以做到稳定与极致解释。

**Independent Test**: 在一个存在依赖使用点但缺失显式声明的模块上运行补全能力，断言源码被更新为显式依赖声明，且结果稳定可复现（重复运行不产生额外变更）。

**Acceptance Scenarios**:

1. **Given** 一个模块缺失服务依赖声明且存在可确定的服务使用点，**When** 运行补全能力，**Then** 该模块的源码被更新为显式服务依赖声明（去重、稳定排序、可 diff），并产出补全报告。
2. **Given** 一个模块缺失装配依赖声明且存在可确定的装配依赖使用点，**When** 运行补全能力，**Then** 该模块的源码被更新为显式装配依赖声明（去重、稳定排序、可 diff），并产出补全报告。
3. **Given** 一个模块不存在任何可确定的依赖使用点，**When** 运行补全能力，**Then** 不产生源码变更，并在报告中标记为“无需补全”。

---

### User Story 2 - 自动补全“定位锚点元数据”缺口（可解释/可跳转） (Priority: P1)

作为平台/Devtools 用户，我希望当模块/动作等缺少可用的定位锚点时，系统能自动补全定位元数据，使 IR 与证据链路能提供稳定的 code link（跳转/定位），并在 diff/门禁中减少“无法解释的漂移”。

**Why this priority**: 没有定位锚点就无法在 Devtools/审计中解释“这条依赖/这条规则来自哪里”，会显著降低可诊断性与全双工可用性。

**Independent Test**: 在缺少定位元数据的模块上运行补全能力，断言源码被更新为显式定位元数据，且 Manifest/IR 能给出可用的 code link。

**Acceptance Scenarios**:

1. **Given** 一个模块缺少可用的定位元数据，**When** 运行补全能力，**Then** 模块源码被补全定位元数据，并在报告中列出补全项。
2. **Given** 一个动作定义缺少可用的定位元数据，**When** 运行补全能力，**Then** 动作定义被补全定位元数据，并在报告中列出补全项。
3. **Given** 定位信息无法被可靠补全，**When** 运行补全能力，**Then** 不修改源码，并在报告中标记为“定位不可解析/不稳定”。

---

### User Story 3 - 宁可错过不可乱补：高置信度门槛 + 可解释报告 (Priority: P1)

作为 Runtime/平台维护者，我希望自动补全严格保守：只在“补全结果可被高置信度确定且可解释”时才写入源码；一旦存在歧义、条件依赖或无法确定稳定标识/定位，就必须跳过补全并输出可解释原因，避免引入错误锚点造成试跑、IR 与全双工链路漂移。

**Why this priority**: 错误的锚点会把系统推向“看似可诊断但事实不可信”，代价远高于漏报；因此必须以零误补为第一优先级。

**Independent Test**: 构造包含歧义/条件依赖/动态依赖/不可定位的模块，运行补全能力后断言不修改源码，同时报告给出明确的“未补全原因”。

**Acceptance Scenarios**:

1. **Given** 某模块存在无法高置信度判定的依赖（例如条件依赖或动态依赖），**When** 运行补全能力，**Then** 不修改该模块源码，并在报告中列出未补全原因与建议的人工处理方式。
2. **Given** 某模块的依赖无法映射到稳定标识，**When** 运行补全能力，**Then** 不修改该模块源码，并在报告中标记为“标识不稳定/不可解析”。
3. **Given** 某模块存在潜在可修复但不确定的“全双工子集写法偏离”，**When** 运行补全能力，**Then** 默认只报告不自动改写，并解释为何不满足自动修复门槛。

---

### User Story 4 - 已显式声明的锚点不被自动改写（可控演进） (Priority: P2)

作为业务模块作者，我希望一旦我显式写了某个锚点声明（例如 `services`、装配声明、定位元数据），系统就不再自动改写该锚点（避免引入“工具悄悄改了我写的契约/资产”的不确定性）；但系统仍应能报告“声明与使用可能不一致”的线索，便于我显式修正。

**Why this priority**: 只有把“权威锚点”保持在源码中且由作者显式控制，才能避免并行真相源与隐式漂移。

**Independent Test**: 对已显式声明相关锚点的模块运行补全能力，断言源码不变，且报告能说明该模块被跳过（并可选提供建议）。

**Acceptance Scenarios**:

1. **Given** 一个模块已显式声明 `services`（包含空对象），**When** 运行补全能力，**Then** 不对该模块做任何源码修改，并在报告中标记为“已声明，跳过服务补全”。
2. **Given** 一个模块已显式声明 `services` 但只覆盖了部分依赖，**When** 运行补全能力，**Then** 仍不修改源码（保持作者权威），但报告 MUST 输出“声明 vs 使用可能不一致”的 deviation 线索（可聚合 reason codes）。
3. **Given** 一个模块已显式声明装配依赖锚点，**When** 运行补全能力，**Then** 不对该模块做任何源码修改，并在报告中标记为“已声明，跳过装配补全”。
4. **Given** 一个模块已显式提供定位元数据，**When** 运行补全能力，**Then** 不对该模块做任何源码修改，并在报告中标记为“已声明，跳过定位补全”。

### Edge Cases

- 模块只部分可确定依赖/定位：必须只补全高置信度子集，并明确报告未补全项；不得为了“补全率”引入猜测。
- `services` 已显式存在但不完整：默认不自动补齐（避免工具隐式改写作者契约），仅输出 deviation 线索与 reason codes。
- 多处/多符号别名指向同一 `serviceId`：补全时按 `serviceId` 去重，端口名默认 `port = serviceId`（不生成业务别名）。
- 同一依赖在模块内多处使用：必须去重，补全结果不应产生重复项。
- 依赖在条件分支/异常分支内出现：默认视为不确定，必须跳过补全并解释原因。
- 模块存在 `services: {}`：视为已声明（作者明确表达“无/已处理依赖”），不得自动补全。
- 存在多个候选依赖/定位来源：必须视为不确定并跳过补全（除非能给出确定性的消歧规则且可解释）。
- 重复运行：必须幂等（第二次运行不应产生新的源码差异）。

## Requirements _(mandatory)_

### Functional Requirements

- **FR-001**: 系统 MUST 提供“保守自动补全 Platform-Grade 锚点声明”的能力，用于补齐试跑/IR/全双工所需的关键源码锚点。
- **FR-002**: 系统 MUST 支持自动补全模块的服务依赖锚点声明：当模块未显式声明服务依赖锚点且存在可确定的服务使用点时，补全该声明。
- **FR-003**: 系统 MUST 支持自动补全模块的装配依赖锚点声明：当模块未显式声明装配依赖锚点且存在可确定的装配依赖使用点时，补全该声明。
- **FR-004**: 系统 MUST 支持自动补全定位锚点元数据：当模块/动作缺少可用定位信息且可被可靠补全时，补全定位元数据以支持解释与跳转。
- **FR-005**: 系统 MUST 仅在“对应锚点字段未被显式声明”时才允许补全；对任何已显式声明该锚点的对象 MUST 不做源码修改。
- **FR-006**: 系统 MUST 以“宁可错过不可乱补”为原则：仅当补全结果可被高置信度确定且可解释时才允许写入；任何存在歧义/不确定性的补全 MUST 不得被自动写入。
- **FR-007**: 系统 MUST 将补全结果回写到源码，使锚点声明成为唯一持久化真相源；系统 MUST NOT 生成或依赖任何长期存在的第二份权威锚点清单（例如 sidecar 作为真相源）。
- **FR-008**: 系统 MUST 产出结构化补全报告，至少包含：已修改对象清单、被跳过对象清单（含原因）、未补全项清单（含原因与建议）。
- **FR-009**: 系统 MUST 生成确定性的补全结果：稳定排序、去重、可 diff，并保证在相同输入下重复运行的输出一致。
- **FR-010**: 用户 MUST 能以“只报告不改动”的方式运行该能力，以便在写回前审阅补全结果与跳过原因。
- **FR-011**: 自动补全写入服务依赖锚点时，系统 MUST 使用确定性的端口命名策略；默认以稳定服务标识作为端口名（`port = serviceId`），不得尝试推断业务别名。
- **FR-012**: 系统 MUST 支持识别“全双工受限子集”的写法偏离，并在补全报告中给出可解释的定位与建议；默认不得自动改写业务逻辑语句以避免语义风险。
- **FR-013**: 系统 MUST 支持 Workflow stepKey 的保守补全：当 WorkflowDef 的 step 缺少 `key` 且可被确定性补全时，补齐缺失字段；若存在重复 key 或无法确定性补全，MUST 不写回并输出 reason codes（对齐 `specs/075-workflow-codegen-ir/contracts/ir.md` 与 `contracts/workflow-stepkey-autofill.md`）。

### Non-Functional Requirements (Performance & Diagnosability)

- **NFR-001**: 自动补全与报告 MUST 是确定性的：同一代码输入产生同一补全/报告输出；不得依赖时间、随机数或进程级可变状态。
- **NFR-002**: 系统 MUST 保证最小化改动面：只允许写入“缺失的锚点字段”，不得引入与补全无关的格式或语义变更。
- **NFR-003**: 报告 MUST 是 Slim 且可序列化（JSON），便于在 CI/Devtools 中展示与门禁化。
- **NFR-004**: 该能力 MUST 不引入运行时常驻成本；其效果完全通过源码显式声明体现。
- **NFR-005**: 若该能力引入 breaking 行为（例如将“缺失锚点”升级为门禁失败），系统 MUST 提供迁移说明，且遵循 forward-only（无兼容层/无弃用期）。

### Key Entities _(include if feature involves data)_

- **Platform-Grade 锚点声明**: 为试跑/IR/全双工提供结构化、可枚举、可跳转的源码锚点集合（权威真相源）。
- **补全报告 (Autofill Report)**: 结构化输出，解释哪些对象被修改/跳过，以及未补全原因与建议。
- **高置信度判定**: 仅在无歧义且可解释的情况下允许写入的判定规则集合。

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: 对任何输入代码，补全能力对“已显式声明对应锚点”的对象产生的源码改动数为 0。
- **SC-002**: 补全能力在存在不确定依赖/定位时不会写入源码，并在报告中为每个未补全项提供明确原因（可枚举的 reason code 或等价字段）。
- **SC-003**: 补全能力具备幂等性：在同一代码输入上连续运行两次，第二次产生的源码差异为 0。
- **SC-004**: 补全报告可被机器解析并用于门禁：在同一输入上输出稳定，可直接用于 diff/审计。
